! function() {
    var t = !1;
    try {
        document
    } catch (e) {
        t = !0
    }
    t && (self.Worker || (self.Worker = function(t) {
        var e = this;
        this.id = Math.random().toString(36).substr(2, 5), this.eventListeners = {
            message: []
        }, self.addEventListener("message", (function(t) {
            if (t.data._from === e.id) {
                var i = new MessageEvent("message");
                i.initMessageEvent("message", !1, !1, t.data.message, e, "", null, []), e.dispatchEvent(i), e.onmessage && e.onmessage(i)
            }
        }));
        var i = self.location.pathname,
            n = "/" == t.charAt(0) ? t : "/" + t,
            s = i.substring(0, i.lastIndexOf("/")) + n;
        self.postMessage({
            _subworker: !0,
            cmd: "newWorker",
            id: this.id,
            path: s
        })
    }, Worker.prototype = {
        onerror: null,
        onmessage: null,
        postMessage: function(t, e) {
            self.postMessage({
                _subworker: !0,
                id: this.id,
                cmd: "passMessage",
                message: t,
                transfer: e
            }, e)
        },
        terminate: function() {
            self.postMessage({
                _subworker: !0,
                cmd: "terminate",
                id: this.id
            })
        },
        addEventListener: function(t, e, i) {
            this.eventListeners[t] && this.eventListeners[t].push(e)
        },
        removeEventListener: function(t, e, i) {
            if (t in this.eventListeners) {
                var n = this.eventListeners[t].indexOf(e); - 1 !== n && this.eventListeners[t].splice(n, 1)
            }
        },
        dispatchEvent: function(t) {
            for (var e = this.eventListeners[t.type], i = 0; i < e.length; i++) e[i](t)
        }
    }));
    var e = {},
        i = {
            newWorker: function(t) {
                var i = new Worker(t.data.path);
                i.addEventListener("message", (function(e) {
                    var i = {
                        _from: t.data.id,
                        message: e.data
                    };
                    t.target.postMessage(i)
                })), e[t.data.id] = i
            },
            terminate: function(t) {
                e[t.data.id].terminate()
            },
            passMessage: function(t) {
                e[t.data.id].postMessage(t.data.message, t.data.transfer)
            }
        },
        n = function(t) {
            t.data._subworker && i[t.data.cmd](t)
        },
        s = Worker;
    Worker = function(t) {
        if (this.constructor !== Worker) throw new TypeError("Failed to construct 'Worker': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
        var e = t.indexOf("blob:"); - 1 !== e && 0 !== e && (t = t.substring(e));
        var i = new s(t);
        return i.addEventListener("message", n), i
    }
}(),
    function() {
        function t(t, e) {
            var i = new XMLHttpRequest;
            i.onreadystatechange = function() {
                4 === i.readyState && e(i.responseText)
            }, i.open("GET", t, !0), i.send()
        }

        function e(t, e, i) {
            Object.defineProperty ? Object.defineProperty(t, e, i) : t[e] = i.get()
        }
        var i, n = window.CSS;
        n || (window.CSS = n = {}), n.supports || (n.supports = function t(e, i) {
            if ("paint" == e) return !0;
            if (i) {
                var n = c.contentDocument.body;
                return n.style.cssText = e + ":" + i, n.style.cssText.length > 0
            }
            for (var s, r, o, a, l = /(^|not|(or)|(and))\s*\(\s*(.+?)\s*:(.+?)\)\s*|(.)/gi; o = l.exec(e);) {
                if (o[6]) return !1;
                a = t(o[4], o[5]), r = o[2] ? r || a : o[3] ? r && a : (s = !o[1], a)
            }
            return r == s
        }), n.escape || (n.escape = function(t) {
            return t.replace(/([^\w-])/g, "\\$1")
        });
        var s = {};

        function r(t, e) {
            var i = parseFloat(t);
            this.value = isNaN(i) ? t : i, this.unit = e
        }
        n.registerProperty || (n.registerProperty = function(t) {
            s[t.name] = t
        }), r.prototype.toString = function() {
            return this.value + ("number" == this.unit ? "" : this.unit)
        }, r.prototype.valueOf = function() {
            return this.value
        }, "Hz Q ch cm deg dpcm dpi ddpx em ex fr grad in kHz mm ms number pc percent pt px rad rem s turn vh vmax vmin vw".split(" ").forEach((function(t) {
            n[t] || (n[t] = function(e) {
                return new r(e, t)
            })
        }));
        var o = /(background|mask|cursor|-image|-source)/,
            a = !!n.paintWorklet;
        a || (i = new st, e(n, "paintWorklet", {
            enumerable: !0,
            configurable: !0,
            get: function() {
                return i
            }
        }));
        var l = "css-paint-polyfill",
            h = document.createElement(l);
        a || document.documentElement.appendChild(h);
        var c = document.createElement("iframe");
        c.style.cssText = "position:absolute; left:0; top:-999px; width:1px; height:1px;", h.appendChild(c);
        var d = document.createElement("style");
        d.id = l, d.$$isPaint = !0, h.appendChild(d);
        var u = d.sheet,
            p = h.style,
            m = !1,
            g = [],
            f = /(paint\(|-moz-element\(#paint-|-webkit-canvas\(paint-|[('"]blob:[^'"#]+#paint=|[('"]data:image\/paint-)/,
            y = "getCSSCanvasContext" in document,
            v = (p.backgroundImage = "-moz-element(#" + l + ")") === p.backgroundImage,
            w = "function" == typeof Promise;
        p.cssText = "display:none !important;";
        var b = window.requestAnimationFrame || setTimeout,
            x = function() {
                return window.devicePixelRatio || 1
            },
            S = {},
            M = {},
            C = 0;

        function _(t) {
            var e = t.bit ^= 1;
            return t.instances[e] || (t.instances[e] = new t.Painter)
        }

        function E(t, e) {
            var i = t.cssText,
                n = f.test(i);
            if (!0 === e.isNew && n && i !== (i = R(i)) && (t = function(t, e) {
                for (var i = t.parentStyleSheet, n = t.parentRule, s = (n || i).cssRules, r = s.length - 1, o = 0; o <= r; o++)
                    if (s[o] === t) {
                        (n || i).deleteRule(o), r = o;
                        break
                    } if (null != e) {
                    if (n) {
                        var a = n.appendRule(e);
                        return n.cssRules[a]
                    }
                    return i.insertRule(e, r), i.cssRules[r]
                }
            }(t, i)), n) {
                var s, r, o, a = t.selectorText,
                    l = W(t.style);
                if (s = null == e.counters[a] ? e.counters[a] = 1 : ++e.counters[a], null != M[r = "sheet" + e.sheetId + "\n" + a + "\n" + s]) {
                    if ((o = M[r]).selector === a) return o.rule = t, void(o.cssText !== l && e.toProcess.push(o));
                    e.toRemove.push(o)
                } else o = M[r] = {
                    key: r,
                    selector: a,
                    cssText: l,
                    properties: {},
                    rule: t
                }, e.toProcess.push(o.selector)
            }
        }

        function P(t, e) {
            if (!("ownerSVGElement" in t)) {
                e(t);
                for (var i = t.firstElementChild; i;) P(i, e), i = i.nextElementSibling
            }
        }

        function T() {
            for (var t, e = [].slice.call(document.styleSheets), i = {
                toProcess: [],
                toRemove: [],
                counters: {},
                isNew: !1,
                sheetId: null,
                rules: null
            }, n = 0; n < e.length; n++) {
                var s = e[n].ownerNode;
                if (!s.$$isPaint) {
                    try {
                        i.rules = s.sheet.cssRules
                    } catch (t) {
                        continue
                    }
                    if (i.sheetId = s.$$paintid, i.isNew = null == i.sheetId, i.isNew) {
                        if (i.sheetId = s.$$paintid = ++C, !1 === L(s)) continue;
                        t = !0
                    }
                    A(s.sheet, E, i)
                }
            }
            for (var r = i.toRemove.length; r--;) delete M[i.toRemove[r].key];
            i.toProcess.length > 0 && U(i.toProcess.join(", ")), t && U("[data-css-paint]", !0)
        }

        function A(e, i, n) {
            var s = [
                    [0, e.cssRules]
                ],
                r = s[0],
                o = r[1];
            if (o)
                for (var a = 0; s.length > 0; a++)
                    if (a >= o.length) {
                        s.pop();
                        var l = s.length;
                        l > 0 && (o = (r = s[l - 1])[1], a = r[0])
                    } else {
                        r[0] = a;
                        var h = o[a];
                        if (3 !== h.type)
                            if (1 === h.type) {
                                var c = i(h, n);
                                void 0 !== c && (n = c)
                            } else h.cssRules && h.cssRules.length > 0 && s.push([0, h.cssRules]);
                        else {
                            if (h.$$isPaint) continue;
                            var d = h.media && h.media.mediaText;
                            if (d && !self.matchMedia(d).matches) continue;
                            if (/ts\.g.{7}is\.com\/css/.test(h.href)) continue;
                            h.$$isPaint = !0, t(h.href, k)
                        }
                    } return n
        }

        function L(e) {
            if (!e.$$isPaint) {
                if (e.href) return t(e.href, k), !1;
                for (var i = e.childNodes.length; i--;) {
                    var n = e.childNodes[i].nodeValue,
                        s = R(n);
                    s !== n && (e.childNodes[i].nodeValue = s)
                }
            }
        }

        function k(t) {
            var e = function(t) {
                var e = c.contentDocument.body,
                    i = document.createElement("style");
                return i.media = "print", i.$$paintid = ++C, i.appendChild(document.createTextNode(t)), e.appendChild(i), i.sheet.remove = function() {
                    return e.removeChild(i)
                }, i.sheet
            }(R(t));
            try {
                e._ = e.cssRules.length
            } catch (t) {
                var i = function() {
                    e && I(e), e = null, clearTimeout(n)
                };
                e.ownerNode.onload = e.ownerNode.onerror = i;
                var n = setTimeout(i, 5e3);
                return
            }
            I(e)
        }

        function I(t) {
            var e = "";
            if (A(t, (function(t) {
                if (1 === t.type) {
                    for (var i = "", n = 0; n < t.style.length; n++) {
                        var s = t.style.item(n),
                            r = t.style.getPropertyValue(s);
                        f.test(r) && (i = s + ": " + r + t.style.getPropertyPriority(s) + ";")
                    }
                    if (i) {
                        i = t.selectorText + "{" + i + "}";
                        for (var o = t; o = o.parentRule;) i = "" + o.cssText.match(/^[\s\S]+?\{/)[0] + i + "}";
                        e += i
                    }
                }
            })), t.remove(), e) {
                var i = document.createElement("style");
                i.appendChild(document.createTextNode(e)), h.appendChild(i), T()
            }
        }

        function R(t) {
            return t.replace(/(;|,|\b)paint\s*\(\s*(['"]?)(.+?)\2\s*\)(;|,|!|\b|$)/g, "$1url(data:image/paint-$3,=)$4")
        }
        var D, O, F, N = [];

        function B(t, e) {
            e && (t.$$paintObservedProperties = null, t.$$paintGeometry && !t.$$paintGeometry.live && (t.$$paintGeometry = null)), !0 !== t.$$paintPending && (t.$$paintPending = !0, -1 === N.indexOf(t) && 1 === N.push(t) && b(V))
        }

        function V() {
            for (var t, e = 0; e < N.length; e++) N[e] && "style" === N[e].localName && (t = !0, N[e] = null);
            if (t) return b(V), void T();
            var i = N.length && N.some((function(t) {
                return t && !0 === t.$$needsOverrides
            }));
            for (i && K(); N.length;) {
                var n = N.pop();
                n && q(n)
            }
            i && Q()
        }

        function U(t, e) {
            try {
                for (var i = document.querySelectorAll(t), n = 0; n < i.length; n++) B(i[n], e)
            } catch (t) {}
        }

        function z(t, e, i) {
            for (var n = t.length, s = function() {
                --n || e.apply(null, i || g)
            }, r = 0; r < t.length; r++) {
                var o = new Image;
                o.onload = s, o.onerror = onerror, o.src = t[r]
            }
        }

        function H(t) {
            var e = t.$$paintId;
            return null == e && (e = t.$$paintId = ++X), e
        }

        function G(t) {
            var e = t.$$paintRule,
                i = H(t);
            if (Number(t.getAttribute("data-css-paint")) !== i && t.setAttribute("data-css-paint", i), null == e) {
                var n = u.insertRule('[data-css-paint="' + i + '"] {}', u.cssRules.length);
                e = t.$$paintRule = u.cssRules[n]
            }
            return e
        }

        function W(t) {
            var e = t.cssText;
            if (e) return e;
            e = "";
            for (var i = 0, n = void 0; i < t.length; i++) 0 !== i && (e += " "), e += n = t[i], e += ":", e += t.getPropertyValue(n), e += ";";
            return e
        }

        function q(t) {
            var e = getComputedStyle(t);
            if (t.$$paintObservedProperties && !t.$$needsOverrides)
                for (var i = 0; i < t.$$paintObservedProperties.length; i++) {
                    var n = t.$$paintObservedProperties[i];
                    if (e.getPropertyValue(n).trim() !== t.$$paintedPropertyValues[n]) {
                        $(t, e);
                        break
                    }
                } else if (t.$$paintId || f.test(W(e))) $(t, e);
            else {
                var s = t.getAttribute("style");
                f.test(s) && (t.style.cssText = s.replace(/;\s*$/, "") + "; " + t.style.cssText, $(t))
            } t.$$paintPending = !1
        }

        function j(t) {
            t.$$paintGeometry && !t.$$paintGeometry.live && (t.$$paintGeometry = null), B(t)
        }
        var Y = {
                get: function(t) {
                    var e = s[t],
                        i = e && !1 === e.inherits ? O.style.getPropertyValue(t) : Y.getRaw(t);
                    if (null == i && e) i = e.initialValue;
                    else if (e && e.syntax) {
                        var r = e.syntax.replace(/[<>\s]/g, "");
                        "function" == typeof n[r] && (i = n[r](i))
                    }
                    return "string" == typeof i && (i = i.trim()), i
                },
                getRaw: function(t) {
                    if (t in F) return F[t];
                    var e = D.getPropertyValue(t);
                    return "string" == typeof e && (e = e.trim()), F[t] = e
                }
            },
            J = window.ResizeObserver && new window.ResizeObserver((function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i = t[e],
                        n = i.target.$$paintGeometry;
                    n ? n.live = !0 : n = i.target.$$paintGeometry = {
                        width: 0,
                        height: 0,
                        live: !0
                    };
                    var s = i.borderBoxSize;
                    if (s && s.length && (s = s[0]), s) n.width = 0 | s.inlineSize, n.height = 0 | s.blockSize;
                    else {
                        var r = getComputedStyle(i.target),
                            o = parseFloat(r.paddingLeft) + parseFloat(r.paddingRight),
                            a = parseFloat(r.paddingTop) + parseFloat(r.paddingBottom);
                        n.width = Math.round((i.contentRect.right - i.contentRect.left || i.contentRect.width) + o), n.height = Math.round((i.contentRect.bottom - i.contentRect.top || i.contentRect.height) + a)
                    }
                    B(i.target, !0)
                }
            })),
            X = 0;

        function $(t, e) {
            !0 === t.$$needsOverrides && K();
            var i, n = D = null == e ? getComputedStyle(t) : e;
            O = t, F = {};
            var s = [];
            t.$$paintPending = !1;
            var r = function(t) {
                return t.$$paintGeometry || (t.$$paintGeometry = {
                    width: t.clientWidth,
                    height: t.clientHeight,
                    live: !1
                })
            }(t);
            ! function(t) {
                J && !t.$$paintGeometry.live && (t.$$paintGeometry.live = !0, J.observe(t))
            }(t), r = {
                width: r.width,
                height: r.height
            };
            for (var a = x(), l = t.$$paintedProperties, c = 0; c < n.length; c++) {
                var d = n[c],
                    u = Y.getRaw(d),
                    p = /(,|\b|^)(?:url\((['"]?))?((?:-moz-element\(#|-webkit-canvas\()paint-\d+-([^;,]+)|(?:data:image\/paint-|blob:[^'"#]+#paint=)([^"';, ]+)(?:[;,].*?)?)\2\)(;|,|\s|\b|$)/g,
                    m = "",
                    g = 0,
                    f = [],
                    w = !1,
                    b = !1,
                    M = void 0,
                    C = void 0,
                    E = !1,
                    P = r;
                if (o.test(d) && "-webkit-border-image" !== d) {
                    if (/border-image/.test(d)) {
                        var T = P.width,
                            A = P.height,
                            L = nt(Y.getRaw("border-image-slice").replace(/\sfill/, "").split(" ")),
                            k = nt(Y.getRaw("border-width").split(" ")),
                            I = nt(Y.getRaw("border-image-outset").split(" "));
                        T += it("0" != L.left && parseFloat(k.left) || 0, I.left || 0, !0), T += it("0" != L.right && parseFloat(k.right) || 0, I.right || 0, !0), A += it("0" != L.top && parseFloat(k.top) || 0, I.top || 0, !0), E = !0, P = {
                            width: T,
                            height: A += it("0" != L.bottom && parseFloat(k.bottom) || 0, I.bottom || 0, !0)
                        }
                    }
                    for (; C = p.exec(u);) {
                        !1 === b && (M = H(t)), b = !0, m += u.substring(0, C.index);
                        var R = C[4] || C[5],
                            N = C[3],
                            B = S[R],
                            V = B && B.Painter.contextOptions || {},
                            U = E || !1 === V.scaling ? 1 : a,
                            W = void 0;
                        B && (B.Painter.inputProperties && s.push.apply(s, B.Painter.inputProperties), W = _(B)), !0 === V.nativePixels && (P.width *= a, P.height *= a, U = 1);
                        var q = U * P.width,
                            j = U * P.height,
                            X = t.$$paintContext,
                            $ = "paint-" + M + "-" + R,
                            Z = X && X.canvas;
                        if (!Z || Z.width != q || Z.height != j || !0 === y && X && $ !== X.id) {
                            if (!0 === y)(X = document.getCSSCanvasContext("2d", $, q, j)).id = $, t.$$paintContext && X.clearRect(0, 0, q, j);
                            else {
                                var st = !1;
                                Z || ((Z = document.createElement("canvas")).id = $, st = v), Z.width = q, Z.height = j, st && (Z.style.display = "none", h.appendChild(Z)), X = Z.getContext("2d")
                            }
                            t.$$paintContext = X, X.imageSmoothingEnabled = !1, 1 !== U && X.scale(U, U)
                        } else X.clearRect(0, 0, q, j);
                        if (W && (X.save(), X.beginPath(), W.paint(X, P, Y), X.closePath(), X.restore(), !1 === y && !v && "resetTransform" in X && X.resetTransform()), m += C[1], !0 === y) m += "-webkit-canvas(" + $ + ")", (null == C[4] || Z && Z.id !== $) && (w = !0);
                        else if (!0 === v) m += "-moz-element(#" + $ + ")", null == C[4] && (w = !0), Z && Z.id !== $ && (Z.id = $, w = !0);
                        else {
                            var rt = Z.toDataURL("image/png").replace("/png", "/paint-" + R);
                            if ("function" == typeof MSBlobBuilder && (rt = tt(rt, R)), f.push(rt), m += 'url("' + rt + '")', rt !== N || !i) {
                                var ot = N ? N.indexOf("#") : -1;
                                ~ot && URL.revokeObjectURL(N.substring(0, ot)), w = !0
                            }
                            N = rt
                        }
                        m += C[6], g = C.index + C[0].length
                    }!1 !== b || null == l || null == l[d] ? (m += u.substring(g), w && (i || (i = G(t)), null == l && (l = t.$$paintedProperties = {}), l[d] = !0, "background" === d.substring(0, 10) && 1 !== a && et(i.style, "background-size", "100% 100%"), /mask/.test(d) && 1 !== a && (et(i.style, "mask-size", "contain"), y && et(i.style, "-webkit-mask-size", "contain")), /border-image/.test(d) && y && (et(i.style, "border-color", "initial"), et(i.style, "image-rendering", "optimizeSpeed")), 0 === f.length ? et(i.style, d, m) : z(f, et, [i.style, d, m]))) : (i || (i = G(t)), i.style.removeProperty(d), J && J.unobserve(t), t.$$paintGeometry && (t.$$paintGeometry.live = !1))
                }
            }
            t.$$paintObservedProperties = 0 === s.length ? null : s;
            for (var at = t.$$paintedPropertyValues = {}, lt = 0; lt < s.length; lt++) {
                var ht = s[lt];
                at[ht] = Y.getRaw(ht)
            }!0 === t.$$needsOverrides && Q(), t.$$needsOverrides = null
        }
        var Z = 0;

        function K() {
            Z++ || (d.disabled = !0)
        }

        function Q() {
            --Z || (d.disabled = !1)
        }

        function tt(t, e) {
            for (var i = atob(t.split(",")[1]), n = new Uint8Array(i.length), s = 0; s < i.length; s++) n[s] = i.charCodeAt(s);
            return URL.createObjectURL(new Blob([n])) + "#paint=" + e
        }

        function et(t, e, i) {
            var n = m;
            m = !0, t.setProperty(e, i, "important"), m = n
        }

        function it(t, e, i) {
            var n = i ? 0 : t,
                s = parseFloat(e);
            return e ? e.match("px") ? n + s : (e.match("%") && (s /= 100), t * s) : n
        }

        function nt(t) {
            return {
                top: t[0],
                bottom: t[2] || t[0],
                left: t[3] || t[1] || t[0],
                right: t[1] || t[0]
            }
        }

        function st() {}
        if (st.prototype.addModule = function(i) {
            var n, s, r = this;
            return w && (n = new Promise((function(t) {
                return s = t
            }))), t(i, (function(t) {
                var i = {
                    registerPaint: function(t, e) {
                        ! function(t, e, i) {
                            S[t] = {
                                worklet: i,
                                Painter: e,
                                properties: e.inputProperties ? [].slice.call(e.inputProperties) : [],
                                bit: 0,
                                instances: []
                            };
                            for (var n = "", s = u.cssRules.length; s--;) {
                                var r = u.cssRules[s]; - 1 !== r.style.cssText.indexOf("-" + t) && (n += r.selectorText)
                            }
                            n && U(n, !0)
                        }(t, e, {
                            context: i,
                            realm: n
                        })
                    }
                };
                e(i, "devicePixelRatio", {
                    get: x
                }), i.self = i;
                var n = new function(t, e) {
                    var i = document.createElement("iframe");
                    i.style.cssText = "position:absolute; left:0; top:-999px; width:1px; height:1px;", e.appendChild(i);
                    var n = i.contentWindow,
                        s = n.document,
                        r = "var window,$hook";
                    for (var o in n) o in t || "eval" === o || (r += ",", r += o);
                    for (var a in t) r += ",", r += a, r += "=self.", r += a;
                    var l = s.createElement("script");
                    l.appendChild(s.createTextNode('function $hook(self,console) {"use strict";\n\t\t' + r + ";return function() {return eval(arguments[0])}}")), s.body.appendChild(l), this.exec = n.$hook(t, console)
                }(i, c.contentDocument && c.contentDocument.body || h);
                t = (r.transpile || String)(t), n.exec(t), s && s()
            })), n
        }, !a) try {
            ! function() {
                var t = !1;
                new MutationObserver((function(e) {
                    if (!0 !== t && !Z) {
                        t = !0;
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i],
                                s = n.target,
                                r = void 0,
                                o = void 0;
                            if (!s || !("ownerSVGElement" in s))
                                if ("childList" === n.type) {
                                    if (r = n.addedNodes)
                                        for (var a = 0; a < r.length; a++) 1 === r[a].nodeType && P(r[a], B);
                                    if (o = n.removedNodes)
                                        for (var l = 0; l < o.length; l++) J && o[l].$$paintGeometry && (o[l].$$paintGeometry.live = !1, J && J.unobserve(o[l]))
                                } else if ("attributes" === n.type && 1 === s.nodeType) {
                                    if ("data-css-paint" === n.attributeName && n.oldValue && null != s.$$paintId && !s.getAttribute("data-css-paint")) {
                                        H(s);
                                        continue
                                    }
                                    P(s, j)
                                }
                        }
                        t = !1
                    }
                })).observe(document.body, {
                    childList: !0,
                    attributes: !0,
                    attributeOldValue: !0,
                    subtree: !0
                });
                var i = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute"),
                    n = i.value;
                i.value = function(t, e) {
                    return "style" === t && f.test(e) && (e = R(e), H(this), this.$$needsOverrides = !0, j(this)), n.call(this, t, e)
                }, e(Element.prototype, "setAttribute", i);
                var s = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute"),
                    r = s.value;
                s.value = function(t) {
                    if ("data-css-paint" !== t) return r.call(this, t)
                }, e(Element.prototype, "removeAttribute", s);
                var a = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "style"),
                    l = a.get;
                a.set = function(t) {
                    return a.get.call(this).cssText = t
                }, a.get = function() {
                    var t = l.call(this);
                    return t.ownerElement !== this && e(t, "ownerElement", {
                        value: this
                    }), t
                }, e(HTMLElement.prototype, "style", a);
                var h = {},
                    c = Object.getOwnPropertyDescriptor(CSSStyleDeclaration.prototype, "cssText"),
                    d = c.set;
                c.set = function(t) {
                    if (!Z && f.test(t)) {
                        t = t && R(t);
                        var e = this.ownerElement;
                        e && (H(e), e.$$needsOverrides = !0, j(e))
                    }
                    return d.call(this, t)
                }, h.cssText = c, Object.keys((window.CSS2Properties || CSSStyleDeclaration).prototype).filter((function(t) {
                    return o.test(t)
                })).forEach((function(t) {
                    var e = t.replace(/([A-Z])/g, "-$1").toLowerCase();
                    h[t] = {
                        configurable: !0,
                        enumerable: !0,
                        get: function() {
                            var t = this.getPropertyPriority(e);
                            return this.getPropertyValue(e) + (t ? " !" + t : "")
                        },
                        set: function(i) {
                            var n = String(i).match(/^(.*?)\s*(?:!\s*(important)\s*)?$/);
                            return this.setProperty(e, n[1], n[2]), this[t]
                        }
                    }
                }));
                var u = Object.getOwnPropertyDescriptor(CSSStyleDeclaration.prototype, "setProperty"),
                    p = u.value;
                u.value = function(t, e, i) {
                    if (!m && !Z && f.test(e)) {
                        e = e && R(e);
                        var n = this.ownerElement;
                        n && (H(n), n.$$needsOverrides = !0, j(n))
                    }
                    p.call(this, t, e, i)
                }, h.setProperty = u, Object.defineProperties(CSSStyleDeclaration.prototype, h), window.CSS2Properties && Object.defineProperties(window.CSS2Properties.prototype, h), addEventListener("resize", (function() {
                    U("[data-css-paint]")
                }));
                var g = {
                    passive: !0
                };

                function y(t) {
                    for (var e = t.target; e;) 1 === e.nodeType && B(e), e = e.parentNode
                } ["animationiteration", "animationend", "animationstart", "transitionstart", "transitionend", "transitionrun", "transitioncancel", "mouseover", "mouseout", "mousedown", "mouseup", "focus", "blur"].forEach((function(t) {
                    addEventListener(t, y, g)
                })), T()
            }()
        } catch (t) {}
    }(),
    function() {
        if ("undefined" != typeof document && !("adoptedStyleSheets" in document)) {
            var t = "ShadyCSS" in window && !ShadyCSS.nativeShadow,
                e = document.implementation.createHTMLDocument(""),
                i = new WeakMap,
                n = "object" == typeof DOMException ? Error : DOMException,
                s = Object.defineProperty,
                r = Array.prototype.forEach,
                o = /@import.+?;?$/gm,
                a = CSSStyleSheet.prototype;
            a.replace = function() {
                return Promise.reject(new n("Can't call replace on non-constructed CSSStyleSheets."))
            }, a.replaceSync = function() {
                throw new n("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.")
            };
            var l = new WeakMap,
                h = new WeakMap,
                c = new WeakMap,
                d = new WeakMap,
                u = P.prototype;
            u.replace = function(t) {
                try {
                    return this.replaceSync(t), Promise.resolve(this)
                } catch (t) {
                    return Promise.reject(t)
                }
            }, u.replaceSync = function(t) {
                if (E(this), "string" == typeof t) {
                    var e = this;
                    l.get(e).textContent = function(t) {
                        var e = t.replace(o, "");
                        return e !== t && console.warn("@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418"), e.trim()
                    }(t), d.set(e, []), h.get(e).forEach((function(t) {
                        t.isConnected() && _(e, C(e, t))
                    }))
                }
            }, s(u, "cssRules", {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return E(this), l.get(this).sheet.cssRules
                }
            }), s(u, "media", {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return E(this), l.get(this).sheet.media
                }
            }), ["addRule", "deleteRule", "insertRule", "removeRule"].forEach((function(t) {
                u[t] = function() {
                    var e = this;
                    E(e);
                    var i = arguments;
                    d.get(e).push({
                        method: t,
                        args: i
                    }), h.get(e).forEach((function(n) {
                        if (n.isConnected()) {
                            var s = C(e, n).sheet;
                            s[t].apply(s, i)
                        }
                    }));
                    var n = l.get(e).sheet;
                    return n[t].apply(n, i)
                }
            })), s(P, Symbol.hasInstance, {
                configurable: !0,
                value: S
            });
            var p = {
                    childList: !0,
                    subtree: !0
                },
                m = new WeakMap,
                g = new WeakMap,
                f = new WeakMap,
                y = new WeakMap;
            if (R.prototype = {
                isConnected: function() {
                    var t = g.get(this);
                    return t instanceof Document ? "loading" !== t.readyState : function(t) {
                        return "isConnected" in t ? t.isConnected : document.contains(t)
                    }(t.host)
                },
                connect: function() {
                    var t = k(this);
                    y.get(this).observe(t, p), f.get(this).length > 0 && I(this), L(t, (function(t) {
                        T(t).connect()
                    }))
                },
                disconnect: function() {
                    y.get(this).disconnect()
                },
                update: function(t) {
                    var e = this,
                        i = g.get(e) === document ? "Document" : "ShadowRoot";
                    if (!Array.isArray(t)) throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + i + ": Iterator getter is not callable.");
                    if (!t.every(S)) throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + i + ": Failed to convert value to 'CSSStyleSheet'");
                    if (t.some(M)) throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + i + ": Can't adopt non-constructed stylesheets");
                    e.sheets = t;
                    var n, s, r = f.get(e),
                        o = (n = t).filter((function(t, e) {
                            return n.indexOf(t) === e
                        }));
                    (s = o, r.filter((function(t) {
                        return -1 === s.indexOf(t)
                    }))).forEach((function(t) {
                        var i;
                        (i = C(t, e)).parentNode.removeChild(i),
                            function(t, e) {
                                c.get(t).delete(e), h.set(t, h.get(t).filter((function(t) {
                                    return t !== e
                                })))
                            }(t, e)
                    })), f.set(e, o), e.isConnected() && o.length > 0 && I(e)
                }
            }, window.CSSStyleSheet = P, A(Document), "ShadowRoot" in window) {
                A(ShadowRoot);
                var v = Element.prototype,
                    w = v.attachShadow;
                v.attachShadow = function(t) {
                    var e = w.call(this, t);
                    return "closed" === t.mode && i.set(this, e), e
                }
            }
            var b = T(document);
            b.isConnected() ? b.connect() : document.addEventListener("DOMContentLoaded", b.connect.bind(b))
        }

        function x(t) {
            return t.shadowRoot || i.get(t)
        }

        function S(t) {
            return "object" == typeof t && (u.isPrototypeOf(t) || a.isPrototypeOf(t))
        }

        function M(t) {
            return "object" == typeof t && a.isPrototypeOf(t)
        }

        function C(t, e) {
            return c.get(t).get(e)
        }

        function _(t, e) {
            requestAnimationFrame((function() {
                e.textContent = l.get(t).textContent, d.get(t).forEach((function(t) {
                    return e.sheet[t.method].apply(e.sheet, t.args)
                }))
            }))
        }

        function E(t) {
            if (!l.has(t)) throw new TypeError("Illegal invocation")
        }

        function P() {
            var t = this,
                i = document.createElement("style");
            e.body.appendChild(i), l.set(t, i), h.set(t, []), c.set(t, new WeakMap), d.set(t, [])
        }

        function T(t) {
            var e = m.get(t);
            return e || (e = new R(t), m.set(t, e)), e
        }

        function A(t) {
            s(t.prototype, "adoptedStyleSheets", {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return T(this).sheets
                },
                set: function(t) {
                    T(this).update(t)
                }
            })
        }

        function L(t, e) {
            for (var i = document.createNodeIterator(t, NodeFilter.SHOW_ELEMENT, (function(t) {
                return x(t) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
            }), null, !1), n = void 0; n = i.nextNode();) e(x(n))
        }

        function k(t) {
            var e = g.get(t);
            return e instanceof Document ? e.body : e
        }

        function I(t) {
            var e = document.createDocumentFragment(),
                i = f.get(t),
                n = y.get(t),
                s = k(t);
            n.disconnect(), i.forEach((function(i) {
                e.appendChild(C(i, t) || function(t, e) {
                    var i = document.createElement("style");
                    return c.get(t).set(e, i), h.get(t).push(e), i
                }(i, t))
            })), s.insertBefore(e, null), n.observe(s, p), i.forEach((function(e) {
                _(e, C(e, t))
            }))
        }

        function R(e) {
            var i = this;
            i.sheets = [], g.set(i, e), f.set(i, []), y.set(i, new MutationObserver((function(e, n) {
                document ? e.forEach((function(e) {
                    t || r.call(e.addedNodes, (function(t) {
                        t instanceof Element && L(t, (function(t) {
                            T(t).connect()
                        }))
                    })), r.call(e.removedNodes, (function(e) {
                        e instanceof Element && (function(t, e) {
                            return e instanceof HTMLStyleElement && f.get(t).some((function(e) {
                                return C(e, t)
                            }))
                        }(i, e) && I(i), t || L(e, (function(t) {
                            T(t).disconnect()
                        })))
                    }))
                })) : n.disconnect()
            })))
        }
    }();
class t {
    addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const i = this._listeners;
        void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
    }
    hasEventListener(t, e) {
        if (void 0 === this._listeners) return !1;
        const i = this._listeners;
        return void 0 !== i[t] && -1 !== i[t].indexOf(e)
    }
    removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const i = this._listeners[t];
        if (void 0 !== i) {
            const t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
        }
    }
    dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
            t.target = this;
            const i = e.slice(0);
            for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
            t.target = null
        }
    }
}
const e = [];
for (let t = 0; t < 256; t++) e[t] = (t < 16 ? "0" : "") + t.toString(16);
const i = Math.PI / 180,
    n = 180 / Math.PI;

function s() {
    const t = 4294967295 * Math.random() | 0,
        i = 4294967295 * Math.random() | 0,
        n = 4294967295 * Math.random() | 0,
        s = 4294967295 * Math.random() | 0;
    return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & s] + e[s >> 8 & 255] + e[s >> 16 & 255] + e[s >> 24 & 255]).toUpperCase()
}

function r(t, e, i) {
    return Math.max(e, Math.min(i, t))
}

function o(t, e, i) {
    return (1 - i) * t + i * e
}

function a(t) {
    return 0 == (t & t - 1) && 0 !== t
}

function l(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
}
class h {
    constructor(t = 0, e = 0) {
        this.x = t, this.y = e
    }
    get width() {
        return this.x
    }
    set width(t) {
        this.x = t
    }
    get height() {
        return this.y
    }
    set height(t) {
        this.y = t
    }
    set(t, e) {
        return this.x = t, this.y = e, this
    }
    setScalar(t) {
        return this.x = t, this.y = t, this
    }
    setX(t) {
        return this.x = t, this
    }
    setY(t) {
        return this.y = t, this
    }
    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this
    }
    add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
    }
    addScalar(t) {
        return this.x += t, this.y += t, this
    }
    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this
    }
    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this
    }
    sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this
    }
    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this
    }
    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this
    }
    divide(t) {
        return this.x /= t.x, this.y /= t.y, this
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }
    applyMatrix3(t) {
        const e = this.x,
            i = this.y,
            n = t.elements;
        return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }
    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
    }
    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
    }
    clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(t) {
        return this.x * t.x + this.y * t.y
    }
    cross(t) {
        return this.x * t.y - this.y * t.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
        const e = this.x - t.x,
            i = this.y - t.y;
        return e * e + i * i
    }
    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
    }
    lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t
    }
    fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
    }
    rotateAround(t, e) {
        const i = Math.cos(e),
            n = Math.sin(e),
            s = this.x - t.x,
            r = this.y - t.y;
        return this.x = s * i - r * n + t.x, this.y = s * n + r * i + t.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }
}
h.prototype.isVector2 = !0;
class c {
    constructor() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    set(t, e, i, n, s, r, o, a, l) {
        const h = this.elements;
        return h[0] = t, h[1] = n, h[2] = o, h[3] = e, h[4] = s, h[5] = a, h[6] = i, h[7] = r, h[8] = l, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(t) {
        const e = this.elements,
            i = t.elements;
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
    }
    extractBasis(t, e, i) {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(t) {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    }
    multiply(t) {
        return this.multiplyMatrices(this, t)
    }
    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e) {
        const i = t.elements,
            n = e.elements,
            s = this.elements,
            r = i[0],
            o = i[3],
            a = i[6],
            l = i[1],
            h = i[4],
            c = i[7],
            d = i[2],
            u = i[5],
            p = i[8],
            m = n[0],
            g = n[3],
            f = n[6],
            y = n[1],
            v = n[4],
            w = n[7],
            b = n[2],
            x = n[5],
            S = n[8];
        return s[0] = r * m + o * y + a * b, s[3] = r * g + o * v + a * x, s[6] = r * f + o * w + a * S, s[1] = l * m + h * y + c * b, s[4] = l * g + h * v + c * x, s[7] = l * f + h * w + c * S, s[2] = d * m + u * y + p * b, s[5] = d * g + u * v + p * x, s[8] = d * f + u * w + p * S, this
    }
    multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
    }
    determinant() {
        const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            s = t[3],
            r = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            h = t[8];
        return e * r * h - e * o * l - i * s * h + i * o * a + n * s * l - n * r * a
    }
    invert() {
        const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            s = t[3],
            r = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            h = t[8],
            c = h * r - o * l,
            d = o * a - h * s,
            u = l * s - r * a,
            p = e * c + i * d + n * u;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / p;
        return t[0] = c * m, t[1] = (n * l - h * i) * m, t[2] = (o * i - n * r) * m, t[3] = d * m, t[4] = (h * e - n * a) * m, t[5] = (n * s - o * e) * m, t[6] = u * m, t[7] = (i * a - l * e) * m, t[8] = (r * e - i * s) * m, this
    }
    transpose() {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
    }
    getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose()
    }
    transposeIntoArray(t) {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
    }
    setUvTransform(t, e, i, n, s, r, o) {
        const a = Math.cos(s),
            l = Math.sin(s);
        return this.set(i * a, i * l, -i * (a * r + l * o) + r + t, -n * l, n * a, -n * (-l * r + a * o) + o + e, 0, 0, 1), this
    }
    scale(t, e) {
        const i = this.elements;
        return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
    }
    rotate(t) {
        const e = Math.cos(t),
            i = Math.sin(t),
            n = this.elements,
            s = n[0],
            r = n[3],
            o = n[6],
            a = n[1],
            l = n[4],
            h = n[7];
        return n[0] = e * s + i * a, n[3] = e * r + i * l, n[6] = e * o + i * h, n[1] = -i * s + e * a, n[4] = -i * r + e * l, n[7] = -i * o + e * h, this
    }
    translate(t, e) {
        const i = this.elements;
        return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
    }
    equals(t) {
        const e = this.elements,
            i = t.elements;
        for (let t = 0; t < 9; t++)
            if (e[t] !== i[t]) return !1;
        return !0
    }
    fromArray(t, e = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
        return this
    }
    toArray(t = [], e = 0) {
        const i = this.elements;
        return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
    }
    clone() {
        return (new this.constructor).fromArray(this.elements)
    }
}
let d;
c.prototype.isMatrix3 = !0;
class u {
    static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
            void 0 === d && (d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), d.width = t.width, d.height = t.height;
            const i = d.getContext("2d");
            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = d
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
    }
}
let p = 0;
class m extends t {
    constructor(t = m.DEFAULT_IMAGE, e = m.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, o = 1008, a = 1023, l = 1009, d = 1, u = 3e3) {
        super(), Object.defineProperty(this, "id", {
            value: p++
        }), this.uuid = s(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = d, this.format = a, this.internalFormat = null, this.type = l, this.offset = new h(0, 0), this.repeat = new h(1, 1), this.center = new h(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new c, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.version = 0, this.onUpdate = null
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
    }
    toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (void 0 !== this.image) {
            const n = this.image;
            if (void 0 === n.uuid && (n.uuid = s()), !e && void 0 === t.images[n.uuid]) {
                let e;
                if (Array.isArray(n)) {
                    e = [];
                    for (let t = 0, i = n.length; t < i; t++) n[t].isDataTexture ? e.push(g(n[t].image)) : e.push(g(n[t]))
                } else e = g(n);
                t.images[n.uuid] = {
                    uuid: n.uuid,
                    url: e
                }
            }
            i.image = n.uuid
        }
        return e || (t.textures[this.uuid] = i), i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(t) {
        if (300 !== this.mapping) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case 1e3:
                t.x = t.x - Math.floor(t.x);
                break;
            case 1001:
                t.x = t.x < 0 ? 0 : 1;
                break;
            case 1002:
                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case 1e3:
                t.y = t.y - Math.floor(t.y);
                break;
            case 1001:
                t.y = t.y < 0 ? 0 : 1;
                break;
            case 1002:
                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
        }
        return this.flipY && (t.y = 1 - t.y), t
    }
    set needsUpdate(t) {
        !0 === t && this.version++
    }
}

function g(t) {
    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? u.getDataURL(t) : t.data ? {
        data: Array.prototype.slice.call(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
m.DEFAULT_IMAGE = void 0, m.DEFAULT_MAPPING = 300, m.prototype.isTexture = !0;
class f {
    constructor(t = 0, e = 0, i = 0, n = 1) {
        this.x = t, this.y = e, this.z = i, this.w = n
    }
    get width() {
        return this.z
    }
    set width(t) {
        this.z = t
    }
    get height() {
        return this.w
    }
    set height(t) {
        this.w = t
    }
    set(t, e, i, n) {
        return this.x = t, this.y = e, this.z = i, this.w = n, this
    }
    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
    }
    setX(t) {
        return this.x = t, this
    }
    setY(t) {
        return this.y = t, this
    }
    setZ(t) {
        return this.z = t, this
    }
    setW(t) {
        return this.w = t, this
    }
    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
    }
    add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
    }
    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
    }
    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }
    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }
    sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }
    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }
    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }
    applyMatrix4(t) {
        const e = this.x,
            i = this.y,
            n = this.z,
            s = this.w,
            r = t.elements;
        return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s, this
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }
    setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
    }
    setAxisAngleFromRotationMatrix(t) {
        let e, i, n, s;
        const r = .01,
            o = .1,
            a = t.elements,
            l = a[0],
            h = a[4],
            c = a[8],
            d = a[1],
            u = a[5],
            p = a[9],
            m = a[2],
            g = a[6],
            f = a[10];
        if (Math.abs(h - d) < r && Math.abs(c - m) < r && Math.abs(p - g) < r) {
            if (Math.abs(h + d) < o && Math.abs(c + m) < o && Math.abs(p + g) < o && Math.abs(l + u + f - 3) < o) return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (l + 1) / 2,
                a = (u + 1) / 2,
                y = (f + 1) / 2,
                v = (h + d) / 4,
                w = (c + m) / 4,
                b = (p + g) / 4;
            return t > a && t > y ? t < r ? (i = 0, n = .707106781, s = .707106781) : (i = Math.sqrt(t), n = v / i, s = w / i) : a > y ? a < r ? (i = .707106781, n = 0, s = .707106781) : (n = Math.sqrt(a), i = v / n, s = b / n) : y < r ? (i = .707106781, n = .707106781, s = 0) : (s = Math.sqrt(y), i = w / s, n = b / s), this.set(i, n, s, e), this
        }
        let y = Math.sqrt((g - p) * (g - p) + (c - m) * (c - m) + (d - h) * (d - h));
        return Math.abs(y) < .001 && (y = 1), this.x = (g - p) / y, this.y = (c - m) / y, this.z = (d - h) / y, this.w = Math.acos((l + u + f - 1) / 2), this
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }
    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }
    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
    }
    clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }
    lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
    }
    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }
    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }
    fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }
}
f.prototype.isVector4 = !0;
class y extends t {
    constructor(t, e, i) {
        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new f(0, 0, t, e), this.scissorTest = !1, this.viewport = new f(0, 0, t, e), i = i || {}, this.texture = new m(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }
    setTexture(t) {
        t.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
        }, this.texture = t
    }
    setSize(t, e, i = 1) {
        this.width === t && this.height === e && this.depth === i || (this.width = t, this.height = e, this.depth = i, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
y.prototype.isWebGLRenderTarget = !0;
(class extends y {
    constructor(t, e, i) {
        super(t, e, i), this.samples = 4
    }
    copy(t) {
        return super.copy.call(this, t), this.samples = t.samples, this
    }
}).prototype.isWebGLMultisampleRenderTarget = !0;
class v {
    constructor(t = 0, e = 0, i = 0, n = 1) {
        this._x = t, this._y = e, this._z = i, this._w = n
    }
    static slerp(t, e, i, n) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(t, e, n)
    }
    static slerpFlat(t, e, i, n, s, r, o) {
        let a = i[n + 0],
            l = i[n + 1],
            h = i[n + 2],
            c = i[n + 3];
        const d = s[r + 0],
            u = s[r + 1],
            p = s[r + 2],
            m = s[r + 3];
        if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = h, void(t[e + 3] = c);
        if (1 === o) return t[e + 0] = d, t[e + 1] = u, t[e + 2] = p, void(t[e + 3] = m);
        if (c !== m || a !== d || l !== u || h !== p) {
            let t = 1 - o;
            const e = a * d + l * u + h * p + c * m,
                i = e >= 0 ? 1 : -1,
                n = 1 - e * e;
            if (n > Number.EPSILON) {
                const s = Math.sqrt(n),
                    r = Math.atan2(s, e * i);
                t = Math.sin(t * r) / s, o = Math.sin(o * r) / s
            }
            const s = o * i;
            if (a = a * t + d * s, l = l * t + u * s, h = h * t + p * s, c = c * t + m * s, t === 1 - o) {
                const t = 1 / Math.sqrt(a * a + l * l + h * h + c * c);
                a *= t, l *= t, h *= t, c *= t
            }
        }
        t[e] = a, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
    }
    static multiplyQuaternionsFlat(t, e, i, n, s, r) {
        const o = i[n],
            a = i[n + 1],
            l = i[n + 2],
            h = i[n + 3],
            c = s[r],
            d = s[r + 1],
            u = s[r + 2],
            p = s[r + 3];
        return t[e] = o * p + h * c + a * u - l * d, t[e + 1] = a * p + h * d + l * c - o * u, t[e + 2] = l * p + h * u + o * d - a * c, t[e + 3] = h * p - o * c - a * d - l * u, t
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x = t, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y = t, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(t) {
        this._z = t, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(t) {
        this._w = t, this._onChangeCallback()
    }
    set(t, e, i, n) {
        return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
    }
    setFromEuler(t, e) {
        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const i = t._x,
            n = t._y,
            s = t._z,
            r = t._order,
            o = Math.cos,
            a = Math.sin,
            l = o(i / 2),
            h = o(n / 2),
            c = o(s / 2),
            d = a(i / 2),
            u = a(n / 2),
            p = a(s / 2);
        switch (r) {
            case "XYZ":
                this._x = d * h * c + l * u * p, this._y = l * u * c - d * h * p, this._z = l * h * p + d * u * c, this._w = l * h * c - d * u * p;
                break;
            case "YXZ":
                this._x = d * h * c + l * u * p, this._y = l * u * c - d * h * p, this._z = l * h * p - d * u * c, this._w = l * h * c + d * u * p;
                break;
            case "ZXY":
                this._x = d * h * c - l * u * p, this._y = l * u * c + d * h * p, this._z = l * h * p + d * u * c, this._w = l * h * c - d * u * p;
                break;
            case "ZYX":
                this._x = d * h * c - l * u * p, this._y = l * u * c + d * h * p, this._z = l * h * p - d * u * c, this._w = l * h * c + d * u * p;
                break;
            case "YZX":
                this._x = d * h * c + l * u * p, this._y = l * u * c + d * h * p, this._z = l * h * p - d * u * c, this._w = l * h * c - d * u * p;
                break;
            case "XZY":
                this._x = d * h * c - l * u * p, this._y = l * u * c - d * h * p, this._z = l * h * p + d * u * c, this._w = l * h * c + d * u * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r)
        }
        return !1 !== e && this._onChangeCallback(), this
    }
    setFromAxisAngle(t, e) {
        const i = e / 2,
            n = Math.sin(i);
        return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
    }
    setFromRotationMatrix(t) {
        const e = t.elements,
            i = e[0],
            n = e[4],
            s = e[8],
            r = e[1],
            o = e[5],
            a = e[9],
            l = e[2],
            h = e[6],
            c = e[10],
            d = i + o + c;
        if (d > 0) {
            const t = .5 / Math.sqrt(d + 1);
            this._w = .25 / t, this._x = (h - a) * t, this._y = (s - l) * t, this._z = (r - n) * t
        } else if (i > o && i > c) {
            const t = 2 * Math.sqrt(1 + i - o - c);
            this._w = (h - a) / t, this._x = .25 * t, this._y = (n + r) / t, this._z = (s + l) / t
        } else if (o > c) {
            const t = 2 * Math.sqrt(1 + o - i - c);
            this._w = (s - l) / t, this._x = (n + r) / t, this._y = .25 * t, this._z = (a + h) / t
        } else {
            const t = 2 * Math.sqrt(1 + c - i - o);
            this._w = (r - n) / t, this._x = (s + l) / t, this._y = (a + h) / t, this._z = .25 * t
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(t, e) {
        let i = t.dot(e) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize()
    }
    angleTo(t) {
        return 2 * Math.acos(Math.abs(r(this.dot(t), -1, 1)))
    }
    rotateTowards(t, e) {
        const i = this.angleTo(t);
        if (0 === i) return this;
        const n = Math.min(1, e / i);
        return this.slerp(t, n), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let t = this.length();
        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
    }
    multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
    }
    premultiply(t) {
        return this.multiplyQuaternions(t, this)
    }
    multiplyQuaternions(t, e) {
        const i = t._x,
            n = t._y,
            s = t._z,
            r = t._w,
            o = e._x,
            a = e._y,
            l = e._z,
            h = e._w;
        return this._x = i * h + r * o + n * l - s * a, this._y = n * h + r * a + s * o - i * l, this._z = s * h + r * l + i * a - n * o, this._w = r * h - i * o - n * a - s * l, this._onChangeCallback(), this
    }
    slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const i = this._x,
            n = this._y,
            s = this._z,
            r = this._w;
        let o = r * t._w + i * t._x + n * t._y + s * t._z;
        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = r, this._x = i, this._y = n, this._z = s, this;
        const a = 1 - o * o;
        if (a <= Number.EPSILON) {
            const t = 1 - e;
            return this._w = t * r + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * s + e * this._z, this.normalize(), this._onChangeCallback(), this
        }
        const l = Math.sqrt(a),
            h = Math.atan2(l, o),
            c = Math.sin((1 - e) * h) / l,
            d = Math.sin(e * h) / l;
        return this._w = r * c + this._w * d, this._x = i * c + this._x * d, this._y = n * c + this._y * d, this._z = s * c + this._z * d, this._onChangeCallback(), this
    }
    slerpQuaternions(t, e, i) {
        this.copy(t).slerp(e, i)
    }
    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }
    fromArray(t, e = 0) {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
    }
    toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
    }
    fromBufferAttribute(t, e) {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
    }
    _onChange(t) {
        return this._onChangeCallback = t, this
    }
    _onChangeCallback() {}
}
v.prototype.isQuaternion = !0;
class w {
    constructor(t = 0, e = 0, i = 0) {
        this.x = t, this.y = e, this.z = i
    }
    set(t, e, i) {
        return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
    }
    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this
    }
    setX(t) {
        return this.x = t, this
    }
    setY(t) {
        return this.y = t, this
    }
    setZ(t) {
        return this.z = t, this
    }
    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }
    add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
    }
    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this
    }
    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
    }
    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
    }
    sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this
    }
    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
    }
    multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
    }
    multiplyVectors(t, e) {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
    }
    applyEuler(t) {
        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(x.setFromEuler(t))
    }
    applyAxisAngle(t, e) {
        return this.applyQuaternion(x.setFromAxisAngle(t, e))
    }
    applyMatrix3(t) {
        const e = this.x,
            i = this.y,
            n = this.z,
            s = t.elements;
        return this.x = s[0] * e + s[3] * i + s[6] * n, this.y = s[1] * e + s[4] * i + s[7] * n, this.z = s[2] * e + s[5] * i + s[8] * n, this
    }
    applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize()
    }
    applyMatrix4(t) {
        const e = this.x,
            i = this.y,
            n = this.z,
            s = t.elements,
            r = 1 / (s[3] * e + s[7] * i + s[11] * n + s[15]);
        return this.x = (s[0] * e + s[4] * i + s[8] * n + s[12]) * r, this.y = (s[1] * e + s[5] * i + s[9] * n + s[13]) * r, this.z = (s[2] * e + s[6] * i + s[10] * n + s[14]) * r, this
    }
    applyQuaternion(t) {
        const e = this.x,
            i = this.y,
            n = this.z,
            s = t.x,
            r = t.y,
            o = t.z,
            a = t.w,
            l = a * e + r * n - o * i,
            h = a * i + o * e - s * n,
            c = a * n + s * i - r * e,
            d = -s * e - r * i - o * n;
        return this.x = l * a + d * -s + h * -o - c * -r, this.y = h * a + d * -r + c * -s - l * -o, this.z = c * a + d * -o + l * -r - h * -s, this
    }
    project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }
    unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }
    transformDirection(t) {
        const e = this.x,
            i = this.y,
            n = this.z,
            s = t.elements;
        return this.x = s[0] * e + s[4] * i + s[8] * n, this.y = s[1] * e + s[5] * i + s[9] * n, this.z = s[2] * e + s[6] * i + s[10] * n, this.normalize()
    }
    divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }
    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
    }
    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
    }
    clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
    }
    lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
    }
    cross(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
    }
    crossVectors(t, e) {
        const i = t.x,
            n = t.y,
            s = t.z,
            r = e.x,
            o = e.y,
            a = e.z;
        return this.x = n * a - s * o, this.y = s * r - i * a, this.z = i * o - n * r, this
    }
    projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const i = t.dot(this) / e;
        return this.copy(t).multiplyScalar(i)
    }
    projectOnPlane(t) {
        return b.copy(this).projectOnVector(t), this.sub(b)
    }
    reflect(t) {
        return this.sub(b.copy(t).multiplyScalar(2 * this.dot(t)))
    }
    angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const i = this.dot(t) / e;
        return Math.acos(r(i, -1, 1))
    }
    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
        const e = this.x - t.x,
            i = this.y - t.y,
            n = this.z - t.z;
        return e * e + i * i + n * n
    }
    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }
    setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }
    setFromSphericalCoords(t, e, i) {
        const n = Math.sin(e) * t;
        return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
    }
    setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }
    setFromCylindricalCoords(t, e, i) {
        return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
    }
    setFromMatrixPosition(t) {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this
    }
    setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
            i = this.setFromMatrixColumn(t, 1).length(),
            n = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = i, this.z = n, this
    }
    setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e)
    }
    setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e)
    }
    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z
    }
    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
    }
    fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
}
w.prototype.isVector3 = !0;
const b = new w,
    x = new v;
class S {
    constructor(t = new w(1 / 0, 1 / 0, 1 / 0), e = new w(-1 / 0, -1 / 0, -1 / 0)) {
        this.min = t, this.max = e
    }
    set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
    }
    setFromArray(t) {
        let e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            s = -1 / 0,
            r = -1 / 0,
            o = -1 / 0;
        for (let a = 0, l = t.length; a < l; a += 3) {
            const l = t[a],
                h = t[a + 1],
                c = t[a + 2];
            l < e && (e = l), h < i && (i = h), c < n && (n = c), l > s && (s = l), h > r && (r = h), c > o && (o = c)
        }
        return this.min.set(e, i, n), this.max.set(s, r, o), this
    }
    setFromBufferAttribute(t) {
        let e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            s = -1 / 0,
            r = -1 / 0,
            o = -1 / 0;
        for (let a = 0, l = t.count; a < l; a++) {
            const l = t.getX(a),
                h = t.getY(a),
                c = t.getZ(a);
            l < e && (e = l), h < i && (i = h), c < n && (n = c), l > s && (s = l), h > r && (r = h), c > o && (o = c)
        }
        return this.min.set(e, i, n), this.max.set(s, r, o), this
    }
    setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this
    }
    setFromCenterAndSize(t, e) {
        const i = C.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
    }
    setFromObject(t) {
        return this.makeEmpty(), this.expandByObject(t)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(t) {
        return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new w), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(t) {
        return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new w), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
    }
    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
    }
    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }
    expandByObject(t) {
        t.updateWorldMatrix(!1, !1);
        const e = t.geometry;
        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), _.copy(e.boundingBox), _.applyMatrix4(t.matrixWorld), this.union(_));
        const i = t.children;
        for (let t = 0, e = i.length; t < e; t++) this.expandByObject(i[t]);
        return this
    }
    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }
    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }
    getParameter(t, e) {
        return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new w), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }
    intersectsSphere(t) {
        return this.clampPoint(t.center, C), C.distanceToSquared(t.center) <= t.radius * t.radius
    }
    intersectsPlane(t) {
        let e, i;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
    }
    intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(I), R.subVectors(this.max, I), E.subVectors(t.a, I), P.subVectors(t.b, I), T.subVectors(t.c, I), A.subVectors(P, E), L.subVectors(T, P), k.subVectors(E, T);
        let e = [0, -A.z, A.y, 0, -L.z, L.y, 0, -k.z, k.y, A.z, 0, -A.x, L.z, 0, -L.x, k.z, 0, -k.x, -A.y, A.x, 0, -L.y, L.x, 0, -k.y, k.x, 0];
        return !!F(e, E, P, T, R) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!F(e, E, P, T, R) && (D.crossVectors(A, L), e = [D.x, D.y, D.z], F(e, E, P, T, R)))
    }
    clampPoint(t, e) {
        return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new w), e.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t) {
        return C.copy(t).clamp(this.min, this.max).sub(t).length()
    }
    getBoundingSphere(t) {
        return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(C).length(), t
    }
    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
    }
    applyMatrix4(t) {
        return this.isEmpty() || (M[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), M[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), M[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), M[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), M[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), M[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), M[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), M[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(M)), this
    }
    translate(t) {
        return this.min.add(t), this.max.add(t), this
    }
    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}
S.prototype.isBox3 = !0;
const M = [new w, new w, new w, new w, new w, new w, new w, new w],
    C = new w,
    _ = new S,
    E = new w,
    P = new w,
    T = new w,
    A = new w,
    L = new w,
    k = new w,
    I = new w,
    R = new w,
    D = new w,
    O = new w;

function F(t, e, i, n, s) {
    for (let r = 0, o = t.length - 3; r <= o; r += 3) {
        O.fromArray(t, r);
        const o = s.x * Math.abs(O.x) + s.y * Math.abs(O.y) + s.z * Math.abs(O.z),
            a = e.dot(O),
            l = i.dot(O),
            h = n.dot(O);
        if (Math.max(-Math.max(a, l, h), Math.min(a, l, h)) > o) return !1
    }
    return !0
}
const N = new S,
    B = new w,
    V = new w,
    U = new w;
class z {
    constructor(t = new w, e = -1) {
        this.center = t, this.radius = e
    }
    set(t, e) {
        return this.center.copy(t), this.radius = e, this
    }
    setFromPoints(t, e) {
        const i = this.center;
        void 0 !== e ? i.copy(e) : N.setFromPoints(t).getCenter(i);
        let n = 0;
        for (let e = 0, s = t.length; e < s; e++) n = Math.max(n, i.distanceToSquared(t[e]));
        return this.radius = Math.sqrt(n), this
    }
    copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius
    }
    intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e
    }
    intersectsBox(t) {
        return t.intersectsSphere(this)
    }
    intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(t, e) {
        const i = this.center.distanceToSquared(t);
        return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new w), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
    }
    getBoundingBox(t) {
        return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new S), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }
    applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }
    translate(t) {
        return this.center.add(t), this
    }
    expandByPoint(t) {
        U.subVectors(t, this.center);
        const e = U.lengthSq();
        if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
                i = .5 * (t - this.radius);
            this.center.add(U.multiplyScalar(i / t)), this.radius += i
        }
        return this
    }
    union(t) {
        return V.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(B.copy(t.center).add(V)), this.expandByPoint(B.copy(t.center).sub(V)), this
    }
    equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const H = new w,
    G = new w,
    W = new w,
    q = new w,
    j = new w,
    Y = new w,
    J = new w;
class X {
    constructor(t = new w, e = new w(0, 0, -1)) {
        this.origin = t, this.direction = e
    }
    set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this
    }
    copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }
    at(t, e) {
        return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new w), e.copy(this.direction).multiplyScalar(t).add(this.origin)
    }
    lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this
    }
    recast(t) {
        return this.origin.copy(this.at(t, H)), this
    }
    closestPointToPoint(t, e) {
        void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new w), e.subVectors(t, this.origin);
        const i = e.dot(this.direction);
        return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
    }
    distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t))
    }
    distanceSqToPoint(t) {
        const e = H.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (H.copy(this.direction).multiplyScalar(e).add(this.origin), H.distanceToSquared(t))
    }
    distanceSqToSegment(t, e, i, n) {
        G.copy(t).add(e).multiplyScalar(.5), W.copy(e).sub(t).normalize(), q.copy(this.origin).sub(G);
        const s = .5 * t.distanceTo(e),
            r = -this.direction.dot(W),
            o = q.dot(this.direction),
            a = -q.dot(W),
            l = q.lengthSq(),
            h = Math.abs(1 - r * r);
        let c, d, u, p;
        if (h > 0)
            if (c = r * a - o, d = r * o - a, p = s * h, c >= 0)
                if (d >= -p)
                    if (d <= p) {
                        const t = 1 / h;
                        c *= t, d *= t, u = c * (c + r * d + 2 * o) + d * (r * c + d + 2 * a) + l
                    } else d = s, c = Math.max(0, -(r * d + o)), u = -c * c + d * (d + 2 * a) + l;
                else d = -s, c = Math.max(0, -(r * d + o)), u = -c * c + d * (d + 2 * a) + l;
            else d <= -p ? (c = Math.max(0, -(-r * s + o)), d = c > 0 ? -s : Math.min(Math.max(-s, -a), s), u = -c * c + d * (d + 2 * a) + l) : d <= p ? (c = 0, d = Math.min(Math.max(-s, -a), s), u = d * (d + 2 * a) + l) : (c = Math.max(0, -(r * s + o)), d = c > 0 ? s : Math.min(Math.max(-s, -a), s), u = -c * c + d * (d + 2 * a) + l);
        else d = r > 0 ? -s : s, c = Math.max(0, -(r * d + o)), u = -c * c + d * (d + 2 * a) + l;
        return i && i.copy(this.direction).multiplyScalar(c).add(this.origin), n && n.copy(W).multiplyScalar(d).add(G), u
    }
    intersectSphere(t, e) {
        H.subVectors(t.center, this.origin);
        const i = H.dot(this.direction),
            n = H.dot(H) - i * i,
            s = t.radius * t.radius;
        if (n > s) return null;
        const r = Math.sqrt(s - n),
            o = i - r,
            a = i + r;
        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
    }
    intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }
    distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const i = -(this.origin.dot(t.normal) + t.constant) / e;
        return i >= 0 ? i : null
    }
    intersectPlane(t, e) {
        const i = this.distanceToPlane(t);
        return null === i ? null : this.at(i, e)
    }
    intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        if (0 === e) return !0;
        return t.normal.dot(this.direction) * e < 0
    }
    intersectBox(t, e) {
        let i, n, s, r, o, a;
        const l = 1 / this.direction.x,
            h = 1 / this.direction.y,
            c = 1 / this.direction.z,
            d = this.origin;
        return l >= 0 ? (i = (t.min.x - d.x) * l, n = (t.max.x - d.x) * l) : (i = (t.max.x - d.x) * l, n = (t.min.x - d.x) * l), h >= 0 ? (s = (t.min.y - d.y) * h, r = (t.max.y - d.y) * h) : (s = (t.max.y - d.y) * h, r = (t.min.y - d.y) * h), i > r || s > n ? null : ((s > i || i != i) && (i = s), (r < n || n != n) && (n = r), c >= 0 ? (o = (t.min.z - d.z) * c, a = (t.max.z - d.z) * c) : (o = (t.max.z - d.z) * c, a = (t.min.z - d.z) * c), i > a || o > n ? null : ((o > i || i != i) && (i = o), (a < n || n != n) && (n = a), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
    }
    intersectsBox(t) {
        return null !== this.intersectBox(t, H)
    }
    intersectTriangle(t, e, i, n, s) {
        j.subVectors(e, t), Y.subVectors(i, t), J.crossVectors(j, Y);
        let r, o = this.direction.dot(J);
        if (o > 0) {
            if (n) return null;
            r = 1
        } else {
            if (!(o < 0)) return null;
            r = -1, o = -o
        }
        q.subVectors(this.origin, t);
        const a = r * this.direction.dot(Y.crossVectors(q, Y));
        if (a < 0) return null;
        const l = r * this.direction.dot(j.cross(q));
        if (l < 0) return null;
        if (a + l > o) return null;
        const h = -r * q.dot(J);
        return h < 0 ? null : this.at(h / o, s)
    }
    applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }
    equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
class $ {
    constructor() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    set(t, e, i, n, s, r, o, a, l, h, c, d, u, p, m, g) {
        const f = this.elements;
        return f[0] = t, f[4] = e, f[8] = i, f[12] = n, f[1] = s, f[5] = r, f[9] = o, f[13] = a, f[2] = l, f[6] = h, f[10] = c, f[14] = d, f[3] = u, f[7] = p, f[11] = m, f[15] = g, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return (new $).fromArray(this.elements)
    }
    copy(t) {
        const e = this.elements,
            i = t.elements;
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
    }
    copyPosition(t) {
        const e = this.elements,
            i = t.elements;
        return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
    }
    setFromMatrix3(t) {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(t, e, i) {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
    }
    makeBasis(t, e, i) {
        return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(t) {
        const e = this.elements,
            i = t.elements,
            n = 1 / Z.setFromMatrixColumn(t, 0).length(),
            s = 1 / Z.setFromMatrixColumn(t, 1).length(),
            r = 1 / Z.setFromMatrixColumn(t, 2).length();
        return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * s, e[5] = i[5] * s, e[6] = i[6] * s, e[7] = 0, e[8] = i[8] * r, e[9] = i[9] * r, e[10] = i[10] * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromEuler(t) {
        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const e = this.elements,
            i = t.x,
            n = t.y,
            s = t.z,
            r = Math.cos(i),
            o = Math.sin(i),
            a = Math.cos(n),
            l = Math.sin(n),
            h = Math.cos(s),
            c = Math.sin(s);
        if ("XYZ" === t.order) {
            const t = r * h,
                i = r * c,
                n = o * h,
                s = o * c;
            e[0] = a * h, e[4] = -a * c, e[8] = l, e[1] = i + n * l, e[5] = t - s * l, e[9] = -o * a, e[2] = s - t * l, e[6] = n + i * l, e[10] = r * a
        } else if ("YXZ" === t.order) {
            const t = a * h,
                i = a * c,
                n = l * h,
                s = l * c;
            e[0] = t + s * o, e[4] = n * o - i, e[8] = r * l, e[1] = r * c, e[5] = r * h, e[9] = -o, e[2] = i * o - n, e[6] = s + t * o, e[10] = r * a
        } else if ("ZXY" === t.order) {
            const t = a * h,
                i = a * c,
                n = l * h,
                s = l * c;
            e[0] = t - s * o, e[4] = -r * c, e[8] = n + i * o, e[1] = i + n * o, e[5] = r * h, e[9] = s - t * o, e[2] = -r * l, e[6] = o, e[10] = r * a
        } else if ("ZYX" === t.order) {
            const t = r * h,
                i = r * c,
                n = o * h,
                s = o * c;
            e[0] = a * h, e[4] = n * l - i, e[8] = t * l + s, e[1] = a * c, e[5] = s * l + t, e[9] = i * l - n, e[2] = -l, e[6] = o * a, e[10] = r * a
        } else if ("YZX" === t.order) {
            const t = r * a,
                i = r * l,
                n = o * a,
                s = o * l;
            e[0] = a * h, e[4] = s - t * c, e[8] = n * c + i, e[1] = c, e[5] = r * h, e[9] = -o * h, e[2] = -l * h, e[6] = i * c + n, e[10] = t - s * c
        } else if ("XZY" === t.order) {
            const t = r * a,
                i = r * l,
                n = o * a,
                s = o * l;
            e[0] = a * h, e[4] = -c, e[8] = l * h, e[1] = t * c + s, e[5] = r * h, e[9] = i * c - n, e[2] = n * c - i, e[6] = o * h, e[10] = s * c + t
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromQuaternion(t) {
        return this.compose(Q, t, tt)
    }
    lookAt(t, e, i) {
        const n = this.elements;
        return nt.subVectors(t, e), 0 === nt.lengthSq() && (nt.z = 1), nt.normalize(), et.crossVectors(i, nt), 0 === et.lengthSq() && (1 === Math.abs(i.z) ? nt.x += 1e-4 : nt.z += 1e-4, nt.normalize(), et.crossVectors(i, nt)), et.normalize(), it.crossVectors(nt, et), n[0] = et.x, n[4] = it.x, n[8] = nt.x, n[1] = et.y, n[5] = it.y, n[9] = nt.y, n[2] = et.z, n[6] = it.z, n[10] = nt.z, this
    }
    multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
    }
    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e) {
        const i = t.elements,
            n = e.elements,
            s = this.elements,
            r = i[0],
            o = i[4],
            a = i[8],
            l = i[12],
            h = i[1],
            c = i[5],
            d = i[9],
            u = i[13],
            p = i[2],
            m = i[6],
            g = i[10],
            f = i[14],
            y = i[3],
            v = i[7],
            w = i[11],
            b = i[15],
            x = n[0],
            S = n[4],
            M = n[8],
            C = n[12],
            _ = n[1],
            E = n[5],
            P = n[9],
            T = n[13],
            A = n[2],
            L = n[6],
            k = n[10],
            I = n[14],
            R = n[3],
            D = n[7],
            O = n[11],
            F = n[15];
        return s[0] = r * x + o * _ + a * A + l * R, s[4] = r * S + o * E + a * L + l * D, s[8] = r * M + o * P + a * k + l * O, s[12] = r * C + o * T + a * I + l * F, s[1] = h * x + c * _ + d * A + u * R, s[5] = h * S + c * E + d * L + u * D, s[9] = h * M + c * P + d * k + u * O, s[13] = h * C + c * T + d * I + u * F, s[2] = p * x + m * _ + g * A + f * R, s[6] = p * S + m * E + g * L + f * D, s[10] = p * M + m * P + g * k + f * O, s[14] = p * C + m * T + g * I + f * F, s[3] = y * x + v * _ + w * A + b * R, s[7] = y * S + v * E + w * L + b * D, s[11] = y * M + v * P + w * k + b * O, s[15] = y * C + v * T + w * I + b * F, this
    }
    multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }
    determinant() {
        const t = this.elements,
            e = t[0],
            i = t[4],
            n = t[8],
            s = t[12],
            r = t[1],
            o = t[5],
            a = t[9],
            l = t[13],
            h = t[2],
            c = t[6],
            d = t[10],
            u = t[14];
        return t[3] * (+s * a * c - n * l * c - s * o * d + i * l * d + n * o * u - i * a * u) + t[7] * (+e * a * u - e * l * d + s * r * d - n * r * u + n * l * h - s * a * h) + t[11] * (+e * l * c - e * o * u - s * r * c + i * r * u + s * o * h - i * l * h) + t[15] * (-n * o * h - e * a * c + e * o * d + n * r * c - i * r * d + i * a * h)
    }
    transpose() {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }
    setPosition(t, e, i) {
        const n = this.elements;
        return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
    }
    invert() {
        const t = this.elements,
            e = t[0],
            i = t[1],
            n = t[2],
            s = t[3],
            r = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            h = t[8],
            c = t[9],
            d = t[10],
            u = t[11],
            p = t[12],
            m = t[13],
            g = t[14],
            f = t[15],
            y = c * g * l - m * d * l + m * a * u - o * g * u - c * a * f + o * d * f,
            v = p * d * l - h * g * l - p * a * u + r * g * u + h * a * f - r * d * f,
            w = h * m * l - p * c * l + p * o * u - r * m * u - h * o * f + r * c * f,
            b = p * c * a - h * m * a - p * o * d + r * m * d + h * o * g - r * c * g,
            x = e * y + i * v + n * w + s * b;
        if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / x;
        return t[0] = y * S, t[1] = (m * d * s - c * g * s - m * n * u + i * g * u + c * n * f - i * d * f) * S, t[2] = (o * g * s - m * a * s + m * n * l - i * g * l - o * n * f + i * a * f) * S, t[3] = (c * a * s - o * d * s - c * n * l + i * d * l + o * n * u - i * a * u) * S, t[4] = v * S, t[5] = (h * g * s - p * d * s + p * n * u - e * g * u - h * n * f + e * d * f) * S, t[6] = (p * a * s - r * g * s - p * n * l + e * g * l + r * n * f - e * a * f) * S, t[7] = (r * d * s - h * a * s + h * n * l - e * d * l - r * n * u + e * a * u) * S, t[8] = w * S, t[9] = (p * c * s - h * m * s - p * i * u + e * m * u + h * i * f - e * c * f) * S, t[10] = (r * m * s - p * o * s + p * i * l - e * m * l - r * i * f + e * o * f) * S, t[11] = (h * o * s - r * c * s - h * i * l + e * c * l + r * i * u - e * o * u) * S, t[12] = b * S, t[13] = (h * m * n - p * c * n + p * i * d - e * m * d - h * i * g + e * c * g) * S, t[14] = (p * o * n - r * m * n - p * i * a + e * m * a + r * i * g - e * o * g) * S, t[15] = (r * c * n - h * o * n + h * i * a - e * c * a - r * i * d + e * o * d) * S, this
    }
    scale(t) {
        const e = this.elements,
            i = t.x,
            n = t.y,
            s = t.z;
        return e[0] *= i, e[4] *= n, e[8] *= s, e[1] *= i, e[5] *= n, e[9] *= s, e[2] *= i, e[6] *= n, e[10] *= s, e[3] *= i, e[7] *= n, e[11] *= s, this
    }
    getMaxScaleOnAxis() {
        const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, i, n))
    }
    makeTranslation(t, e, i) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
    }
    makeRotationX(t) {
        const e = Math.cos(t),
            i = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
    }
    makeRotationY(t) {
        const e = Math.cos(t),
            i = Math.sin(t);
        return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(t) {
        const e = Math.cos(t),
            i = Math.sin(t);
        return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(t, e) {
        const i = Math.cos(e),
            n = Math.sin(e),
            s = 1 - i,
            r = t.x,
            o = t.y,
            a = t.z,
            l = s * r,
            h = s * o;
        return this.set(l * r + i, l * o - n * a, l * a + n * o, 0, l * o + n * a, h * o + i, h * a - n * r, 0, l * a - n * o, h * a + n * r, s * a * a + i, 0, 0, 0, 0, 1), this
    }
    makeScale(t, e, i) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
    }
    makeShear(t, e, i) {
        return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
    }
    compose(t, e, i) {
        const n = this.elements,
            s = e._x,
            r = e._y,
            o = e._z,
            a = e._w,
            l = s + s,
            h = r + r,
            c = o + o,
            d = s * l,
            u = s * h,
            p = s * c,
            m = r * h,
            g = r * c,
            f = o * c,
            y = a * l,
            v = a * h,
            w = a * c,
            b = i.x,
            x = i.y,
            S = i.z;
        return n[0] = (1 - (m + f)) * b, n[1] = (u + w) * b, n[2] = (p - v) * b, n[3] = 0, n[4] = (u - w) * x, n[5] = (1 - (d + f)) * x, n[6] = (g + y) * x, n[7] = 0, n[8] = (p + v) * S, n[9] = (g - y) * S, n[10] = (1 - (d + m)) * S, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
    }
    decompose(t, e, i) {
        const n = this.elements;
        let s = Z.set(n[0], n[1], n[2]).length();
        const r = Z.set(n[4], n[5], n[6]).length(),
            o = Z.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (s = -s), t.x = n[12], t.y = n[13], t.z = n[14], K.copy(this);
        const a = 1 / s,
            l = 1 / r,
            h = 1 / o;
        return K.elements[0] *= a, K.elements[1] *= a, K.elements[2] *= a, K.elements[4] *= l, K.elements[5] *= l, K.elements[6] *= l, K.elements[8] *= h, K.elements[9] *= h, K.elements[10] *= h, e.setFromRotationMatrix(K), i.x = s, i.y = r, i.z = o, this
    }
    makePerspective(t, e, i, n, s, r) {
        void 0 === r && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const o = this.elements,
            a = 2 * s / (e - t),
            l = 2 * s / (i - n),
            h = (e + t) / (e - t),
            c = (i + n) / (i - n),
            d = -(r + s) / (r - s),
            u = -2 * r * s / (r - s);
        return o[0] = a, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = l, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = u, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
    }
    makeOrthographic(t, e, i, n, s, r) {
        const o = this.elements,
            a = 1 / (e - t),
            l = 1 / (i - n),
            h = 1 / (r - s),
            c = (e + t) * a,
            d = (i + n) * l,
            u = (r + s) * h;
        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -c, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -u, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
    }
    equals(t) {
        const e = this.elements,
            i = t.elements;
        for (let t = 0; t < 16; t++)
            if (e[t] !== i[t]) return !1;
        return !0
    }
    fromArray(t, e = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
        return this
    }
    toArray(t = [], e = 0) {
        const i = this.elements;
        return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
    }
}
$.prototype.isMatrix4 = !0;
const Z = new w,
    K = new $,
    Q = new w(0, 0, 0),
    tt = new w(1, 1, 1),
    et = new w,
    it = new w,
    nt = new w,
    st = new $,
    rt = new v;
class ot {
    constructor(t = 0, e = 0, i = 0, n = ot.DefaultOrder) {
        this._x = t, this._y = e, this._z = i, this._order = n
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x = t, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y = t, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(t) {
        this._z = t, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(t) {
        this._order = t, this._onChangeCallback()
    }
    set(t, e, i, n) {
        return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(t, e, i) {
        const n = t.elements,
            s = n[0],
            o = n[4],
            a = n[8],
            l = n[1],
            h = n[5],
            c = n[9],
            d = n[2],
            u = n[6],
            p = n[10];
        switch (e = e || this._order) {
            case "XYZ":
                this._y = Math.asin(r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(u, h), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-d, s), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-d, p), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math.atan2(l, s));
                break;
            case "ZYX":
                this._y = Math.asin(-r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(u, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, h));
                break;
            case "YZX":
                this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-c, h), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(a, p));
                break;
            case "XZY":
                this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(u, h), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-c, p), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
        }
        return this._order = e, !1 !== i && this._onChangeCallback(), this
    }
    setFromQuaternion(t, e, i) {
        return st.makeRotationFromQuaternion(t), this.setFromRotationMatrix(st, e, i)
    }
    setFromVector3(t, e) {
        return this.set(t.x, t.y, t.z, e || this._order)
    }
    reorder(t) {
        return rt.setFromEuler(this), this.setFromQuaternion(rt, t)
    }
    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }
    fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
    }
    toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
    }
    toVector3(t) {
        return t ? t.set(this._x, this._y, this._z) : new w(this._x, this._y, this._z)
    }
    _onChange(t) {
        return this._onChangeCallback = t, this
    }
    _onChangeCallback() {}
}
ot.prototype.isEuler = !0, ot.DefaultOrder = "XYZ", ot.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class at {
    constructor() {
        this.mask = 1
    }
    set(t) {
        this.mask = 1 << t | 0
    }
    enable(t) {
        this.mask |= 1 << t | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(t) {
        this.mask ^= 1 << t | 0
    }
    disable(t) {
        this.mask &= ~(1 << t | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(t) {
        return 0 != (this.mask & t.mask)
    }
}
let lt = 0;
const ht = new w,
    ct = new v,
    dt = new $,
    ut = new w,
    pt = new w,
    mt = new w,
    gt = new v,
    ft = new w(1, 0, 0),
    yt = new w(0, 1, 0),
    vt = new w(0, 0, 1),
    wt = {
        type: "added"
    },
    bt = {
        type: "removed"
    };
class xt extends t {
    constructor() {
        super(), Object.defineProperty(this, "id", {
            value: lt++
        }), this.uuid = s(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = xt.DefaultUp.clone();
        const t = new w,
            e = new ot,
            i = new v,
            n = new w(1, 1, 1);
        e._onChange((function() {
            i.setFromEuler(e, !1)
        })), i._onChange((function() {
            e.setFromQuaternion(i, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new $
            },
            normalMatrix: {
                value: new c
            }
        }), this.matrix = new $, this.matrixWorld = new $, this.matrixAutoUpdate = xt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new at, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(t) {
        return this.quaternion.premultiply(t), this
    }
    setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e)
    }
    setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0)
    }
    setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t)
    }
    setRotationFromQuaternion(t) {
        this.quaternion.copy(t)
    }
    rotateOnAxis(t, e) {
        return ct.setFromAxisAngle(t, e), this.quaternion.multiply(ct), this
    }
    rotateOnWorldAxis(t, e) {
        return ct.setFromAxisAngle(t, e), this.quaternion.premultiply(ct), this
    }
    rotateX(t) {
        return this.rotateOnAxis(ft, t)
    }
    rotateY(t) {
        return this.rotateOnAxis(yt, t)
    }
    rotateZ(t) {
        return this.rotateOnAxis(vt, t)
    }
    translateOnAxis(t, e) {
        return ht.copy(t).applyQuaternion(this.quaternion), this.position.add(ht.multiplyScalar(e)), this
    }
    translateX(t) {
        return this.translateOnAxis(ft, t)
    }
    translateY(t) {
        return this.translateOnAxis(yt, t)
    }
    translateZ(t) {
        return this.translateOnAxis(vt, t)
    }
    localToWorld(t) {
        return t.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(t) {
        return t.applyMatrix4(dt.copy(this.matrixWorld).invert())
    }
    lookAt(t, e, i) {
        t.isVector3 ? ut.copy(t) : ut.set(t, e, i);
        const n = this.parent;
        this.updateWorldMatrix(!0, !1), pt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? dt.lookAt(pt, ut, this.up) : dt.lookAt(ut, pt, this.up), this.quaternion.setFromRotationMatrix(dt), n && (dt.extractRotation(n.matrixWorld), ct.setFromRotationMatrix(dt), this.quaternion.premultiply(ct.invert()))
    }
    add(t) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(wt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
    }
    remove(t) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
            return this
        }
        const e = this.children.indexOf(t);
        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(bt)), this
    }
    clear() {
        for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            e.parent = null, e.dispatchEvent(bt)
        }
        return this.children.length = 0, this
    }
    attach(t) {
        return this.updateWorldMatrix(!0, !1), dt.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), dt.multiply(t.parent.matrixWorld)), t.applyMatrix4(dt), this.add(t), t.updateWorldMatrix(!1, !0), this
    }
    getObjectById(t) {
        return this.getObjectByProperty("id", t)
    }
    getObjectByName(t) {
        return this.getObjectByProperty("name", t)
    }
    getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
            const n = this.children[i].getObjectByProperty(t, e);
            if (void 0 !== n) return n
        }
    }
    getWorldPosition(t) {
        return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new w), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(t) {
        return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new v), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pt, t, mt), t
    }
    getWorldScale(t) {
        return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new w), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pt, gt, t), t
    }
    getWorldDirection(t) {
        void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new w), this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize()
    }
    raycast() {}
    traverse(t) {
        t(this);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
    }
    traverseVisible(t) {
        if (!1 === this.visible) return;
        t(this);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
    }
    traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
    }
    updateWorldMatrix(t, e) {
        const i = this.parent;
        if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
            const t = this.children;
            for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(t) {
        const e = void 0 === t || "string" == typeof t,
            i = {};
        e && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {}
        }, i.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const n = {};

        function s(e, i) {
            return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
        }
        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
            n.geometry = s(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
                const i = e.shapes;
                if (Array.isArray(i))
                    for (let e = 0, n = i.length; e < n; e++) {
                        const n = i[e];
                        s(t.shapes, n)
                    } else s(t.shapes, i)
            }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (s(t.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material)
            if (Array.isArray(this.material)) {
                const e = [];
                for (let i = 0, n = this.material.length; i < n; i++) e.push(s(t.materials, this.material[i]));
                n.material = e
            } else n.material = s(t.materials, this.material);
        if (this.children.length > 0) {
            n.children = [];
            for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object)
        }
        if (this.animations.length > 0) {
            n.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
                const i = this.animations[e];
                n.animations.push(s(t.animations, i))
            }
        }
        if (e) {
            const e = r(t.geometries),
                n = r(t.materials),
                s = r(t.textures),
                o = r(t.images),
                a = r(t.shapes),
                l = r(t.skeletons),
                h = r(t.animations);
            e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o), a.length > 0 && (i.shapes = a), l.length > 0 && (i.skeletons = l), h.length > 0 && (i.animations = h)
        }
        return i.object = n, i;

        function r(t) {
            const e = [];
            for (const i in t) {
                const n = t[i];
                delete n.metadata, e.push(n)
            }
            return e
        }
    }
    clone(t) {
        return (new this.constructor).copy(this, t)
    }
    copy(t, e = !0) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
            for (let e = 0; e < t.children.length; e++) {
                const i = t.children[e];
                this.add(i.clone())
            }
        return this
    }
}
xt.DefaultUp = new w(0, 1, 0), xt.DefaultMatrixAutoUpdate = !0, xt.prototype.isObject3D = !0;
const St = new w,
    Mt = new w,
    Ct = new c;
class _t {
    constructor(t = new w(1, 0, 0), e = 0) {
        this.normal = t, this.constant = e
    }
    set(t, e) {
        return this.normal.copy(t), this.constant = e, this
    }
    setComponents(t, e, i, n) {
        return this.normal.set(t, e, i), this.constant = n, this
    }
    setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
    }
    setFromCoplanarPoints(t, e, i) {
        const n = St.subVectors(i, e).cross(Mt.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, t), this
    }
    copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this
    }
    normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(t) {
        return this.normal.dot(t) + this.constant
    }
    distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius
    }
    projectPoint(t, e) {
        return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new w), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    }
    intersectLine(t, e) {
        void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new w);
        const i = t.delta(St),
            n = this.normal.dot(i);
        if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const s = -(t.start.dot(this.normal) + this.constant) / n;
        return s < 0 || s > 1 ? null : e.copy(i).multiplyScalar(s).add(t.start)
    }
    intersectsLine(t) {
        const e = this.distanceToPoint(t.start),
            i = this.distanceToPoint(t.end);
        return e < 0 && i > 0 || i < 0 && e > 0
    }
    intersectsBox(t) {
        return t.intersectsPlane(this)
    }
    intersectsSphere(t) {
        return t.intersectsPlane(this)
    }
    coplanarPoint(t) {
        return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new w), t.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(t, e) {
        const i = e || Ct.getNormalMatrix(t),
            n = this.coplanarPoint(St).applyMatrix4(t),
            s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -n.dot(s), this
    }
    translate(t) {
        return this.constant -= t.dot(this.normal), this
    }
    equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
_t.prototype.isPlane = !0;
const Et = new w,
    Pt = new w,
    Tt = new w,
    At = new w,
    Lt = new w,
    kt = new w,
    It = new w,
    Rt = new w,
    Dt = new w,
    Ot = new w;
class Ft {
    constructor(t = new w, e = new w, i = new w) {
        this.a = t, this.b = e, this.c = i
    }
    static getNormal(t, e, i, n) {
        void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new w), n.subVectors(i, e), Et.subVectors(t, e), n.cross(Et);
        const s = n.lengthSq();
        return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0)
    }
    static getBarycoord(t, e, i, n, s) {
        Et.subVectors(n, e), Pt.subVectors(i, e), Tt.subVectors(t, e);
        const r = Et.dot(Et),
            o = Et.dot(Pt),
            a = Et.dot(Tt),
            l = Pt.dot(Pt),
            h = Pt.dot(Tt),
            c = r * l - o * o;
        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new w), 0 === c) return s.set(-2, -1, -1);
        const d = 1 / c,
            u = (l * a - o * h) * d,
            p = (r * h - o * a) * d;
        return s.set(1 - u - p, p, u)
    }
    static containsPoint(t, e, i, n) {
        return this.getBarycoord(t, e, i, n, At), At.x >= 0 && At.y >= 0 && At.x + At.y <= 1
    }
    static getUV(t, e, i, n, s, r, o, a) {
        return this.getBarycoord(t, e, i, n, At), a.set(0, 0), a.addScaledVector(s, At.x), a.addScaledVector(r, At.y), a.addScaledVector(o, At.z), a
    }
    static isFrontFacing(t, e, i, n) {
        return Et.subVectors(i, e), Pt.subVectors(t, e), Et.cross(Pt).dot(n) < 0
    }
    set(t, e, i) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
    }
    setFromPointsAndIndices(t, e, i, n) {
        return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }
    getArea() {
        return Et.subVectors(this.c, this.b), Pt.subVectors(this.a, this.b), .5 * Et.cross(Pt).length()
    }
    getMidpoint(t) {
        return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new w), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(t) {
        return Ft.getNormal(this.a, this.b, this.c, t)
    }
    getPlane(t) {
        return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new _t), t.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(t, e) {
        return Ft.getBarycoord(t, this.a, this.b, this.c, e)
    }
    getUV(t, e, i, n, s) {
        return Ft.getUV(t, this.a, this.b, this.c, e, i, n, s)
    }
    containsPoint(t) {
        return Ft.containsPoint(t, this.a, this.b, this.c)
    }
    isFrontFacing(t) {
        return Ft.isFrontFacing(this.a, this.b, this.c, t)
    }
    intersectsBox(t) {
        return t.intersectsTriangle(this)
    }
    closestPointToPoint(t, e) {
        void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new w);
        const i = this.a,
            n = this.b,
            s = this.c;
        let r, o;
        Lt.subVectors(n, i), kt.subVectors(s, i), Rt.subVectors(t, i);
        const a = Lt.dot(Rt),
            l = kt.dot(Rt);
        if (a <= 0 && l <= 0) return e.copy(i);
        Dt.subVectors(t, n);
        const h = Lt.dot(Dt),
            c = kt.dot(Dt);
        if (h >= 0 && c <= h) return e.copy(n);
        const d = a * c - h * l;
        if (d <= 0 && a >= 0 && h <= 0) return r = a / (a - h), e.copy(i).addScaledVector(Lt, r);
        Ot.subVectors(t, s);
        const u = Lt.dot(Ot),
            p = kt.dot(Ot);
        if (p >= 0 && u <= p) return e.copy(s);
        const m = u * l - a * p;
        if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(i).addScaledVector(kt, o);
        const g = h * p - u * c;
        if (g <= 0 && c - h >= 0 && u - p >= 0) return It.subVectors(s, n), o = (c - h) / (c - h + (u - p)), e.copy(n).addScaledVector(It, o);
        const f = 1 / (g + m + d);
        return r = m * f, o = d * f, e.copy(i).addScaledVector(Lt, r).addScaledVector(kt, o)
    }
    equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
}
let Nt = 0;

function Bt() {
    Object.defineProperty(this, "id", {
        value: Nt++
    }), this.uuid = s(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
}
Bt.prototype = Object.assign(Object.create(t.prototype), {
    constructor: Bt,
    isMaterial: !0,
    onBuild: function() {},
    onBeforeCompile: function() {},
    customProgramCacheKey: function() {
        return this.onBeforeCompile.toString()
    },
    setValues: function(t) {
        if (void 0 !== t)
            for (const e in t) {
                const i = t[e];
                if (void 0 === i) {
                    console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                    continue
                }
                if ("shading" === e) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                    continue
                }
                const n = this[e];
                void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
            }
    },
    toJSON: function(t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };

        function n(t) {
            const e = [];
            for (const i in t) {
                const n = t[i];
                delete n.metadata, e.push(n)
            }
            return e
        }
        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.morphNormals && (i.morphNormals = !0), !0 === this.skinning && (i.skinning = !0), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
            const e = n(t.textures),
                s = n(t.images);
            e.length > 0 && (i.textures = e), s.length > 0 && (i.images = s)
        }
        return i
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(t) {
        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let i = null;
        if (null !== e) {
            const t = e.length;
            i = new Array(t);
            for (let n = 0; n !== t; ++n) i[n] = e[n].clone()
        }
        return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}), Object.defineProperty(Bt.prototype, "needsUpdate", {
    set: function(t) {
        !0 === t && this.version++
    }
});
const Vt = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Ut = {
        h: 0,
        s: 0,
        l: 0
    },
    zt = {
        h: 0,
        s: 0,
        l: 0
    };

function Ht(t, e, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
}

function Gt(t) {
    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
}

function Wt(t) {
    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
}
class qt {
    constructor(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    }
    set(t) {
        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
    }
    setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this
    }
    setHex(t) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
    }
    setRGB(t, e, i) {
        return this.r = t, this.g = e, this.b = i, this
    }
    setHSL(t, e, i) {
        var n;
        if (t = (t % (n = 1) + n) % n, e = r(e, 0, 1), i = r(i, 0, 1), 0 === e) this.r = this.g = this.b = i;
        else {
            const n = i <= .5 ? i * (1 + e) : i + e - i * e,
                s = 2 * i - n;
            this.r = Ht(s, n, t + 1 / 3), this.g = Ht(s, n, t), this.b = Ht(s, n, t - 1 / 3)
        }
        return this
    }
    setStyle(t) {
        function e(e) {
            void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }
        let i;
        if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
            let t;
            const n = i[1],
                s = i[2];
            switch (n) {
                case "rgb":
                case "rgba":
                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                        const i = parseFloat(t[1]) / 360,
                            n = parseInt(t[2], 10) / 100,
                            s = parseInt(t[3], 10) / 100;
                        return e(t[4]), this.setHSL(i, n, s)
                    }
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const t = i[1],
                e = t.length;
            if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
        }
        return t && t.length > 0 ? this.setColorName(t) : this
    }
    setColorName(t) {
        const e = Vt[t.toLowerCase()];
        return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
    }
    copyGammaToLinear(t, e = 2) {
        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
    }
    copyLinearToGamma(t, e = 2) {
        const i = e > 0 ? 1 / e : 1;
        return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
    }
    convertGammaToLinear(t) {
        return this.copyGammaToLinear(this, t), this
    }
    convertLinearToGamma(t) {
        return this.copyLinearToGamma(this, t), this
    }
    copySRGBToLinear(t) {
        return this.r = Gt(t.r), this.g = Gt(t.g), this.b = Gt(t.b), this
    }
    copyLinearToSRGB(t) {
        return this.r = Wt(t.r), this.g = Wt(t.g), this.b = Wt(t.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    }
    getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    }
    getHSL(t) {
        void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
            h: 0,
            s: 0,
            l: 0
        });
        const e = this.r,
            i = this.g,
            n = this.b,
            s = Math.max(e, i, n),
            r = Math.min(e, i, n);
        let o, a;
        const l = (r + s) / 2;
        if (r === s) o = 0, a = 0;
        else {
            const t = s - r;
            switch (a = l <= .5 ? t / (s + r) : t / (2 - s - r), s) {
                case e:
                    o = (i - n) / t + (i < n ? 6 : 0);
                    break;
                case i:
                    o = (n - e) / t + 2;
                    break;
                case n:
                    o = (e - i) / t + 4
            }
            o /= 6
        }
        return t.h = o, t.s = a, t.l = l, t
    }
    getStyle() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    }
    offsetHSL(t, e, i) {
        return this.getHSL(Ut), Ut.h += t, Ut.s += e, Ut.l += i, this.setHSL(Ut.h, Ut.s, Ut.l), this
    }
    add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
    }
    addColors(t, e) {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }
    addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this
    }
    sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }
    multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }
    multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this
    }
    lerp(t, e) {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }
    lerpColors(t, e, i) {
        return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this
    }
    lerpHSL(t, e) {
        this.getHSL(Ut), t.getHSL(zt);
        const i = o(Ut.h, zt.h, e),
            n = o(Ut.s, zt.s, e),
            s = o(Ut.l, zt.l, e);
        return this.setHSL(i, n, s), this
    }
    equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b
    }
    fromArray(t, e = 0) {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }
    fromBufferAttribute(t, e) {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
    }
    toJSON() {
        return this.getHex()
    }
}
qt.NAMES = Vt, qt.prototype.isColor = !0, qt.prototype.r = 1, qt.prototype.g = 1, qt.prototype.b = 1;
class jt extends Bt {
    constructor(t) {
        super(), this.type = "MeshBasicMaterial", this.color = new qt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }
}
jt.prototype.isMeshBasicMaterial = !0;
const Yt = new w,
    Jt = new h;
class Xt {
    constructor(t, e, i) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.onUploadCallback = function() {}
    }
    set needsUpdate(t) {
        !0 === t && this.version++
    }
    setUsage(t) {
        return this.usage = t, this
    }
    copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
    }
    copyAt(t, e, i) {
        t *= this.itemSize, i *= e.itemSize;
        for (let n = 0, s = this.itemSize; n < s; n++) this.array[t + n] = e.array[i + n];
        return this
    }
    copyArray(t) {
        return this.array.set(t), this
    }
    copyColorsArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), s = new qt), e[i++] = s.r, e[i++] = s.g, e[i++] = s.b
        }
        return this
    }
    copyVector2sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), s = new h), e[i++] = s.x, e[i++] = s.y
        }
        return this
    }
    copyVector3sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new w), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z
        }
        return this
    }
    copyVector4sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, s = t.length; n < s; n++) {
            let s = t[n];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), s = new f), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z, e[i++] = s.w
        }
        return this
    }
    applyMatrix3(t) {
        if (2 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++) Jt.fromBufferAttribute(this, e), Jt.applyMatrix3(t), this.setXY(e, Jt.x, Jt.y);
        else if (3 === this.itemSize)
            for (let e = 0, i = this.count; e < i; e++) Yt.fromBufferAttribute(this, e), Yt.applyMatrix3(t), this.setXYZ(e, Yt.x, Yt.y, Yt.z);
        return this
    }
    applyMatrix4(t) {
        for (let e = 0, i = this.count; e < i; e++) Yt.x = this.getX(e), Yt.y = this.getY(e), Yt.z = this.getZ(e), Yt.applyMatrix4(t), this.setXYZ(e, Yt.x, Yt.y, Yt.z);
        return this
    }
    applyNormalMatrix(t) {
        for (let e = 0, i = this.count; e < i; e++) Yt.x = this.getX(e), Yt.y = this.getY(e), Yt.z = this.getZ(e), Yt.applyNormalMatrix(t), this.setXYZ(e, Yt.x, Yt.y, Yt.z);
        return this
    }
    transformDirection(t) {
        for (let e = 0, i = this.count; e < i; e++) Yt.x = this.getX(e), Yt.y = this.getY(e), Yt.z = this.getZ(e), Yt.transformDirection(t), this.setXYZ(e, Yt.x, Yt.y, Yt.z);
        return this
    }
    set(t, e = 0) {
        return this.array.set(t, e), this
    }
    getX(t) {
        return this.array[t * this.itemSize]
    }
    setX(t, e) {
        return this.array[t * this.itemSize] = e, this
    }
    getY(t) {
        return this.array[t * this.itemSize + 1]
    }
    setY(t, e) {
        return this.array[t * this.itemSize + 1] = e, this
    }
    getZ(t) {
        return this.array[t * this.itemSize + 2]
    }
    setZ(t, e) {
        return this.array[t * this.itemSize + 2] = e, this
    }
    getW(t) {
        return this.array[t * this.itemSize + 3]
    }
    setW(t, e) {
        return this.array[t * this.itemSize + 3] = e, this
    }
    setXY(t, e, i) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
    }
    setXYZ(t, e, i, n) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
    }
    setXYZW(t, e, i, n, s) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = s, this
    }
    onUpload(t) {
        return this.onUploadCallback = t, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
    }
}
Xt.prototype.isBufferAttribute = !0;
class $t extends Xt {
    constructor(t, e, i) {
        super(new Uint16Array(t), e, i)
    }
}
class Zt extends Xt {
    constructor(t, e, i) {
        super(new Uint32Array(t), e, i)
    }
}(class extends Xt {
    constructor(t, e, i) {
        super(new Uint16Array(t), e, i)
    }
}).prototype.isFloat16BufferAttribute = !0;
class Kt extends Xt {
    constructor(t, e, i) {
        super(new Float32Array(t), e, i)
    }
}

function Qt(t) {
    if (0 === t.length) return -1 / 0;
    let e = t[0];
    for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
    return e
}
let te = 0;
const ee = new $,
    ie = new xt,
    ne = new w,
    se = new S,
    re = new S,
    oe = new w;
class ae extends t {
    constructor() {
        super(), Object.defineProperty(this, "id", {
            value: te++
        }), this.uuid = s(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(t) {
        return Array.isArray(t) ? this.index = new(Qt(t) > 65535 ? Zt : $t)(t, 1) : this.index = t, this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    setAttribute(t, e) {
        return this.attributes[t] = e, this
    }
    deleteAttribute(t) {
        return delete this.attributes[t], this
    }
    hasAttribute(t) {
        return void 0 !== this.attributes[t]
    }
    addGroup(t, e, i = 0) {
        this.groups.push({
            start: t,
            count: e,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(t, e) {
        this.drawRange.start = t, this.drawRange.count = e
    }
    applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
        const i = this.attributes.normal;
        if (void 0 !== i) {
            const e = (new c).getNormalMatrix(t);
            i.applyNormalMatrix(e), i.needsUpdate = !0
        }
        const n = this.attributes.tangent;
        return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
    }
    rotateX(t) {
        return ee.makeRotationX(t), this.applyMatrix4(ee), this
    }
    rotateY(t) {
        return ee.makeRotationY(t), this.applyMatrix4(ee), this
    }
    rotateZ(t) {
        return ee.makeRotationZ(t), this.applyMatrix4(ee), this
    }
    translate(t, e, i) {
        return ee.makeTranslation(t, e, i), this.applyMatrix4(ee), this
    }
    scale(t, e, i) {
        return ee.makeScale(t, e, i), this.applyMatrix4(ee), this
    }
    lookAt(t) {
        return ie.lookAt(t), ie.updateMatrix(), this.applyMatrix4(ie.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(ne).negate(), this.translate(ne.x, ne.y, ne.z), this
    }
    setFromPoints(t) {
        const e = [];
        for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i];
            e.push(n.x, n.y, n.z || 0)
        }
        return this.setAttribute("position", new Kt(e, 3)), this
    }
    computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new S);
        const t = this.attributes.position,
            e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new w(-1 / 0, -1 / 0, -1 / 0), new w(1 / 0, 1 / 0, 1 / 0));
        if (void 0 !== t) {
            if (this.boundingBox.setFromBufferAttribute(t), e)
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    se.setFromBufferAttribute(i), this.morphTargetsRelative ? (oe.addVectors(this.boundingBox.min, se.min), this.boundingBox.expandByPoint(oe), oe.addVectors(this.boundingBox.max, se.max), this.boundingBox.expandByPoint(oe)) : (this.boundingBox.expandByPoint(se.min), this.boundingBox.expandByPoint(se.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new z);
        const t = this.attributes.position,
            e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new w, 1 / 0);
        if (t) {
            const i = this.boundingSphere.center;
            if (se.setFromBufferAttribute(t), e)
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    re.setFromBufferAttribute(i), this.morphTargetsRelative ? (oe.addVectors(se.min, re.min), se.expandByPoint(oe), oe.addVectors(se.max, re.max), se.expandByPoint(oe)) : (se.expandByPoint(re.min), se.expandByPoint(re.max))
                }
            se.getCenter(i);
            let n = 0;
            for (let e = 0, s = t.count; e < s; e++) oe.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(oe));
            if (e)
                for (let s = 0, r = e.length; s < r; s++) {
                    const r = e[s],
                        o = this.morphTargetsRelative;
                    for (let e = 0, s = r.count; e < s; e++) oe.fromBufferAttribute(r, e), o && (ne.fromBufferAttribute(t, e), oe.add(ne)), n = Math.max(n, i.distanceToSquared(oe))
                }
            this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeFaceNormals() {}
    computeTangents() {
        const t = this.index,
            e = this.attributes;
        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const i = t.array,
            n = e.position.array,
            s = e.normal.array,
            r = e.uv.array,
            o = n.length / 3;
        void 0 === e.tangent && this.setAttribute("tangent", new Xt(new Float32Array(4 * o), 4));
        const a = e.tangent.array,
            l = [],
            c = [];
        for (let t = 0; t < o; t++) l[t] = new w, c[t] = new w;
        const d = new w,
            u = new w,
            p = new w,
            m = new h,
            g = new h,
            f = new h,
            y = new w,
            v = new w;

        function b(t, e, i) {
            d.fromArray(n, 3 * t), u.fromArray(n, 3 * e), p.fromArray(n, 3 * i), m.fromArray(r, 2 * t), g.fromArray(r, 2 * e), f.fromArray(r, 2 * i), u.sub(d), p.sub(d), g.sub(m), f.sub(m);
            const s = 1 / (g.x * f.y - f.x * g.y);
            isFinite(s) && (y.copy(u).multiplyScalar(f.y).addScaledVector(p, -g.y).multiplyScalar(s), v.copy(p).multiplyScalar(g.x).addScaledVector(u, -f.x).multiplyScalar(s), l[t].add(y), l[e].add(y), l[i].add(y), c[t].add(v), c[e].add(v), c[i].add(v))
        }
        let x = this.groups;
        0 === x.length && (x = [{
            start: 0,
            count: i.length
        }]);
        for (let t = 0, e = x.length; t < e; ++t) {
            const e = x[t],
                n = e.start;
            for (let t = n, s = n + e.count; t < s; t += 3) b(i[t + 0], i[t + 1], i[t + 2])
        }
        const S = new w,
            M = new w,
            C = new w,
            _ = new w;

        function E(t) {
            C.fromArray(s, 3 * t), _.copy(C);
            const e = l[t];
            S.copy(e), S.sub(C.multiplyScalar(C.dot(e))).normalize(), M.crossVectors(_, e);
            const i = M.dot(c[t]) < 0 ? -1 : 1;
            a[4 * t] = S.x, a[4 * t + 1] = S.y, a[4 * t + 2] = S.z, a[4 * t + 3] = i
        }
        for (let t = 0, e = x.length; t < e; ++t) {
            const e = x[t],
                n = e.start;
            for (let t = n, s = n + e.count; t < s; t += 3) E(i[t + 0]), E(i[t + 1]), E(i[t + 2])
        }
    }
    computeVertexNormals() {
        const t = this.index,
            e = this.getAttribute("position");
        if (void 0 !== e) {
            let i = this.getAttribute("normal");
            if (void 0 === i) i = new Xt(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
            else
                for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
            const n = new w,
                s = new w,
                r = new w,
                o = new w,
                a = new w,
                l = new w,
                h = new w,
                c = new w;
            if (t)
                for (let d = 0, u = t.count; d < u; d += 3) {
                    const u = t.getX(d + 0),
                        p = t.getX(d + 1),
                        m = t.getX(d + 2);
                    n.fromBufferAttribute(e, u), s.fromBufferAttribute(e, p), r.fromBufferAttribute(e, m), h.subVectors(r, s), c.subVectors(n, s), h.cross(c), o.fromBufferAttribute(i, u), a.fromBufferAttribute(i, p), l.fromBufferAttribute(i, m), o.add(h), a.add(h), l.add(h), i.setXYZ(u, o.x, o.y, o.z), i.setXYZ(p, a.x, a.y, a.z), i.setXYZ(m, l.x, l.y, l.z)
                } else
                for (let t = 0, o = e.count; t < o; t += 3) n.fromBufferAttribute(e, t + 0), s.fromBufferAttribute(e, t + 1), r.fromBufferAttribute(e, t + 2), h.subVectors(r, s), c.subVectors(n, s), h.cross(c), i.setXYZ(t + 0, h.x, h.y, h.z), i.setXYZ(t + 1, h.x, h.y, h.z), i.setXYZ(t + 2, h.x, h.y, h.z);
            this.normalizeNormals(), i.needsUpdate = !0
        }
    }
    merge(t, e) {
        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const i = this.attributes;
        for (const n in i) {
            if (void 0 === t.attributes[n]) continue;
            const s = i[n].array,
                r = t.attributes[n],
                o = r.array,
                a = r.itemSize * e,
                l = Math.min(o.length, s.length - a);
            for (let t = 0, e = a; t < l; t++, e++) s[e] = o[t]
        }
        return this
    }
    normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, i = t.count; e < i; e++) oe.fromBufferAttribute(t, e), oe.normalize(), t.setXYZ(e, oe.x, oe.y, oe.z)
    }
    toNonIndexed() {
        function t(t, e) {
            const i = t.array,
                n = t.itemSize,
                s = t.normalized,
                r = new i.constructor(e.length * n);
            let o = 0,
                a = 0;
            for (let t = 0, s = e.length; t < s; t++) {
                o = e[t] * n;
                for (let t = 0; t < n; t++) r[a++] = i[o++]
            }
            return new Xt(r, n, s)
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new ae,
            i = this.index.array,
            n = this.attributes;
        for (const s in n) {
            const r = t(n[s], i);
            e.setAttribute(s, r)
        }
        const s = this.morphAttributes;
        for (const n in s) {
            const r = [],
                o = s[n];
            for (let e = 0, n = o.length; e < n; e++) {
                const n = t(o[e], i);
                r.push(n)
            }
            e.morphAttributes[n] = r
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const r = this.groups;
        for (let t = 0, i = r.length; t < i; t++) {
            const i = r[t];
            e.addGroup(i.start, i.count, i.materialIndex)
        }
        return e
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
            const e = this.parameters;
            for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
            return t
        }
        t.data = {
            attributes: {}
        };
        const e = this.index;
        null !== e && (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array)
        });
        const i = this.attributes;
        for (const e in i) {
            const n = i[e];
            t.data.attributes[e] = n.toJSON(t.data)
        }
        const n = {};
        let s = !1;
        for (const e in this.morphAttributes) {
            const i = this.morphAttributes[e],
                r = [];
            for (let e = 0, n = i.length; e < n; e++) {
                const n = i[e];
                r.push(n.toJSON(t.data))
            }
            r.length > 0 && (n[e] = r, s = !0)
        }
        s && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const r = this.groups;
        r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
        const o = this.boundingSphere;
        return null !== o && (t.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
        }), t
    }
    clone() {
        return (new ae).copy(this)
    }
    copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const i = t.index;
        null !== i && this.setIndex(i.clone(e));
        const n = t.attributes;
        for (const t in n) {
            const i = n[t];
            this.setAttribute(t, i.clone(e))
        }
        const s = t.morphAttributes;
        for (const t in s) {
            const i = [],
                n = s[t];
            for (let t = 0, s = n.length; t < s; t++) i.push(n[t].clone(e));
            this.morphAttributes[t] = i
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const r = t.groups;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t];
            this.addGroup(e.start, e.count, e.materialIndex)
        }
        const o = t.boundingBox;
        null !== o && (this.boundingBox = o.clone());
        const a = t.boundingSphere;
        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
ae.prototype.isBufferGeometry = !0;
const le = new $,
    he = new X,
    ce = new z,
    de = new w,
    ue = new w,
    pe = new w,
    me = new w,
    ge = new w,
    fe = new w,
    ye = new w,
    ve = new w,
    we = new w,
    be = new h,
    xe = new h,
    Se = new h,
    Me = new w,
    Ce = new w;
class _e extends xt {
    constructor(t = new ae, e = new jt) {
        super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
    }
    copy(t) {
        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
    }
    updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            const e = t.morphAttributes,
                i = Object.keys(e);
            if (i.length > 0) {
                const t = e[i[0]];
                if (void 0 !== t) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e].name || String(e);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                    }
                }
            }
        } else {
            const e = t.morphTargets;
            void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
    raycast(t, e) {
        const i = this.geometry,
            n = this.material,
            s = this.matrixWorld;
        if (void 0 === n) return;
        if (null === i.boundingSphere && i.computeBoundingSphere(), ce.copy(i.boundingSphere), ce.applyMatrix4(s), !1 === t.ray.intersectsSphere(ce)) return;
        if (le.copy(s).invert(), he.copy(t.ray).applyMatrix4(le), null !== i.boundingBox && !1 === he.intersectsBox(i.boundingBox)) return;
        let r;
        if (i.isBufferGeometry) {
            const s = i.index,
                o = i.attributes.position,
                a = i.morphAttributes.position,
                l = i.morphTargetsRelative,
                h = i.attributes.uv,
                c = i.attributes.uv2,
                d = i.groups,
                u = i.drawRange;
            if (null !== s)
                if (Array.isArray(n))
                    for (let i = 0, p = d.length; i < p; i++) {
                        const p = d[i],
                            m = n[p.materialIndex];
                        for (let i = Math.max(p.start, u.start), n = Math.min(p.start + p.count, u.start + u.count); i < n; i += 3) {
                            const n = s.getX(i),
                                d = s.getX(i + 1),
                                u = s.getX(i + 2);
                            r = Ee(this, m, t, he, o, a, l, h, c, n, d, u), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = p.materialIndex, e.push(r))
                        }
                    } else {
                    for (let i = Math.max(0, u.start), d = Math.min(s.count, u.start + u.count); i < d; i += 3) {
                        const d = s.getX(i),
                            u = s.getX(i + 1),
                            p = s.getX(i + 2);
                        r = Ee(this, n, t, he, o, a, l, h, c, d, u, p), r && (r.faceIndex = Math.floor(i / 3), e.push(r))
                    }
                } else if (void 0 !== o)
                if (Array.isArray(n))
                    for (let i = 0, s = d.length; i < s; i++) {
                        const s = d[i],
                            p = n[s.materialIndex];
                        for (let i = Math.max(s.start, u.start), n = Math.min(s.start + s.count, u.start + u.count); i < n; i += 3) {
                            r = Ee(this, p, t, he, o, a, l, h, c, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = s.materialIndex, e.push(r))
                        }
                    } else {
                    for (let i = Math.max(0, u.start), s = Math.min(o.count, u.start + u.count); i < s; i += 3) {
                        r = Ee(this, n, t, he, o, a, l, h, c, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), e.push(r))
                    }
                }
        } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
}

function Ee(t, e, i, n, s, r, o, a, l, c, d, u) {
    de.fromBufferAttribute(s, c), ue.fromBufferAttribute(s, d), pe.fromBufferAttribute(s, u);
    const p = t.morphTargetInfluences;
    if (e.morphTargets && r && p) {
        ye.set(0, 0, 0), ve.set(0, 0, 0), we.set(0, 0, 0);
        for (let t = 0, e = r.length; t < e; t++) {
            const e = p[t],
                i = r[t];
            0 !== e && (me.fromBufferAttribute(i, c), ge.fromBufferAttribute(i, d), fe.fromBufferAttribute(i, u), o ? (ye.addScaledVector(me, e), ve.addScaledVector(ge, e), we.addScaledVector(fe, e)) : (ye.addScaledVector(me.sub(de), e), ve.addScaledVector(ge.sub(ue), e), we.addScaledVector(fe.sub(pe), e)))
        }
        de.add(ye), ue.add(ve), pe.add(we)
    }
    t.isSkinnedMesh && e.skinning && (t.boneTransform(c, de), t.boneTransform(d, ue), t.boneTransform(u, pe));
    const m = function(t, e, i, n, s, r, o, a) {
        let l;
        if (l = 1 === e.side ? n.intersectTriangle(o, r, s, !0, a) : n.intersectTriangle(s, r, o, 2 !== e.side, a), null === l) return null;
        Ce.copy(a), Ce.applyMatrix4(t.matrixWorld);
        const h = i.ray.origin.distanceTo(Ce);
        return h < i.near || h > i.far ? null : {
            distance: h,
            point: Ce.clone(),
            object: t
        }
    }(t, e, i, n, de, ue, pe, Me);
    if (m) {
        a && (be.fromBufferAttribute(a, c), xe.fromBufferAttribute(a, d), Se.fromBufferAttribute(a, u), m.uv = Ft.getUV(Me, de, ue, pe, be, xe, Se, new h)), l && (be.fromBufferAttribute(l, c), xe.fromBufferAttribute(l, d), Se.fromBufferAttribute(l, u), m.uv2 = Ft.getUV(Me, de, ue, pe, be, xe, Se, new h));
        const t = {
            a: c,
            b: d,
            c: u,
            normal: new w,
            materialIndex: 0
        };
        Ft.getNormal(de, ue, pe, t.normal), m.face = t
    }
    return m
}
_e.prototype.isMesh = !0;
class Pe extends ae {
    constructor(t = 1, e = 1, i = 1, n = 1, s = 1, r = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: s,
            depthSegments: r
        };
        const o = this;
        n = Math.floor(n), s = Math.floor(s), r = Math.floor(r);
        const a = [],
            l = [],
            h = [],
            c = [];
        let d = 0,
            u = 0;

        function p(t, e, i, n, s, r, p, m, g, f, y) {
            const v = r / g,
                b = p / f,
                x = r / 2,
                S = p / 2,
                M = m / 2,
                C = g + 1,
                _ = f + 1;
            let E = 0,
                P = 0;
            const T = new w;
            for (let r = 0; r < _; r++) {
                const o = r * b - S;
                for (let a = 0; a < C; a++) {
                    const d = a * v - x;
                    T[t] = d * n, T[e] = o * s, T[i] = M, l.push(T.x, T.y, T.z), T[t] = 0, T[e] = 0, T[i] = m > 0 ? 1 : -1, h.push(T.x, T.y, T.z), c.push(a / g), c.push(1 - r / f), E += 1
                }
            }
            for (let t = 0; t < f; t++)
                for (let e = 0; e < g; e++) {
                    const i = d + e + C * t,
                        n = d + e + C * (t + 1),
                        s = d + (e + 1) + C * (t + 1),
                        r = d + (e + 1) + C * t;
                    a.push(i, n, r), a.push(n, s, r), P += 6
                }
            o.addGroup(u, P, y), u += P, d += E
        }
        p("z", "y", "x", -1, -1, i, e, t, r, s, 0), p("z", "y", "x", 1, -1, i, e, -t, r, s, 1), p("x", "z", "y", 1, 1, t, i, e, n, r, 2), p("x", "z", "y", 1, -1, t, i, -e, n, r, 3), p("x", "y", "z", 1, -1, t, e, i, n, s, 4), p("x", "y", "z", -1, -1, t, e, -i, n, s, 5), this.setIndex(a), this.setAttribute("position", new Kt(l, 3)), this.setAttribute("normal", new Kt(h, 3)), this.setAttribute("uv", new Kt(c, 2))
    }
}

function Te(t) {
    const e = {};
    for (const i in t) {
        e[i] = {};
        for (const n in t[i]) {
            const s = t[i][n];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s
        }
    }
    return e
}

function Ae(t) {
    const e = {};
    for (let i = 0; i < t.length; i++) {
        const n = Te(t[i]);
        for (const t in n) e[t] = n[t]
    }
    return e
}
const Le = {
    clone: Te,
    merge: Ae
};
class ke extends Bt {
    constructor(t) {
        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }
    copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Te(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion, e.uniforms = {};
        for (const i in this.uniforms) {
            const n = this.uniforms[i].value;
            n && n.isTexture ? e.uniforms[i] = {
                type: "t",
                value: n.toJSON(t).uuid
            } : n && n.isColor ? e.uniforms[i] = {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? e.uniforms[i] = {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? e.uniforms[i] = {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? e.uniforms[i] = {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? e.uniforms[i] = {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? e.uniforms[i] = {
                type: "m4",
                value: n.toArray()
            } : e.uniforms[i] = {
                value: n
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        const i = {};
        for (const t in this.extensions) !0 === this.extensions[t] && (i[t] = !0);
        return Object.keys(i).length > 0 && (e.extensions = i), e
    }
}
ke.prototype.isShaderMaterial = !0;
class Ie extends xt {
    constructor() {
        super(), this.type = "Camera", this.matrixWorldInverse = new $, this.projectionMatrix = new $, this.projectionMatrixInverse = new $
    }
    copy(t, e) {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
    }
    getWorldDirection(t) {
        void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new w), this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize()
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
Ie.prototype.isCamera = !0;
class Re extends Ie {
    constructor(t = 50, e = 1, i = .1, n = 2e3) {
        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(t, e) {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }
    setFocalLength(t) {
        const e = .5 * this.getFilmHeight() / t;
        this.fov = 2 * n * Math.atan(e), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const t = Math.tan(.5 * i * this.fov);
        return .5 * this.getFilmHeight() / t
    }
    getEffectiveFOV() {
        return 2 * n * Math.atan(Math.tan(.5 * i * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(t, e, i, n, s, r) {
        this.aspect = t / e, null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = r, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const t = this.near;
        let e = t * Math.tan(.5 * i * this.fov) / this.zoom,
            n = 2 * e,
            s = this.aspect * n,
            r = -.5 * s;
        const o = this.view;
        if (null !== this.view && this.view.enabled) {
            const t = o.fullWidth,
                i = o.fullHeight;
            r += o.offsetX * s / t, e -= o.offsetY * n / i, s *= o.width / t, n *= o.height / i
        }
        const a = this.filmOffset;
        0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
    }
}
Re.prototype.isPerspectiveCamera = !0;
class De extends xt {
    constructor(t, e, i) {
        if (super(), this.type = "CubeCamera", !0 !== i.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = i;
        const n = new Re(90, 1, t, e);
        n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new w(1, 0, 0)), this.add(n);
        const s = new Re(90, 1, t, e);
        s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new w(-1, 0, 0)), this.add(s);
        const r = new Re(90, 1, t, e);
        r.layers = this.layers, r.up.set(0, 0, 1), r.lookAt(new w(0, 1, 0)), this.add(r);
        const o = new Re(90, 1, t, e);
        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new w(0, -1, 0)), this.add(o);
        const a = new Re(90, 1, t, e);
        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new w(0, 0, 1)), this.add(a);
        const l = new Re(90, 1, t, e);
        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new w(0, 0, -1)), this.add(l)
    }
    update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const i = this.renderTarget,
            [n, s, r, o, a, l] = this.children,
            h = t.xr.enabled,
            c = t.getRenderTarget();
        t.xr.enabled = !1;
        const d = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0), t.render(e, n), t.setRenderTarget(i, 1), t.render(e, s), t.setRenderTarget(i, 2), t.render(e, r), t.setRenderTarget(i, 3), t.render(e, o), t.setRenderTarget(i, 4), t.render(e, a), i.texture.generateMipmaps = d, t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(c), t.xr.enabled = h
    }
}
class Oe extends m {
    constructor(t, e, i, n, s, r, o, a, l, h) {
        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, i, n, s, r, o = void 0 !== o ? o : 1022, a, l, h), this._needsFlipEnvMap = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(t) {
        this.image = t
    }
}
Oe.prototype.isCubeTexture = !0;
class Fe extends y {
    constructor(t, e, i) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = i), super(t, t, e), e = e || {}, this.texture = new Oe(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006, this.texture._needsFlipEnvMap = !1
    }
    fromEquirectangularTexture(t, e) {
        this.texture.type = e.type, this.texture.format = 1023, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        const i = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            },
            n = new Pe(5, 5, 5),
            s = new ke({
                name: "CubemapFromEquirect",
                uniforms: Te(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: 1,
                blending: 0
            });
        s.uniforms.tEquirect.value = e;
        const r = new _e(n, s),
            o = e.minFilter;
        1008 === e.minFilter && (e.minFilter = 1006);
        return new De(1, 10, this).update(t, r), e.minFilter = o, r.geometry.dispose(), r.material.dispose(), this
    }
    clear(t, e, i, n) {
        const s = t.getRenderTarget();
        for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, i, n);
        t.setRenderTarget(s)
    }
}
Fe.prototype.isWebGLCubeRenderTarget = !0;
class Ne extends m {
    constructor(t, e, i, n, s, r, o, a, l, h, c, d) {
        super(null, r, o, a, l, h, n, s, c, d), this.image = {
            data: t || null,
            width: e || 1,
            height: i || 1
        }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== h ? h : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
}
Ne.prototype.isDataTexture = !0;
const Be = new z,
    Ve = new w;
class Ue {
    constructor(t = new _t, e = new _t, i = new _t, n = new _t, s = new _t, r = new _t) {
        this.planes = [t, e, i, n, s, r]
    }
    set(t, e, i, n, s, r) {
        const o = this.planes;
        return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(s), o[5].copy(r), this
    }
    copy(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
        return this
    }
    setFromProjectionMatrix(t) {
        const e = this.planes,
            i = t.elements,
            n = i[0],
            s = i[1],
            r = i[2],
            o = i[3],
            a = i[4],
            l = i[5],
            h = i[6],
            c = i[7],
            d = i[8],
            u = i[9],
            p = i[10],
            m = i[11],
            g = i[12],
            f = i[13],
            y = i[14],
            v = i[15];
        return e[0].setComponents(o - n, c - a, m - d, v - g).normalize(), e[1].setComponents(o + n, c + a, m + d, v + g).normalize(), e[2].setComponents(o + s, c + l, m + u, v + f).normalize(), e[3].setComponents(o - s, c - l, m - u, v - f).normalize(), e[4].setComponents(o - r, c - h, m - p, v - y).normalize(), e[5].setComponents(o + r, c + h, m + p, v + y).normalize(), this
    }
    intersectsObject(t) {
        const e = t.geometry;
        return null === e.boundingSphere && e.computeBoundingSphere(), Be.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Be)
    }
    intersectsSprite(t) {
        return Be.center.set(0, 0, 0), Be.radius = .7071067811865476, Be.applyMatrix4(t.matrixWorld), this.intersectsSphere(Be)
    }
    intersectsSphere(t) {
        const e = this.planes,
            i = t.center,
            n = -t.radius;
        for (let t = 0; t < 6; t++) {
            if (e[t].distanceToPoint(i) < n) return !1
        }
        return !0
    }
    intersectsBox(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) {
            const n = e[i];
            if (Ve.x = n.normal.x > 0 ? t.max.x : t.min.x, Ve.y = n.normal.y > 0 ? t.max.y : t.min.y, Ve.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(Ve) < 0) return !1
        }
        return !0
    }
    containsPoint(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++)
            if (e[i].distanceToPoint(t) < 0) return !1;
        return !0
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}

function ze() {
    let t = null,
        e = !1,
        i = null,
        n = null;

    function s(e, r) {
        i(e, r), n = t.requestAnimationFrame(s)
    }
    return {
        start: function() {
            !0 !== e && null !== i && (n = t.requestAnimationFrame(s), e = !0)
        },
        stop: function() {
            t.cancelAnimationFrame(n), e = !1
        },
        setAnimationLoop: function(t) {
            i = t
        },
        setContext: function(e) {
            t = e
        }
    }
}

function He(t, e) {
    const i = e.isWebGL2,
        n = new WeakMap;
    return {
        get: function(t) {
            return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
        },
        remove: function(e) {
            e.isInterleavedBufferAttribute && (e = e.data);
            const i = n.get(e);
            i && (t.deleteBuffer(i.buffer), n.delete(e))
        },
        update: function(e, s) {
            if (e.isGLBufferAttribute) {
                const t = n.get(e);
                return void((!t || t.version < e.version) && n.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version
                }))
            }
            e.isInterleavedBufferAttribute && (e = e.data);
            const r = n.get(e);
            void 0 === r ? n.set(e, function(e, n) {
                const s = e.array,
                    r = e.usage,
                    o = t.createBuffer();
                t.bindBuffer(n, o), t.bufferData(n, s, r), e.onUploadCallback();
                let a = 5126;
                return s instanceof Float32Array ? a = 5126 : s instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : s instanceof Uint16Array ? e.isFloat16BufferAttribute ? i ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : s instanceof Int16Array ? a = 5122 : s instanceof Uint32Array ? a = 5125 : s instanceof Int32Array ? a = 5124 : s instanceof Int8Array ? a = 5120 : s instanceof Uint8Array && (a = 5121), {
                    buffer: o,
                    type: a,
                    bytesPerElement: s.BYTES_PER_ELEMENT,
                    version: e.version
                }
            }(e, s)) : r.version < e.version && (! function(e, n, s) {
                const r = n.array,
                    o = n.updateRange;
                t.bindBuffer(s, e), -1 === o.count ? t.bufferSubData(s, 0, r) : (i ? t.bufferSubData(s, o.offset * r.BYTES_PER_ELEMENT, r, o.offset, o.count) : t.bufferSubData(s, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
            }(r.buffer, e, s), r.version = e.version)
        }
    }
}
class Ge extends ae {
    constructor(t = 1, e = 1, i = 1, n = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        };
        const s = t / 2,
            r = e / 2,
            o = Math.floor(i),
            a = Math.floor(n),
            l = o + 1,
            h = a + 1,
            c = t / o,
            d = e / a,
            u = [],
            p = [],
            m = [],
            g = [];
        for (let t = 0; t < h; t++) {
            const e = t * d - r;
            for (let i = 0; i < l; i++) {
                const n = i * c - s;
                p.push(n, -e, 0), m.push(0, 0, 1), g.push(i / o), g.push(1 - t / a)
            }
        }
        for (let t = 0; t < a; t++)
            for (let e = 0; e < o; e++) {
                const i = e + l * t,
                    n = e + l * (t + 1),
                    s = e + 1 + l * (t + 1),
                    r = e + 1 + l * t;
                u.push(i, n, r), u.push(n, s, r)
            }
        this.setIndex(u), this.setAttribute("position", new Kt(p, 3)), this.setAttribute("normal", new Kt(m, 3)), this.setAttribute("uv", new Kt(g, 2))
    }
}
const We = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
        transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    },
    qe = {
        common: {
            diffuse: {
                value: new qt(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new c
            },
            uv2Transform: {
                value: new c
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new h(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new qt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new qt(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new c
            }
        },
        sprite: {
            diffuse: {
                value: new qt(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new h(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new c
            }
        }
    },
    je = {
        basic: {
            uniforms: Ae([qe.common, qe.specularmap, qe.envmap, qe.aomap, qe.lightmap, qe.fog]),
            vertexShader: We.meshbasic_vert,
            fragmentShader: We.meshbasic_frag
        },
        lambert: {
            uniforms: Ae([qe.common, qe.specularmap, qe.envmap, qe.aomap, qe.lightmap, qe.emissivemap, qe.fog, qe.lights, {
                emissive: {
                    value: new qt(0)
                }
            }]),
            vertexShader: We.meshlambert_vert,
            fragmentShader: We.meshlambert_frag
        },
        phong: {
            uniforms: Ae([qe.common, qe.specularmap, qe.envmap, qe.aomap, qe.lightmap, qe.emissivemap, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.fog, qe.lights, {
                emissive: {
                    value: new qt(0)
                },
                specular: {
                    value: new qt(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: We.meshphong_vert,
            fragmentShader: We.meshphong_frag
        },
        standard: {
            uniforms: Ae([qe.common, qe.envmap, qe.aomap, qe.lightmap, qe.emissivemap, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.roughnessmap, qe.metalnessmap, qe.fog, qe.lights, {
                emissive: {
                    value: new qt(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: We.meshphysical_vert,
            fragmentShader: We.meshphysical_frag
        },
        toon: {
            uniforms: Ae([qe.common, qe.aomap, qe.lightmap, qe.emissivemap, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.gradientmap, qe.fog, qe.lights, {
                emissive: {
                    value: new qt(0)
                }
            }]),
            vertexShader: We.meshtoon_vert,
            fragmentShader: We.meshtoon_frag
        },
        matcap: {
            uniforms: Ae([qe.common, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: We.meshmatcap_vert,
            fragmentShader: We.meshmatcap_frag
        },
        points: {
            uniforms: Ae([qe.points, qe.fog]),
            vertexShader: We.points_vert,
            fragmentShader: We.points_frag
        },
        dashed: {
            uniforms: Ae([qe.common, qe.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: We.linedashed_vert,
            fragmentShader: We.linedashed_frag
        },
        depth: {
            uniforms: Ae([qe.common, qe.displacementmap]),
            vertexShader: We.depth_vert,
            fragmentShader: We.depth_frag
        },
        normal: {
            uniforms: Ae([qe.common, qe.bumpmap, qe.normalmap, qe.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: We.normal_vert,
            fragmentShader: We.normal_frag
        },
        sprite: {
            uniforms: Ae([qe.sprite, qe.fog]),
            vertexShader: We.sprite_vert,
            fragmentShader: We.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new c
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: We.background_vert,
            fragmentShader: We.background_frag
        },
        cube: {
            uniforms: Ae([qe.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: We.cube_vert,
            fragmentShader: We.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: We.equirect_vert,
            fragmentShader: We.equirect_frag
        },
        distanceRGBA: {
            uniforms: Ae([qe.common, qe.displacementmap, {
                referencePosition: {
                    value: new w
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: We.distanceRGBA_vert,
            fragmentShader: We.distanceRGBA_frag
        },
        shadow: {
            uniforms: Ae([qe.lights, qe.fog, {
                color: {
                    value: new qt(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: We.shadow_vert,
            fragmentShader: We.shadow_frag
        }
    };

function Ye(t, e, i, n, s) {
    const r = new qt(0);
    let o, a, l = 0,
        h = null,
        c = 0,
        d = null;

    function u(t, e) {
        i.buffers.color.setClear(t.r, t.g, t.b, e, s)
    }
    return {
        getClearColor: function() {
            return r
        },
        setClearColor: function(t, e = 1) {
            r.set(t), l = e, u(r, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(t) {
            l = t, u(r, l)
        },
        render: function(i, s, p, m) {
            let g = !0 === s.isScene ? s.background : null;
            g && g.isTexture && (g = e.get(g));
            const f = t.xr,
                y = f.getSession && f.getSession();
            y && "additive" === y.environmentBlendMode && (g = null), null === g ? u(r, l) : g && g.isColor && (u(g, 1), m = !0), (t.autoClear || m) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || 306 === g.mapping) ? (void 0 === a && (a = new _e(new Pe(1, 1, 1), new ke({
                name: "BackgroundCubeMaterial",
                uniforms: Te(je.cube.uniforms),
                vertexShader: je.cube.vertexShader,
                fragmentShader: je.cube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, i) {
                this.matrixWorld.copyPosition(i.matrixWorld)
            }, Object.defineProperty(a.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }), n.update(a)), a.material.uniforms.envMap.value = g, a.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, h === g && c === g.version && d === t.toneMapping || (a.material.needsUpdate = !0, h = g, c = g.version, d = t.toneMapping), i.unshift(a, a.geometry, a.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new _e(new Ge(2, 2), new ke({
                name: "BackgroundMaterial",
                uniforms: Te(je.background.uniforms),
                vertexShader: je.background.vertexShader,
                fragmentShader: je.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }), n.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), h === g && c === g.version && d === t.toneMapping || (o.material.needsUpdate = !0, h = g, c = g.version, d = t.toneMapping), i.unshift(o, o.geometry, o.material, 0, 0, null))
        }
    }
}

function Je(t, e, i, n) {
    const s = t.getParameter(34921),
        r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = n.isWebGL2 || null !== r,
        a = {},
        l = u(null);
    let h = l;

    function c(e) {
        return n.isWebGL2 ? t.bindVertexArray(e) : r.bindVertexArrayOES(e)
    }

    function d(e) {
        return n.isWebGL2 ? t.deleteVertexArray(e) : r.deleteVertexArrayOES(e)
    }

    function u(t) {
        const e = [],
            i = [],
            n = [];
        for (let t = 0; t < s; t++) e[t] = 0, i[t] = 0, n[t] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: i,
            attributeDivisors: n,
            object: t,
            attributes: {},
            index: null
        }
    }

    function p() {
        const t = h.newAttributes;
        for (let e = 0, i = t.length; e < i; e++) t[e] = 0
    }

    function m(t) {
        g(t, 0)
    }

    function g(i, s) {
        const r = h.newAttributes,
            o = h.enabledAttributes,
            a = h.attributeDivisors;
        if (r[i] = 1, 0 === o[i] && (t.enableVertexAttribArray(i), o[i] = 1), a[i] !== s) {
            (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, s), a[i] = s
        }
    }

    function f() {
        const e = h.newAttributes,
            i = h.enabledAttributes;
        for (let n = 0, s = i.length; n < s; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), i[n] = 0)
    }

    function y(e, i, s, r, o, a) {
        !0 !== n.isWebGL2 || 5124 !== s && 5125 !== s ? t.vertexAttribPointer(e, i, s, r, o, a) : t.vertexAttribIPointer(e, i, s, o, a)
    }

    function v() {
        w(), h !== l && (h = l, c(h.object))
    }

    function w() {
        l.geometry = null, l.program = null, l.wireframe = !1
    }
    return {
        setup: function(s, l, d, v, w) {
            let b = !1;
            if (o) {
                const e = function(e, i, s) {
                    const o = !0 === s.wireframe;
                    let l = a[e.id];
                    void 0 === l && (l = {}, a[e.id] = l);
                    let h = l[i.id];
                    void 0 === h && (h = {}, l[i.id] = h);
                    let c = h[o];
                    void 0 === c && (c = u(n.isWebGL2 ? t.createVertexArray() : r.createVertexArrayOES()), h[o] = c);
                    return c
                }(v, d, l);
                h !== e && (h = e, c(h.object)), b = function(t, e) {
                    const i = h.attributes,
                        n = t.attributes;
                    let s = 0;
                    for (const t in n) {
                        const e = i[t],
                            r = n[t];
                        if (void 0 === e) return !0;
                        if (e.attribute !== r) return !0;
                        if (e.data !== r.data) return !0;
                        s++
                    }
                    return h.attributesNum !== s || h.index !== e
                }(v, w), b && function(t, e) {
                    const i = {},
                        n = t.attributes;
                    let s = 0;
                    for (const t in n) {
                        const e = n[t],
                            r = {};
                        r.attribute = e, e.data && (r.data = e.data), i[t] = r, s++
                    }
                    h.attributes = i, h.attributesNum = s, h.index = e
                }(v, w)
            } else {
                const t = !0 === l.wireframe;
                h.geometry === v.id && h.program === d.id && h.wireframe === t || (h.geometry = v.id, h.program = d.id, h.wireframe = t, b = !0)
            }!0 === s.isInstancedMesh && (b = !0), null !== w && i.update(w, 34963), b && (! function(s, r, o, a) {
                if (!1 === n.isWebGL2 && (s.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                p();
                const l = a.attributes,
                    h = o.getAttributes(),
                    c = r.defaultAttributeValues;
                for (const e in h) {
                    const n = h[e];
                    if (n >= 0) {
                        const r = l[e];
                        if (void 0 !== r) {
                            const e = r.normalized,
                                s = r.itemSize,
                                o = i.get(r);
                            if (void 0 === o) continue;
                            const l = o.buffer,
                                h = o.type,
                                c = o.bytesPerElement;
                            if (r.isInterleavedBufferAttribute) {
                                const i = r.data,
                                    o = i.stride,
                                    d = r.offset;
                                i && i.isInstancedInterleavedBuffer ? (g(n, i.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = i.meshPerAttribute * i.count)) : m(n), t.bindBuffer(34962, l), y(n, s, h, e, o * c, d * c)
                            } else r.isInstancedBufferAttribute ? (g(n, r.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = r.meshPerAttribute * r.count)) : m(n), t.bindBuffer(34962, l), y(n, s, h, e, 0, 0)
                        } else if ("instanceMatrix" === e) {
                            const e = i.get(s.instanceMatrix);
                            if (void 0 === e) continue;
                            const r = e.buffer,
                                o = e.type;
                            g(n + 0, 1), g(n + 1, 1), g(n + 2, 1), g(n + 3, 1), t.bindBuffer(34962, r), t.vertexAttribPointer(n + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(n + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(n + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(n + 3, 4, o, !1, 64, 48)
                        } else if ("instanceColor" === e) {
                            const e = i.get(s.instanceColor);
                            if (void 0 === e) continue;
                            const r = e.buffer,
                                o = e.type;
                            g(n, 1), t.bindBuffer(34962, r), t.vertexAttribPointer(n, 3, o, !1, 12, 0)
                        } else if (void 0 !== c) {
                            const i = c[e];
                            if (void 0 !== i) switch (i.length) {
                                case 2:
                                    t.vertexAttrib2fv(n, i);
                                    break;
                                case 3:
                                    t.vertexAttrib3fv(n, i);
                                    break;
                                case 4:
                                    t.vertexAttrib4fv(n, i);
                                    break;
                                default:
                                    t.vertexAttrib1fv(n, i)
                            }
                        }
                    }
                }
                f()
            }(s, l, d, v), null !== w && t.bindBuffer(34963, i.get(w).buffer))
        },
        reset: v,
        resetDefaultState: w,
        dispose: function() {
            v();
            for (const t in a) {
                const e = a[t];
                for (const t in e) {
                    const i = e[t];
                    for (const t in i) d(i[t].object), delete i[t];
                    delete e[t]
                }
                delete a[t]
            }
        },
        releaseStatesOfGeometry: function(t) {
            if (void 0 === a[t.id]) return;
            const e = a[t.id];
            for (const t in e) {
                const i = e[t];
                for (const t in i) d(i[t].object), delete i[t];
                delete e[t]
            }
            delete a[t.id]
        },
        releaseStatesOfProgram: function(t) {
            for (const e in a) {
                const i = a[e];
                if (void 0 === i[t.id]) continue;
                const n = i[t.id];
                for (const t in n) d(n[t].object), delete n[t];
                delete i[t.id]
            }
        },
        initAttributes: p,
        enableAttribute: m,
        disableUnusedAttributes: f
    }
}

function Xe(t, e, i, n) {
    const s = n.isWebGL2;
    let r;
    this.setMode = function(t) {
        r = t
    }, this.render = function(e, n) {
        t.drawArrays(r, e, n), i.update(n, r, 1)
    }, this.renderInstances = function(n, o, a) {
        if (0 === a) return;
        let l, h;
        if (s) l = t, h = "drawArraysInstanced";
        else if (l = e.get("ANGLE_instanced_arrays"), h = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[h](r, n, o, a), i.update(o, r, a)
    }
}

function $e(t, e, i) {
    let n;

    function s(e) {
        if ("highp" === e) {
            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            e = "mediump"
        }
        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const r = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
    let o = void 0 !== i.precision ? i.precision : "highp";
    const a = s(o);
    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
    const l = !0 === i.logarithmicDepthBuffer,
        h = t.getParameter(34930),
        c = t.getParameter(35660),
        d = t.getParameter(3379),
        u = t.getParameter(34076),
        p = t.getParameter(34921),
        m = t.getParameter(36347),
        g = t.getParameter(36348),
        f = t.getParameter(36349),
        y = c > 0,
        v = r || e.has("OES_texture_float");
    return {
        isWebGL2: r,
        getMaxAnisotropy: function() {
            if (void 0 !== n) return n;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const i = e.get("EXT_texture_filter_anisotropic");
                n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else n = 0;
            return n
        },
        getMaxPrecision: s,
        precision: o,
        logarithmicDepthBuffer: l,
        maxTextures: h,
        maxVertexTextures: c,
        maxTextureSize: d,
        maxCubemapSize: u,
        maxAttributes: p,
        maxVertexUniforms: m,
        maxVaryings: g,
        maxFragmentUniforms: f,
        vertexTextures: y,
        floatFragmentTextures: v,
        floatVertexTextures: y && v,
        maxSamples: r ? t.getParameter(36183) : 0
    }
}

function Ze(t) {
    const e = this;
    let i = null,
        n = 0,
        s = !1,
        r = !1;
    const o = new _t,
        a = new c,
        l = {
            value: null,
            needsUpdate: !1
        };

    function h() {
        l.value !== i && (l.value = i, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
    }

    function d(t, i, n, s) {
        const r = null !== t ? t.length : 0;
        let h = null;
        if (0 !== r) {
            if (h = l.value, !0 !== s || null === h) {
                const e = n + 4 * r,
                    s = i.matrixWorldInverse;
                a.getNormalMatrix(s), (null === h || h.length < e) && (h = new Float32Array(e));
                for (let e = 0, i = n; e !== r; ++e, i += 4) o.copy(t[e]).applyMatrix4(s, a), o.normal.toArray(h, i), h[i + 3] = o.constant
            }
            l.value = h, l.needsUpdate = !0
        }
        return e.numPlanes = r, e.numIntersection = 0, h
    }
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, r) {
        const o = 0 !== t.length || e || 0 !== n || s;
        return s = e, i = d(t, r, 0), n = t.length, o
    }, this.beginShadows = function() {
        r = !0, d(null)
    }, this.endShadows = function() {
        r = !1, h()
    }, this.setState = function(e, o, a) {
        const c = e.clippingPlanes,
            u = e.clipIntersection,
            p = e.clipShadows,
            m = t.get(e);
        if (!s || null === c || 0 === c.length || r && !p) r ? d(null) : h();
        else {
            const t = r ? 0 : n,
                e = 4 * t;
            let s = m.clippingState || null;
            l.value = s, s = d(c, o, e, a);
            for (let t = 0; t !== e; ++t) s[t] = i[t];
            m.clippingState = s, this.numIntersection = u ? this.numPlanes : 0, this.numPlanes += t
        }
    }
}

function Ke(t) {
    let e = new WeakMap;

    function i(t, e) {
        return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t
    }

    function n(t) {
        const i = t.target;
        i.removeEventListener("dispose", n);
        const s = e.get(i);
        void 0 !== s && (e.delete(i), s.dispose())
    }
    return {
        get: function(s) {
            if (s && s.isTexture) {
                const r = s.mapping;
                if (303 === r || 304 === r) {
                    if (e.has(s)) {
                        return i(e.get(s).texture, s.mapping)
                    } {
                        const r = s.image;
                        if (r && r.height > 0) {
                            const o = t.getRenderTarget(),
                                a = new Fe(r.height / 2);
                            return a.fromEquirectangularTexture(t, s), e.set(s, a), t.setRenderTarget(o), s.addEventListener("dispose", n), i(a.texture, s.mapping)
                        }
                        return null
                    }
                }
            }
            return s
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}

function Qe(t) {
    const e = {};

    function i(i) {
        if (void 0 !== e[i]) return e[i];
        let n;
        switch (i) {
            case "WEBGL_depth_texture":
                n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                n = t.getExtension(i)
        }
        return e[i] = n, n
    }
    return {
        has: function(t) {
            return null !== i(t)
        },
        init: function(t) {
            t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float")
        },
        get: function(t) {
            const e = i(t);
            return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
        }
    }
}

function ti(t, e, i, n) {
    const s = {},
        r = new WeakMap;

    function o(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const t in a.attributes) e.remove(a.attributes[t]);
        a.removeEventListener("dispose", o), delete s[a.id];
        const l = r.get(a);
        l && (e.remove(l), r.delete(a)), n.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, i.memory.geometries--
    }

    function a(t) {
        const i = [],
            n = t.index,
            s = t.attributes.position;
        let o = 0;
        if (null !== n) {
            const t = n.array;
            o = n.version;
            for (let e = 0, n = t.length; e < n; e += 3) {
                const n = t[e + 0],
                    s = t[e + 1],
                    r = t[e + 2];
                i.push(n, s, s, r, r, n)
            }
        } else {
            const t = s.array;
            o = s.version;
            for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
                const t = e + 0,
                    n = e + 1,
                    s = e + 2;
                i.push(t, n, n, s, s, t)
            }
        }
        const a = new(Qt(i) > 65535 ? Zt : $t)(i, 1);
        a.version = o;
        const l = r.get(t);
        l && e.remove(l), r.set(t, a)
    }
    return {
        get: function(t, e) {
            return !0 === s[e.id] || (e.addEventListener("dispose", o), s[e.id] = !0, i.memory.geometries++), e
        },
        update: function(t) {
            const i = t.attributes;
            for (const t in i) e.update(i[t], 34962);
            const n = t.morphAttributes;
            for (const t in n) {
                const i = n[t];
                for (let t = 0, n = i.length; t < n; t++) e.update(i[t], 34962)
            }
        },
        getWireframeAttribute: function(t) {
            const e = r.get(t);
            if (e) {
                const i = t.index;
                null !== i && e.version < i.version && a(t)
            } else a(t);
            return r.get(t)
        }
    }
}

function ei(t, e, i, n) {
    const s = n.isWebGL2;
    let r, o, a;
    this.setMode = function(t) {
        r = t
    }, this.setIndex = function(t) {
        o = t.type, a = t.bytesPerElement
    }, this.render = function(e, n) {
        t.drawElements(r, n, o, e * a), i.update(n, r, 1)
    }, this.renderInstances = function(n, l, h) {
        if (0 === h) return;
        let c, d;
        if (s) c = t, d = "drawElementsInstanced";
        else if (c = e.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        c[d](r, l, o, n * a, h), i.update(l, r, h)
    }
}

function ii(t) {
    const e = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function() {
            e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
        },
        update: function(t, i, n) {
            switch (e.calls++, i) {
                case 4:
                    e.triangles += n * (t / 3);
                    break;
                case 1:
                    e.lines += n * (t / 2);
                    break;
                case 3:
                    e.lines += n * (t - 1);
                    break;
                case 2:
                    e.lines += n * t;
                    break;
                case 0:
                    e.points += n * t;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", i)
            }
        }
    }
}

function ni(t, e) {
    return t[0] - e[0]
}

function si(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1])
}

function ri(t) {
    const e = {},
        i = new Float32Array(8),
        n = [];
    for (let t = 0; t < 8; t++) n[t] = [t, 0];
    return {
        update: function(s, r, o, a) {
            const l = s.morphTargetInfluences,
                h = void 0 === l ? 0 : l.length;
            let c = e[r.id];
            if (void 0 === c) {
                c = [];
                for (let t = 0; t < h; t++) c[t] = [t, 0];
                e[r.id] = c
            }
            for (let t = 0; t < h; t++) {
                const e = c[t];
                e[0] = t, e[1] = l[t]
            }
            c.sort(si);
            for (let t = 0; t < 8; t++) t < h && c[t][1] ? (n[t][0] = c[t][0], n[t][1] = c[t][1]) : (n[t][0] = Number.MAX_SAFE_INTEGER, n[t][1] = 0);
            n.sort(ni);
            const d = o.morphTargets && r.morphAttributes.position,
                u = o.morphNormals && r.morphAttributes.normal;
            let p = 0;
            for (let t = 0; t < 8; t++) {
                const e = n[t],
                    s = e[0],
                    o = e[1];
                s !== Number.MAX_SAFE_INTEGER && o ? (d && r.getAttribute("morphTarget" + t) !== d[s] && r.setAttribute("morphTarget" + t, d[s]), u && r.getAttribute("morphNormal" + t) !== u[s] && r.setAttribute("morphNormal" + t, u[s]), i[t] = o, p += o) : (d && !0 === r.hasAttribute("morphTarget" + t) && r.deleteAttribute("morphTarget" + t), u && !0 === r.hasAttribute("morphNormal" + t) && r.deleteAttribute("morphNormal" + t), i[t] = 0)
            }
            const m = r.morphTargetsRelative ? 1 : 1 - p;
            a.getUniforms().setValue(t, "morphTargetBaseInfluence", m), a.getUniforms().setValue(t, "morphTargetInfluences", i)
        }
    }
}

function oi(t, e, i, n) {
    let s = new WeakMap;

    function r(t) {
        const e = t.target;
        e.removeEventListener("dispose", r), i.remove(e.instanceMatrix), null !== e.instanceColor && i.remove(e.instanceColor)
    }
    return {
        update: function(t) {
            const o = n.render.frame,
                a = t.geometry,
                l = e.get(t, a);
            return s.get(l) !== o && (e.update(l), s.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", r) && t.addEventListener("dispose", r), i.update(t.instanceMatrix, 34962), null !== t.instanceColor && i.update(t.instanceColor, 34962)), l
        },
        dispose: function() {
            s = new WeakMap
        }
    }
}
je.physical = {
    uniforms: Ae([je.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new h(1, 1)
        },
        clearcoatNormalMap: {
            value: null
        },
        sheen: {
            value: new qt(0)
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        }
    }]),
    vertexShader: We.meshphysical_vert,
    fragmentShader: We.meshphysical_frag
};
class ai extends m {
    constructor(t = null, e = 1, i = 1, n = 1) {
        super(null), this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
}
ai.prototype.isDataTexture2DArray = !0;
class li extends m {
    constructor(t = null, e = 1, i = 1, n = 1) {
        super(null), this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
}
li.prototype.isDataTexture3D = !0;
const hi = new m,
    ci = new ai,
    di = new li,
    ui = new Oe,
    pi = [],
    mi = [],
    gi = new Float32Array(16),
    fi = new Float32Array(9),
    yi = new Float32Array(4);

function vi(t, e, i) {
    const n = t[0];
    if (n <= 0 || n > 0) return t;
    const s = e * i;
    let r = pi[s];
    if (void 0 === r && (r = new Float32Array(s), pi[s] = r), 0 !== e) {
        n.toArray(r, 0);
        for (let n = 1, s = 0; n !== e; ++n) s += i, t[n].toArray(r, s)
    }
    return r
}

function wi(t, e) {
    if (t.length !== e.length) return !1;
    for (let i = 0, n = t.length; i < n; i++)
        if (t[i] !== e[i]) return !1;
    return !0
}

function bi(t, e) {
    for (let i = 0, n = e.length; i < n; i++) t[i] = e[i]
}

function xi(t, e) {
    let i = mi[e];
    void 0 === i && (i = new Int32Array(e), mi[e] = i);
    for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
    return i
}

function Si(t, e) {
    const i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
}

function Mi(t, e) {
    const i = this.cache;
    if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
    else {
        if (wi(i, e)) return;
        t.uniform2fv(this.addr, e), bi(i, e)
    }
}

function Ci(t, e) {
    const i = this.cache;
    if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
    else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
    else {
        if (wi(i, e)) return;
        t.uniform3fv(this.addr, e), bi(i, e)
    }
}

function _i(t, e) {
    const i = this.cache;
    if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
    else {
        if (wi(i, e)) return;
        t.uniform4fv(this.addr, e), bi(i, e)
    }
}

function Ei(t, e) {
    const i = this.cache,
        n = e.elements;
    if (void 0 === n) {
        if (wi(i, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), bi(i, e)
    } else {
        if (wi(i, n)) return;
        yi.set(n), t.uniformMatrix2fv(this.addr, !1, yi), bi(i, n)
    }
}

function Pi(t, e) {
    const i = this.cache,
        n = e.elements;
    if (void 0 === n) {
        if (wi(i, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), bi(i, e)
    } else {
        if (wi(i, n)) return;
        fi.set(n), t.uniformMatrix3fv(this.addr, !1, fi), bi(i, n)
    }
}

function Ti(t, e) {
    const i = this.cache,
        n = e.elements;
    if (void 0 === n) {
        if (wi(i, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), bi(i, e)
    } else {
        if (wi(i, n)) return;
        gi.set(n), t.uniformMatrix4fv(this.addr, !1, gi), bi(i, n)
    }
}

function Ai(t, e) {
    const i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
}

function Li(t, e) {
    const i = this.cache;
    wi(i, e) || (t.uniform2iv(this.addr, e), bi(i, e))
}

function ki(t, e) {
    const i = this.cache;
    wi(i, e) || (t.uniform3iv(this.addr, e), bi(i, e))
}

function Ii(t, e) {
    const i = this.cache;
    wi(i, e) || (t.uniform4iv(this.addr, e), bi(i, e))
}

function Ri(t, e) {
    const i = this.cache;
    i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e)
}

function Di(t, e) {
    const i = this.cache;
    wi(i, e) || (t.uniform2uiv(this.addr, e), bi(i, e))
}

function Oi(t, e) {
    const i = this.cache;
    wi(i, e) || (t.uniform3uiv(this.addr, e), bi(i, e))
}

function Fi(t, e) {
    const i = this.cache;
    wi(i, e) || (t.uniform4uiv(this.addr, e), bi(i, e))
}

function Ni(t, e, i) {
    const n = this.cache,
        s = i.allocateTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.safeSetTexture2D(e || hi, s)
}

function Bi(t, e, i) {
    const n = this.cache,
        s = i.allocateTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.setTexture3D(e || di, s)
}

function Vi(t, e, i) {
    const n = this.cache,
        s = i.allocateTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.safeSetTextureCube(e || ui, s)
}

function Ui(t, e, i) {
    const n = this.cache,
        s = i.allocateTextureUnit();
    n[0] !== s && (t.uniform1i(this.addr, s), n[0] = s), i.setTexture2DArray(e || ci, s)
}

function zi(t, e) {
    t.uniform1fv(this.addr, e)
}

function Hi(t, e) {
    const i = vi(e, this.size, 2);
    t.uniform2fv(this.addr, i)
}

function Gi(t, e) {
    const i = vi(e, this.size, 3);
    t.uniform3fv(this.addr, i)
}

function Wi(t, e) {
    const i = vi(e, this.size, 4);
    t.uniform4fv(this.addr, i)
}

function qi(t, e) {
    const i = vi(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, i)
}

function ji(t, e) {
    const i = vi(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, i)
}

function Yi(t, e) {
    const i = vi(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, i)
}

function Ji(t, e) {
    t.uniform1iv(this.addr, e)
}

function Xi(t, e) {
    t.uniform2iv(this.addr, e)
}

function $i(t, e) {
    t.uniform3iv(this.addr, e)
}

function Zi(t, e) {
    t.uniform4iv(this.addr, e)
}

function Ki(t, e) {
    t.uniform1uiv(this.addr, e)
}

function Qi(t, e) {
    t.uniform2uiv(this.addr, e)
}

function tn(t, e) {
    t.uniform3uiv(this.addr, e)
}

function en(t, e) {
    t.uniform4uiv(this.addr, e)
}

function nn(t, e, i) {
    const n = e.length,
        s = xi(i, n);
    t.uniform1iv(this.addr, s);
    for (let t = 0; t !== n; ++t) i.safeSetTexture2D(e[t] || hi, s[t])
}

function sn(t, e, i) {
    const n = e.length,
        s = xi(i, n);
    t.uniform1iv(this.addr, s);
    for (let t = 0; t !== n; ++t) i.safeSetTextureCube(e[t] || ui, s[t])
}

function rn(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
        switch (t) {
            case 5126:
                return Si;
            case 35664:
                return Mi;
            case 35665:
                return Ci;
            case 35666:
                return _i;
            case 35674:
                return Ei;
            case 35675:
                return Pi;
            case 35676:
                return Ti;
            case 5124:
            case 35670:
                return Ai;
            case 35667:
            case 35671:
                return Li;
            case 35668:
            case 35672:
                return ki;
            case 35669:
            case 35673:
                return Ii;
            case 5125:
                return Ri;
            case 36294:
                return Di;
            case 36295:
                return Oi;
            case 36296:
                return Fi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Ni;
            case 35679:
            case 36299:
            case 36307:
                return Bi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Vi;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Ui
        }
    }(e.type)
}

function on(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
        switch (t) {
            case 5126:
                return zi;
            case 35664:
                return Hi;
            case 35665:
                return Gi;
            case 35666:
                return Wi;
            case 35674:
                return qi;
            case 35675:
                return ji;
            case 35676:
                return Yi;
            case 5124:
            case 35670:
                return Ji;
            case 35667:
            case 35671:
                return Xi;
            case 35668:
            case 35672:
                return $i;
            case 35669:
            case 35673:
                return Zi;
            case 5125:
                return Ki;
            case 36294:
                return Qi;
            case 36295:
                return tn;
            case 36296:
                return en;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return nn;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return sn
        }
    }(e.type)
}

function an(t) {
    this.id = t, this.seq = [], this.map = {}
}
on.prototype.updateCache = function(t) {
    const e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), bi(e, t)
}, an.prototype.setValue = function(t, e, i) {
    const n = this.seq;
    for (let s = 0, r = n.length; s !== r; ++s) {
        const r = n[s];
        r.setValue(t, e[r.id], i)
    }
};
const ln = /(\w+)(\])?(\[|\.)?/g;

function hn(t, e) {
    t.seq.push(e), t.map[e.id] = e
}

function cn(t, e, i) {
    const n = t.name,
        s = n.length;
    for (ln.lastIndex = 0;;) {
        const r = ln.exec(n),
            o = ln.lastIndex;
        let a = r[1];
        const l = "]" === r[2],
            h = r[3];
        if (l && (a |= 0), void 0 === h || "[" === h && o + 2 === s) {
            hn(i, void 0 === h ? new rn(a, t, e) : new on(a, t, e));
            break
        } {
            let t = i.map[a];
            void 0 === t && (t = new an(a), hn(i, t)), i = t
        }
    }
}

function dn(t, e) {
    this.seq = [], this.map = {};
    const i = t.getProgramParameter(e, 35718);
    for (let n = 0; n < i; ++n) {
        const i = t.getActiveUniform(e, n);
        cn(i, t.getUniformLocation(e, i.name), this)
    }
}

function un(t, e, i) {
    const n = t.createShader(e);
    return t.shaderSource(n, i), t.compileShader(n), n
}
dn.prototype.setValue = function(t, e, i, n) {
    const s = this.map[e];
    void 0 !== s && s.setValue(t, i, n)
}, dn.prototype.setOptional = function(t, e, i) {
    const n = e[i];
    void 0 !== n && this.setValue(t, i, n)
}, dn.upload = function(t, e, i, n) {
    for (let s = 0, r = e.length; s !== r; ++s) {
        const r = e[s],
            o = i[r.id];
        !1 !== o.needsUpdate && r.setValue(t, o.value, n)
    }
}, dn.seqWithValue = function(t, e) {
    const i = [];
    for (let n = 0, s = t.length; n !== s; ++n) {
        const s = t[n];
        s.id in e && i.push(s)
    }
    return i
};
let pn = 0;

function mn(t) {
    switch (t) {
        case 3e3:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
            return ["LogLuv", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
    }
}

function gn(t, e, i) {
    const n = t.getShaderParameter(e, 35713),
        s = t.getShaderInfoLog(e).trim();
    if (n && "" === s) return "";
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + s + function(t) {
        const e = t.split("\n");
        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join("\n")
    }(t.getShaderSource(e))
}

function fn(t, e) {
    const i = mn(e);
    return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
}

function yn(t, e) {
    const i = mn(e);
    return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
}

function vn(t, e) {
    let i;
    switch (e) {
        case 1:
            i = "Linear";
            break;
        case 2:
            i = "Reinhard";
            break;
        case 3:
            i = "OptimizedCineon";
            break;
        case 4:
            i = "ACESFilmic";
            break;
        case 5:
            i = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear"
    }
    return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
}

function wn(t) {
    return "" !== t
}

function bn(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function xn(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Sn = /^[ \t]*#include +<([\w\d./]+)>/gm;

function Mn(t) {
    return t.replace(Sn, Cn)
}

function Cn(t, e) {
    const i = We[e];
    if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
    return Mn(i)
}
const _n = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    En = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function Pn(t) {
    return t.replace(En, An).replace(_n, Tn)
}

function Tn(t, e, i, n) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), An(t, e, i, n)
}

function An(t, e, i, n) {
    let s = "";
    for (let t = parseInt(e); t < parseInt(i); t++) s += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
    return s
}

function Ln(t) {
    let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
    return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
}

function kn(t, e, i, n) {
    const s = t.getContext(),
        r = i.defines;
    let o = i.vertexShader,
        a = i.fragmentShader;
    const l = function(t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
        }(i),
        h = function(t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap) switch (t.envMapMode) {
                case 301:
                case 302:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    e = "ENVMAP_TYPE_CUBE_UV"
            }
            return e
        }(i),
        c = function(t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap) switch (t.envMapMode) {
                case 302:
                case 307:
                    e = "ENVMAP_MODE_REFRACTION"
            }
            return e
        }(i),
        d = function(t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap) switch (t.combine) {
                case 0:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    e = "ENVMAP_BLENDING_ADD"
            }
            return e
        }(i),
        u = t.gammaFactor > 0 ? t.gammaFactor : 1,
        p = i.isWebGL2 ? "" : function(t) {
            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(wn).join("\n")
        }(i),
        m = function(t) {
            const e = [];
            for (const i in t) {
                const n = t[i];
                !1 !== n && e.push("#define " + i + " " + n)
            }
            return e.join("\n")
        }(r),
        g = s.createProgram();
    let f, y, v = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
    i.isRawShaderMaterial ? (f = [m].filter(wn).join("\n"), f.length > 0 && (f += "\n"), y = [p, m].filter(wn).join("\n"), y.length > 0 && (y += "\n")) : (f = [Ln(i), "#define SHADER_NAME " + i.shaderName, m, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + u, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(wn).join("\n"), y = [p, Ln(i), "#define SHADER_NAME " + i.shaderName, m, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + u, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + d : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? We.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? vn("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", We.encodings_pars_fragment, i.map ? fn("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? fn("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? fn("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? fn("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.lightMap ? fn("lightMapTexelToLinear", i.lightMapEncoding) : "", yn("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(wn).join("\n")), o = Mn(o), o = bn(o, i), o = xn(o, i), a = Mn(a), a = bn(a, i), a = xn(a, i), o = Pn(o), a = Pn(a), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (v = "#version 300 es\n", f = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + f, y = ["#define varying in", "300 es" === i.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === i.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
    const w = v + y + a,
        b = un(s, 35633, v + f + o),
        x = un(s, 35632, w);
    if (s.attachShader(g, b), s.attachShader(g, x), void 0 !== i.index0AttributeName ? s.bindAttribLocation(g, 0, i.index0AttributeName) : !0 === i.morphTargets && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g), t.debug.checkShaderErrors) {
        const t = s.getProgramInfoLog(g).trim(),
            e = s.getShaderInfoLog(b).trim(),
            i = s.getShaderInfoLog(x).trim();
        let n = !0,
            r = !0;
        if (!1 === s.getProgramParameter(g, 35714)) {
            n = !1;
            const e = gn(s, b, "vertex"),
                i = gn(s, x, "fragment");
            console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(g, 35715), "gl.getProgramInfoLog", t, e, i)
        } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== i || (r = !1);
        r && (this.diagnostics = {
            runnable: n,
            programLog: t,
            vertexShader: {
                log: e,
                prefix: f
            },
            fragmentShader: {
                log: i,
                prefix: y
            }
        })
    }
    let S, M;
    return s.deleteShader(b), s.deleteShader(x), this.getUniforms = function() {
        return void 0 === S && (S = new dn(s, g)), S
    }, this.getAttributes = function() {
        return void 0 === M && (M = function(t, e) {
            const i = {},
                n = t.getProgramParameter(e, 35721);
            for (let s = 0; s < n; s++) {
                const n = t.getActiveAttrib(e, s).name;
                i[n] = t.getAttribLocation(e, n)
            }
            return i
        }(s, g)), M
    }, this.destroy = function() {
        n.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0
    }, this.name = i.shaderName, this.id = pn++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = b, this.fragmentShader = x, this
}

function In(t, e, i, n, s, r) {
    const o = [],
        a = n.isWebGL2,
        l = n.logarithmicDepthBuffer,
        h = n.floatVertexTextures,
        c = n.maxVertexUniforms,
        d = n.vertexTextures;
    let u = n.precision;
    const p = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        },
        m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

    function g(t) {
        let e;
        return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e
    }
    return {
        getParameters: function(s, o, m, f, y) {
            const v = f.fog,
                w = s.isMeshStandardMaterial ? f.environment : null,
                b = e.get(s.envMap || w),
                x = p[s.type],
                S = y.isSkinnedMesh ? function(t) {
                    const e = t.skeleton.bones;
                    if (h) return 1024; {
                        const t = c,
                            i = Math.floor((t - 20) / 4),
                            n = Math.min(i, e.length);
                        return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n
                    }
                }(y) : 0;
            let M, C;
            if (null !== s.precision && (u = n.getMaxPrecision(s.precision), u !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", u, "instead.")), x) {
                const t = je[x];
                M = t.vertexShader, C = t.fragmentShader
            } else M = s.vertexShader, C = s.fragmentShader;
            const _ = t.getRenderTarget();
            return {
                isWebGL2: a,
                shaderID: x,
                shaderName: s.type,
                vertexShader: M,
                fragmentShader: C,
                defines: s.defines,
                isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                glslVersion: s.glslVersion,
                precision: u,
                instancing: !0 === y.isInstancedMesh,
                instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                supportsVertexTextures: d,
                outputEncoding: null !== _ ? g(_.texture) : t.outputEncoding,
                map: !!s.map,
                mapEncoding: g(s.map),
                matcap: !!s.matcap,
                matcapEncoding: g(s.matcap),
                envMap: !!b,
                envMapMode: b && b.mapping,
                envMapEncoding: g(b),
                envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
                lightMap: !!s.lightMap,
                lightMapEncoding: g(s.lightMap),
                aoMap: !!s.aoMap,
                emissiveMap: !!s.emissiveMap,
                emissiveMapEncoding: g(s.emissiveMap),
                bumpMap: !!s.bumpMap,
                normalMap: !!s.normalMap,
                objectSpaceNormalMap: 1 === s.normalMapType,
                tangentSpaceNormalMap: 0 === s.normalMapType,
                clearcoatMap: !!s.clearcoatMap,
                clearcoatRoughnessMap: !!s.clearcoatRoughnessMap,
                clearcoatNormalMap: !!s.clearcoatNormalMap,
                displacementMap: !!s.displacementMap,
                roughnessMap: !!s.roughnessMap,
                metalnessMap: !!s.metalnessMap,
                specularMap: !!s.specularMap,
                alphaMap: !!s.alphaMap,
                gradientMap: !!s.gradientMap,
                sheen: !!s.sheen,
                transmissionMap: !!s.transmissionMap,
                combine: s.combine,
                vertexTangents: s.normalMap && s.vertexTangents,
                vertexColors: s.vertexColors,
                vertexAlphas: !0 === s.vertexColors && y.geometry && y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
                vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap),
                uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmissionMap || !s.displacementMap),
                fog: !!v,
                useFog: s.fog,
                fogExp2: v && v.isFogExp2,
                flatShading: !!s.flatShading,
                sizeAttenuation: s.sizeAttenuation,
                logarithmicDepthBuffer: l,
                skinning: s.skinning && S > 0,
                maxBones: S,
                useVertexTexture: h,
                morphTargets: s.morphTargets,
                morphNormals: s.morphNormals,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numDirLightShadows: o.directionalShadowMap.length,
                numPointLightShadows: o.pointShadowMap.length,
                numSpotLightShadows: o.spotShadowMap.length,
                numClippingPlanes: r.numPlanes,
                numClipIntersection: r.numIntersection,
                dithering: s.dithering,
                shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: s.toneMapped ? t.toneMapping : 0,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: s.premultipliedAlpha,
                alphaTest: s.alphaTest,
                doubleSided: 2 === s.side,
                flipSided: 1 === s.side,
                depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                index0AttributeName: s.index0AttributeName,
                extensionDerivatives: s.extensions && s.extensions.derivatives,
                extensionFragDepth: s.extensions && s.extensions.fragDepth,
                extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: a || i.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: a || i.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: a || i.has("EXT_shader_texture_lod"),
                customProgramCacheKey: s.customProgramCacheKey()
            }
        },
        getProgramCacheKey: function(e) {
            const i = [];
            if (e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                for (const t in e.defines) i.push(t), i.push(e.defines[t]);
            if (!1 === e.isRawShaderMaterial) {
                for (let t = 0; t < m.length; t++) i.push(e[m[t]]);
                i.push(t.outputEncoding), i.push(t.gammaFactor)
            }
            return i.push(e.customProgramCacheKey), i.join()
        },
        getUniforms: function(t) {
            const e = p[t.type];
            let i;
            if (e) {
                const t = je[e];
                i = Le.clone(t.uniforms)
            } else i = t.uniforms;
            return i
        },
        acquireProgram: function(e, i) {
            let n;
            for (let t = 0, e = o.length; t < e; t++) {
                const e = o[t];
                if (e.cacheKey === i) {
                    n = e, ++n.usedTimes;
                    break
                }
            }
            return void 0 === n && (n = new kn(t, i, e, s), o.push(n)), n
        },
        releaseProgram: function(t) {
            if (0 == --t.usedTimes) {
                const e = o.indexOf(t);
                o[e] = o[o.length - 1], o.pop(), t.destroy()
            }
        },
        programs: o
    }
}

function Rn() {
    let t = new WeakMap;
    return {
        get: function(e) {
            let i = t.get(e);
            return void 0 === i && (i = {}, t.set(e, i)), i
        },
        remove: function(e) {
            t.delete(e)
        },
        update: function(e, i, n) {
            t.get(e)[i] = n
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}

function Dn(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
}

function On(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
}

function Fn(t) {
    const e = [];
    let i = 0;
    const n = [],
        s = [],
        r = {
            id: -1
        };

    function o(n, s, o, a, l, h) {
        let c = e[i];
        const d = t.get(o);
        return void 0 === c ? (c = {
            id: n.id,
            object: n,
            geometry: s,
            material: o,
            program: d.program || r,
            groupOrder: a,
            renderOrder: n.renderOrder,
            z: l,
            group: h
        }, e[i] = c) : (c.id = n.id, c.object = n, c.geometry = s, c.material = o, c.program = d.program || r, c.groupOrder = a, c.renderOrder = n.renderOrder, c.z = l, c.group = h), i++, c
    }
    return {
        opaque: n,
        transparent: s,
        init: function() {
            i = 0, n.length = 0, s.length = 0
        },
        push: function(t, e, i, r, a, l) {
            const h = o(t, e, i, r, a, l);
            (!0 === i.transparent ? s : n).push(h)
        },
        unshift: function(t, e, i, r, a, l) {
            const h = o(t, e, i, r, a, l);
            (!0 === i.transparent ? s : n).unshift(h)
        },
        finish: function() {
            for (let t = i, n = e.length; t < n; t++) {
                const i = e[t];
                if (null === i.id) break;
                i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null
            }
        },
        sort: function(t, e) {
            n.length > 1 && n.sort(t || Dn), s.length > 1 && s.sort(e || On)
        }
    }
}

function Nn(t) {
    let e = new WeakMap;
    return {
        get: function(i, n) {
            let s;
            return !1 === e.has(i) ? (s = new Fn(t), e.set(i, [s])) : n >= e.get(i).length ? (s = new Fn(t), e.get(i).push(s)) : s = e.get(i)[n], s
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}

function Bn() {
    const t = {};
    return {
        get: function(e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let i;
            switch (e.type) {
                case "DirectionalLight":
                    i = {
                        direction: new w,
                        color: new qt
                    };
                    break;
                case "SpotLight":
                    i = {
                        position: new w,
                        direction: new w,
                        color: new qt,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    i = {
                        position: new w,
                        color: new qt,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    i = {
                        direction: new w,
                        skyColor: new qt,
                        groundColor: new qt
                    };
                    break;
                case "RectAreaLight":
                    i = {
                        color: new qt,
                        position: new w,
                        halfWidth: new w,
                        halfHeight: new w
                    }
            }
            return t[e.id] = i, i
        }
    }
}
let Vn = 0;

function Un(t, e) {
    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
}

function zn(t, e) {
    const i = new Bn,
        n = function() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let i;
                    switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            i = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new h
                            };
                            break;
                        case "PointLight":
                            i = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new h,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                    }
                    return t[e.id] = i, i
                }
            }
        }(),
        s = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
    for (let t = 0; t < 9; t++) s.probe.push(new w);
    const r = new w,
        o = new $,
        a = new $;
    return {
        setup: function(r) {
            let o = 0,
                a = 0,
                l = 0;
            for (let t = 0; t < 9; t++) s.probe[t].set(0, 0, 0);
            let h = 0,
                c = 0,
                d = 0,
                u = 0,
                p = 0,
                m = 0,
                g = 0,
                f = 0;
            r.sort(Un);
            for (let t = 0, e = r.length; t < e; t++) {
                const e = r[t],
                    y = e.color,
                    v = e.intensity,
                    w = e.distance,
                    b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight) o += y.r * v, a += y.g * v, l += y.b * v;
                else if (e.isLightProbe)
                    for (let t = 0; t < 9; t++) s.probe[t].addScaledVector(e.sh.coefficients[t], v);
                else if (e.isDirectionalLight) {
                    const t = i.get(e);
                    if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
                        const t = e.shadow,
                            i = n.get(e);
                        i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, s.directionalShadow[h] = i, s.directionalShadowMap[h] = b, s.directionalShadowMatrix[h] = e.shadow.matrix, m++
                    }
                    s.directional[h] = t, h++
                } else if (e.isSpotLight) {
                    const t = i.get(e);
                    if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(y).multiplyScalar(v), t.distance = w, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                        const t = e.shadow,
                            i = n.get(e);
                        i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, s.spotShadow[d] = i, s.spotShadowMap[d] = b, s.spotShadowMatrix[d] = e.shadow.matrix, f++
                    }
                    s.spot[d] = t, d++
                } else if (e.isRectAreaLight) {
                    const t = i.get(e);
                    t.color.copy(y).multiplyScalar(v), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), s.rectArea[u] = t, u++
                } else if (e.isPointLight) {
                    const t = i.get(e);
                    if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                        const t = e.shadow,
                            i = n.get(e);
                        i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, s.pointShadow[c] = i, s.pointShadowMap[c] = b, s.pointShadowMatrix[c] = e.shadow.matrix, g++
                    }
                    s.point[c] = t, c++
                } else if (e.isHemisphereLight) {
                    const t = i.get(e);
                    t.skyColor.copy(e.color).multiplyScalar(v), t.groundColor.copy(e.groundColor).multiplyScalar(v), s.hemi[p] = t, p++
                }
            }
            u > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (s.rectAreaLTC1 = qe.LTC_FLOAT_1, s.rectAreaLTC2 = qe.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (s.rectAreaLTC1 = qe.LTC_HALF_1, s.rectAreaLTC2 = qe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), s.ambient[0] = o, s.ambient[1] = a, s.ambient[2] = l;
            const y = s.hash;
            y.directionalLength === h && y.pointLength === c && y.spotLength === d && y.rectAreaLength === u && y.hemiLength === p && y.numDirectionalShadows === m && y.numPointShadows === g && y.numSpotShadows === f || (s.directional.length = h, s.spot.length = d, s.rectArea.length = u, s.point.length = c, s.hemi.length = p, s.directionalShadow.length = m, s.directionalShadowMap.length = m, s.pointShadow.length = g, s.pointShadowMap.length = g, s.spotShadow.length = f, s.spotShadowMap.length = f, s.directionalShadowMatrix.length = m, s.pointShadowMatrix.length = g, s.spotShadowMatrix.length = f, y.directionalLength = h, y.pointLength = c, y.spotLength = d, y.rectAreaLength = u, y.hemiLength = p, y.numDirectionalShadows = m, y.numPointShadows = g, y.numSpotShadows = f, s.version = Vn++)
        },
        setupView: function(t, e) {
            let i = 0,
                n = 0,
                l = 0,
                h = 0,
                c = 0;
            const d = e.matrixWorldInverse;
            for (let e = 0, u = t.length; e < u; e++) {
                const u = t[e];
                if (u.isDirectionalLight) {
                    const t = s.directional[i];
                    t.direction.setFromMatrixPosition(u.matrixWorld), r.setFromMatrixPosition(u.target.matrixWorld), t.direction.sub(r), t.direction.transformDirection(d), i++
                } else if (u.isSpotLight) {
                    const t = s.spot[l];
                    t.position.setFromMatrixPosition(u.matrixWorld), t.position.applyMatrix4(d), t.direction.setFromMatrixPosition(u.matrixWorld), r.setFromMatrixPosition(u.target.matrixWorld), t.direction.sub(r), t.direction.transformDirection(d), l++
                } else if (u.isRectAreaLight) {
                    const t = s.rectArea[h];
                    t.position.setFromMatrixPosition(u.matrixWorld), t.position.applyMatrix4(d), a.identity(), o.copy(u.matrixWorld), o.premultiply(d), a.extractRotation(o), t.halfWidth.set(.5 * u.width, 0, 0), t.halfHeight.set(0, .5 * u.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), h++
                } else if (u.isPointLight) {
                    const t = s.point[n];
                    t.position.setFromMatrixPosition(u.matrixWorld), t.position.applyMatrix4(d), n++
                } else if (u.isHemisphereLight) {
                    const t = s.hemi[c];
                    t.direction.setFromMatrixPosition(u.matrixWorld), t.direction.transformDirection(d), t.direction.normalize(), c++
                }
            }
        },
        state: s
    }
}

function Hn(t, e) {
    const i = new zn(t, e),
        n = [],
        s = [];
    return {
        init: function() {
            n.length = 0, s.length = 0
        },
        state: {
            lightsArray: n,
            shadowsArray: s,
            lights: i
        },
        setupLights: function() {
            i.setup(n)
        },
        setupLightsView: function(t) {
            i.setupView(n, t)
        },
        pushLight: function(t) {
            n.push(t)
        },
        pushShadow: function(t) {
            s.push(t)
        }
    }
}

function Gn(t, e) {
    let i = new WeakMap;
    return {
        get: function(n, s = 0) {
            let r;
            return !1 === i.has(n) ? (r = new Hn(t, e), i.set(n, [r])) : s >= i.get(n).length ? (r = new Hn(t, e), i.get(n).push(r)) : r = i.get(n)[s], r
        },
        dispose: function() {
            i = new WeakMap
        }
    }
}
class Wn extends Bt {
    constructor(t) {
        super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }
}
Wn.prototype.isMeshDepthMaterial = !0;
class qn extends Bt {
    constructor(t) {
        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new w, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }
}
qn.prototype.isMeshDistanceMaterial = !0;

function jn(t, e, i) {
    let n = new Ue;
    const s = new h,
        r = new h,
        o = new f,
        a = [],
        l = [],
        c = {},
        d = i.maxTextureSize,
        u = {
            0: 1,
            1: 0,
            2: 2
        },
        p = new ke({
            defines: {
                SAMPLE_RATE: 2 / 8,
                HALF_SAMPLE_RATE: 1 / 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new h
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        }),
        m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const g = new ae;
    g.setAttribute("position", new Xt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const v = new _e(g, p),
        w = this;

    function b(i, n) {
        const s = e.update(v);
        p.uniforms.shadow_pass.value = i.map.texture, p.uniforms.resolution.value = i.mapSize, p.uniforms.radius.value = i.radius, t.setRenderTarget(i.mapPass), t.clear(), t.renderBufferDirect(n, null, s, p, v, null), m.uniforms.shadow_pass.value = i.mapPass.texture, m.uniforms.resolution.value = i.mapSize, m.uniforms.radius.value = i.radius, t.setRenderTarget(i.map), t.clear(), t.renderBufferDirect(n, null, s, m, v, null)
    }

    function x(t, e, i) {
        const n = t << 0 | e << 1 | i << 2;
        let s = a[n];
        return void 0 === s && (s = new Wn({
            depthPacking: 3201,
            morphTargets: t,
            skinning: e
        }), a[n] = s), s
    }

    function S(t, e, i) {
        const n = t << 0 | e << 1 | i << 2;
        let s = l[n];
        return void 0 === s && (s = new qn({
            morphTargets: t,
            skinning: e
        }), l[n] = s), s
    }

    function M(e, i, n, s, r, o, a) {
        let l = null,
            h = x,
            d = e.customDepthMaterial;
        if (!0 === s.isPointLight && (h = S, d = e.customDistanceMaterial), void 0 === d) {
            let t = !1;
            !0 === n.morphTargets && (t = i.morphAttributes && i.morphAttributes.position && i.morphAttributes.position.length > 0);
            let s = !1;
            !0 === e.isSkinnedMesh && (!0 === n.skinning ? s = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
            l = h(t, s, !0 === e.isInstancedMesh)
        } else l = d;
        if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
            const t = l.uuid,
                e = n.uuid;
            let i = c[t];
            void 0 === i && (i = {}, c[t] = i);
            let s = i[e];
            void 0 === s && (s = l.clone(), i[e] = s), l = s
        }
        return l.visible = n.visible, l.wireframe = n.wireframe, l.side = 3 === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side], l.clipShadows = n.clipShadows, l.clippingPlanes = n.clippingPlanes, l.clipIntersection = n.clipIntersection, l.wireframeLinewidth = n.wireframeLinewidth, l.linewidth = n.linewidth, !0 === s.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(s.matrixWorld), l.nearDistance = r, l.farDistance = o), l
    }

    function C(i, s, r, o, a) {
        if (!1 === i.visible) return;
        if (i.layers.test(s.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === a) && (!i.frustumCulled || n.intersectsObject(i))) {
            i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
            const n = e.update(i),
                s = i.material;
            if (Array.isArray(s)) {
                const e = n.groups;
                for (let l = 0, h = e.length; l < h; l++) {
                    const h = e[l],
                        c = s[h.materialIndex];
                    if (c && c.visible) {
                        const e = M(i, n, c, o, r.near, r.far, a);
                        t.renderBufferDirect(r, null, n, e, i, h)
                    }
                }
            } else if (s.visible) {
                const e = M(i, n, s, o, r.near, r.far, a);
                t.renderBufferDirect(r, null, n, e, i, null)
            }
        }
        const l = i.children;
        for (let t = 0, e = l.length; t < e; t++) C(l[t], s, r, o, a)
    }
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, i, a) {
        if (!1 === w.enabled) return;
        if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
        if (0 === e.length) return;
        const l = t.getRenderTarget(),
            h = t.getActiveCubeFace(),
            c = t.getActiveMipmapLevel(),
            u = t.state;
        u.setBlending(0), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u.setScissorTest(!1);
        for (let l = 0, h = e.length; l < h; l++) {
            const h = e[l],
                c = h.shadow;
            if (void 0 === c) {
                console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                continue
            }
            if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
            s.copy(c.mapSize);
            const p = c.getFrameExtents();
            if (s.multiply(p), r.copy(c.mapSize), (s.x > d || s.y > d) && (s.x > d && (r.x = Math.floor(d / p.x), s.x = r.x * p.x, c.mapSize.x = r.x), s.y > d && (r.y = Math.floor(d / p.y), s.y = r.y * p.y, c.mapSize.y = r.y)), null === c.map && !c.isPointLightShadow && 3 === this.type) {
                const t = {
                    minFilter: 1006,
                    magFilter: 1006,
                    format: 1023
                };
                c.map = new y(s.x, s.y, t), c.map.texture.name = h.name + ".shadowMap", c.mapPass = new y(s.x, s.y, t), c.camera.updateProjectionMatrix()
            }
            if (null === c.map) {
                const t = {
                    minFilter: 1003,
                    magFilter: 1003,
                    format: 1023
                };
                c.map = new y(s.x, s.y, t), c.map.texture.name = h.name + ".shadowMap", c.camera.updateProjectionMatrix()
            }
            t.setRenderTarget(c.map), t.clear();
            const m = c.getViewportCount();
            for (let t = 0; t < m; t++) {
                const e = c.getViewport(t);
                o.set(r.x * e.x, r.y * e.y, r.x * e.z, r.y * e.w), u.viewport(o), c.updateMatrices(h, t), n = c.getFrustum(), C(i, a, c.camera, h, this.type)
            }
            c.isPointLightShadow || 3 !== this.type || b(c, a), c.needsUpdate = !1
        }
        w.needsUpdate = !1, t.setRenderTarget(l, h, c)
    }
}

function Yn(t, e, i) {
    const n = i.isWebGL2;
    const s = new function() {
            let e = !1;
            const i = new f;
            let n = null;
            const s = new f(0, 0, 0, 0);
            return {
                setMask: function(i) {
                    n === i || e || (t.colorMask(i, i, i, i), n = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, n, r, o, a) {
                    !0 === a && (e *= o, n *= o, r *= o), i.set(e, n, r, o), !1 === s.equals(i) && (t.clearColor(e, n, r, o), s.copy(i))
                },
                reset: function() {
                    e = !1, n = null, s.set(-1, 0, 0, 0)
                }
            }
        },
        r = new function() {
            let e = !1,
                i = null,
                n = null,
                s = null;
            return {
                setTest: function(t) {
                    t ? F(2929) : N(2929)
                },
                setMask: function(n) {
                    i === n || e || (t.depthMask(n), i = n)
                },
                setFunc: function(e) {
                    if (n !== e) {
                        if (e) switch (e) {
                            case 0:
                                t.depthFunc(512);
                                break;
                            case 1:
                                t.depthFunc(519);
                                break;
                            case 2:
                                t.depthFunc(513);
                                break;
                            case 3:
                                t.depthFunc(515);
                                break;
                            case 4:
                                t.depthFunc(514);
                                break;
                            case 5:
                                t.depthFunc(518);
                                break;
                            case 6:
                                t.depthFunc(516);
                                break;
                            case 7:
                                t.depthFunc(517);
                                break;
                            default:
                                t.depthFunc(515)
                        } else t.depthFunc(515);
                        n = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    s !== e && (t.clearDepth(e), s = e)
                },
                reset: function() {
                    e = !1, i = null, n = null, s = null
                }
            }
        },
        o = new function() {
            let e = !1,
                i = null,
                n = null,
                s = null,
                r = null,
                o = null,
                a = null,
                l = null,
                h = null;
            return {
                setTest: function(t) {
                    e || (t ? F(2960) : N(2960))
                },
                setMask: function(n) {
                    i === n || e || (t.stencilMask(n), i = n)
                },
                setFunc: function(e, i, o) {
                    n === e && s === i && r === o || (t.stencilFunc(e, i, o), n = e, s = i, r = o)
                },
                setOp: function(e, i, n) {
                    o === e && a === i && l === n || (t.stencilOp(e, i, n), o = e, a = i, l = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    h !== e && (t.clearStencil(e), h = e)
                },
                reset: function() {
                    e = !1, i = null, n = null, s = null, r = null, o = null, a = null, l = null, h = null
                }
            }
        };
    let a = {},
        l = null,
        h = {},
        c = null,
        d = !1,
        u = null,
        p = null,
        m = null,
        g = null,
        y = null,
        v = null,
        w = null,
        b = !1,
        x = null,
        S = null,
        M = null,
        C = null,
        _ = null;
    const E = t.getParameter(35661);
    let P = !1,
        T = 0;
    const A = t.getParameter(7938); - 1 !== A.indexOf("WebGL") ? (T = parseFloat(/^WebGL (\d)/.exec(A)[1]), P = T >= 1) : -1 !== A.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), P = T >= 2);
    let L = null,
        k = {};
    const I = new f(0, 0, t.canvas.width, t.canvas.height),
        R = new f(0, 0, t.canvas.width, t.canvas.height);

    function D(e, i, n) {
        const s = new Uint8Array(4),
            r = t.createTexture();
        t.bindTexture(e, r), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
        for (let e = 0; e < n; e++) t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, s);
        return r
    }
    const O = {};

    function F(e) {
        !0 !== a[e] && (t.enable(e), a[e] = !0)
    }

    function N(e) {
        !1 !== a[e] && (t.disable(e), a[e] = !1)
    }
    O[3553] = D(3553, 3553, 1), O[34067] = D(34067, 34069, 6), s.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), F(2929), r.setFunc(3), z(!1), H(1), F(2884), U(0);
    const B = {
        100: 32774,
        101: 32778,
        102: 32779
    };
    if (n) B[103] = 32775, B[104] = 32776;
    else {
        const t = e.get("EXT_blend_minmax");
        null !== t && (B[103] = t.MIN_EXT, B[104] = t.MAX_EXT)
    }
    const V = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773
    };

    function U(e, i, n, s, r, o, a, l) {
        if (0 !== e) {
            if (!1 === d && (F(3042), d = !0), 5 === e) r = r || i, o = o || n, a = a || s, i === p && r === y || (t.blendEquationSeparate(B[i], B[r]), p = i, y = r), n === m && s === g && o === v && a === w || (t.blendFuncSeparate(V[n], V[s], V[o], V[a]), m = n, g = s, v = o, w = a), u = e, b = null;
            else if (e !== u || l !== b) {
                if (100 === p && 100 === y || (t.blendEquation(32774), p = 100, y = 100), l) switch (e) {
                    case 1:
                        t.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case 2:
                        t.blendFunc(1, 1);
                        break;
                    case 3:
                        t.blendFuncSeparate(0, 0, 769, 771);
                        break;
                    case 4:
                        t.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", e)
                } else switch (e) {
                    case 1:
                        t.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case 2:
                        t.blendFunc(770, 1);
                        break;
                    case 3:
                        t.blendFunc(0, 769);
                        break;
                    case 4:
                        t.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", e)
                }
                m = null, g = null, v = null, w = null, u = e, b = l
            }
        } else !0 === d && (N(3042), d = !1)
    }

    function z(e) {
        x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), x = e)
    }

    function H(e) {
        0 !== e ? (F(2884), e !== S && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : N(2884), S = e
    }

    function G(e, i, n) {
        e ? (F(32823), C === i && _ === n || (t.polygonOffset(i, n), C = i, _ = n)) : N(32823)
    }

    function W(e) {
        void 0 === e && (e = 33984 + E - 1), L !== e && (t.activeTexture(e), L = e)
    }
    return {
        buffers: {
            color: s,
            depth: r,
            stencil: o
        },
        enable: F,
        disable: N,
        bindFramebuffer: function(e, i) {
            null === i && null !== l && (i = l), h[e] !== i && (t.bindFramebuffer(e, i), h[e] = i, n && (36009 === e && (h[36160] = i), 36160 === e && (h[36009] = i)))
        },
        bindXRFramebuffer: function(e) {
            e !== l && (t.bindFramebuffer(36160, e), l = e)
        },
        useProgram: function(e) {
            return c !== e && (t.useProgram(e), c = e, !0)
        },
        setBlending: U,
        setMaterial: function(t, e) {
            2 === t.side ? N(2884) : F(2884);
            let i = 1 === t.side;
            e && (i = !i), z(i), 1 === t.blending && !1 === t.transparent ? U(0) : U(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), r.setFunc(t.depthFunc), r.setTest(t.depthTest), r.setMask(t.depthWrite), s.setMask(t.colorWrite);
            const n = t.stencilWrite;
            o.setTest(n), n && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), G(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? F(32926) : N(32926)
        },
        setFlipSided: z,
        setCullFace: H,
        setLineWidth: function(e) {
            e !== M && (P && t.lineWidth(e), M = e)
        },
        setPolygonOffset: G,
        setScissorTest: function(t) {
            t ? F(3089) : N(3089)
        },
        activeTexture: W,
        bindTexture: function(e, i) {
            null === L && W();
            let n = k[L];
            void 0 === n && (n = {
                type: void 0,
                texture: void 0
            }, k[L] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || O[e]), n.type = e, n.texture = i)
        },
        unbindTexture: function() {
            const e = k[L];
            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
        },
        compressedTexImage2D: function() {
            try {
                t.compressedTexImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texImage2D: function() {
            try {
                t.texImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texImage3D: function() {
            try {
                t.texImage3D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        scissor: function(e) {
            !1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), I.copy(e))
        },
        viewport: function(e) {
            !1 === R.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), R.copy(e))
        },
        reset: function() {
            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === n && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, L = null, k = {}, l = null, h = {}, c = null, d = !1, u = null, p = null, m = null, g = null, y = null, v = null, w = null, b = !1, x = null, S = null, M = null, C = null, _ = null, I.set(0, 0, t.canvas.width, t.canvas.height), R.set(0, 0, t.canvas.width, t.canvas.height), s.reset(), r.reset(), o.reset()
        }
    }
}

function Jn(t, e, i, n, s, r, o) {
    const h = s.isWebGL2,
        c = s.maxTextures,
        d = s.maxCubemapSize,
        u = s.maxTextureSize,
        p = s.maxSamples,
        m = new WeakMap;
    let g, f = !1;
    try {
        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
    } catch (t) {}

    function y(t, e) {
        return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
    }

    function v(t, e, i, n) {
        let s = 1;
        if ((t.width > n || t.height > n) && (s = n / Math.max(t.width, t.height)), s < 1 || !0 === e) {
            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                const n = e ? l : Math.floor,
                    r = n(s * t.width),
                    o = n(s * t.height);
                void 0 === g && (g = y(r, o));
                const a = i ? y(r, o) : g;
                a.width = r, a.height = o;
                return a.getContext("2d").drawImage(t, 0, 0, r, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + r + "x" + o + ")."), a
            }
            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
        }
        return t
    }

    function w(t) {
        return a(t.width) && a(t.height)
    }

    function b(t, e) {
        return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
    }

    function x(e, i, s, r) {
        t.generateMipmap(e);
        n.get(i).__maxMipLevel = Math.log2(Math.max(s, r))
    }

    function S(i, n, s) {
        if (!1 === h) return n;
        if (null !== i) {
            if (void 0 !== t[i]) return t[i];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
        }
        let r = n;
        return 6403 === n && (5126 === s && (r = 33326), 5131 === s && (r = 33325), 5121 === s && (r = 33321)), 6407 === n && (5126 === s && (r = 34837), 5131 === s && (r = 34843), 5121 === s && (r = 32849)), 6408 === n && (5126 === s && (r = 34836), 5131 === s && (r = 34842), 5121 === s && (r = 32856)), 33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r || e.get("EXT_color_buffer_float"), r
    }

    function M(t) {
        return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
    }

    function C(e) {
        const i = e.target;
        i.removeEventListener("dispose", C),
            function(e) {
                const i = n.get(e);
                if (void 0 === i.__webglInit) return;
                t.deleteTexture(i.__webglTexture), n.remove(e)
            }(i), i.isVideoTexture && m.delete(i), o.memory.textures--
    }

    function _(e) {
        const i = e.target;
        i.removeEventListener("dispose", _),
            function(e) {
                const i = e.texture,
                    s = n.get(e),
                    r = n.get(i);
                if (!e) return;
                void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                    for (let e = 0; e < 6; e++) t.deleteFramebuffer(s.__webglFramebuffer[e]), s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer[e]);
                else t.deleteFramebuffer(s.__webglFramebuffer), s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer), s.__webglMultisampledFramebuffer && t.deleteFramebuffer(s.__webglMultisampledFramebuffer), s.__webglColorRenderbuffer && t.deleteRenderbuffer(s.__webglColorRenderbuffer), s.__webglDepthRenderbuffer && t.deleteRenderbuffer(s.__webglDepthRenderbuffer);
                n.remove(i), n.remove(e)
            }(i), o.memory.textures--
    }
    let E = 0;

    function P(t, e) {
        const s = n.get(t);
        if (t.isVideoTexture && function(t) {
            const e = o.render.frame;
            m.get(t) !== e && (m.set(t, e), t.update())
        }(t), t.version > 0 && s.__version !== t.version) {
            const i = t.image;
            if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else {
                if (!1 !== i.complete) return void R(s, t, e);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
            }
        }
        i.activeTexture(33984 + e), i.bindTexture(3553, s.__webglTexture)
    }

    function T(e, s) {
        const o = n.get(e);
        e.version > 0 && o.__version !== e.version ? function(e, n, s) {
            if (6 !== n.image.length) return;
            I(e, n), i.activeTexture(33984 + s), i.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
            const o = n && (n.isCompressedTexture || n.image[0].isCompressedTexture),
                a = n.image[0] && n.image[0].isDataTexture,
                l = [];
            for (let t = 0; t < 6; t++) l[t] = o || a ? a ? n.image[t].image : n.image[t] : v(n.image[t], !1, !0, d);
            const c = l[0],
                u = w(c) || h,
                p = r.convert(n.format),
                m = r.convert(n.type),
                g = S(n.internalFormat, p, m);
            let f;
            if (k(34067, n, u), o) {
                for (let t = 0; t < 6; t++) {
                    f = l[t].mipmaps;
                    for (let e = 0; e < f.length; e++) {
                        const s = f[e];
                        1023 !== n.format && 1022 !== n.format ? null !== p ? i.compressedTexImage2D(34069 + t, e, g, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + t, e, g, s.width, s.height, 0, p, m, s.data)
                    }
                }
                e.__maxMipLevel = f.length - 1
            } else {
                f = n.mipmaps;
                for (let t = 0; t < 6; t++)
                    if (a) {
                        i.texImage2D(34069 + t, 0, g, l[t].width, l[t].height, 0, p, m, l[t].data);
                        for (let e = 0; e < f.length; e++) {
                            const n = f[e].image[t].image;
                            i.texImage2D(34069 + t, e + 1, g, n.width, n.height, 0, p, m, n.data)
                        }
                    } else {
                        i.texImage2D(34069 + t, 0, g, p, m, l[t]);
                        for (let e = 0; e < f.length; e++) {
                            const n = f[e];
                            i.texImage2D(34069 + t, e + 1, g, p, m, n.image[t])
                        }
                    } e.__maxMipLevel = f.length
            }
            b(n, u) && x(34067, n, c.width, c.height);
            e.__version = n.version, n.onUpdate && n.onUpdate(n)
        }(o, e, s) : (i.activeTexture(33984 + s), i.bindTexture(34067, o.__webglTexture))
    }
    const A = {
            1e3: 10497,
            1001: 33071,
            1002: 33648
        },
        L = {
            1003: 9728,
            1004: 9984,
            1005: 9986,
            1006: 9729,
            1007: 9985,
            1008: 9987
        };

    function k(i, r, o) {
        if (o ? (t.texParameteri(i, 10242, A[r.wrapS]), t.texParameteri(i, 10243, A[r.wrapT]), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, A[r.wrapR]), t.texParameteri(i, 10240, L[r.magFilter]), t.texParameteri(i, 10241, L[r.minFilter])) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), 1001 === r.wrapS && 1001 === r.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, M(r.magFilter)), t.texParameteri(i, 10241, M(r.minFilter)), 1003 !== r.minFilter && 1006 !== r.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
            const o = e.get("EXT_texture_filter_anisotropic");
            if (1015 === r.type && !1 === e.has("OES_texture_float_linear")) return;
            if (!1 === h && 1016 === r.type && !1 === e.has("OES_texture_half_float_linear")) return;
            (r.anisotropy > 1 || n.get(r).__currentAnisotropy) && (t.texParameterf(i, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, s.getMaxAnisotropy())), n.get(r).__currentAnisotropy = r.anisotropy)
        }
    }

    function I(e, i) {
        void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", C), e.__webglTexture = t.createTexture(), o.memory.textures++)
    }

    function R(e, n, s) {
        let o = 3553;
        n.isDataTexture2DArray && (o = 35866), n.isDataTexture3D && (o = 32879), I(e, n), i.activeTexture(33984 + s), i.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
        const a = function(t) {
                return !h && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)
            }(n) && !1 === w(n.image),
            l = v(n.image, a, !1, u),
            c = w(l) || h,
            d = r.convert(n.format);
        let p, m = r.convert(n.type),
            g = S(n.internalFormat, d, m);
        k(o, n, c);
        const f = n.mipmaps;
        if (n.isDepthTexture) g = 6402, h ? g = 1015 === n.type ? 36012 : 1014 === n.type ? 33190 : 1020 === n.type ? 35056 : 33189 : 1015 === n.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = r.convert(n.type)), 1027 === n.format && 6402 === g && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = r.convert(n.type))), i.texImage2D(3553, 0, g, l.width, l.height, 0, d, m, null);
        else if (n.isDataTexture)
            if (f.length > 0 && c) {
                for (let t = 0, e = f.length; t < e; t++) p = f[t], i.texImage2D(3553, t, g, p.width, p.height, 0, d, m, p.data);
                n.generateMipmaps = !1, e.__maxMipLevel = f.length - 1
            } else i.texImage2D(3553, 0, g, l.width, l.height, 0, d, m, l.data), e.__maxMipLevel = 0;
        else if (n.isCompressedTexture) {
            for (let t = 0, e = f.length; t < e; t++) p = f[t], 1023 !== n.format && 1022 !== n.format ? null !== d ? i.compressedTexImage2D(3553, t, g, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, t, g, p.width, p.height, 0, d, m, p.data);
            e.__maxMipLevel = f.length - 1
        } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, l.width, l.height, l.depth, 0, d, m, l.data), e.__maxMipLevel = 0;
        else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, l.width, l.height, l.depth, 0, d, m, l.data), e.__maxMipLevel = 0;
        else if (f.length > 0 && c) {
            for (let t = 0, e = f.length; t < e; t++) p = f[t], i.texImage2D(3553, t, g, d, m, p);
            n.generateMipmaps = !1, e.__maxMipLevel = f.length - 1
        } else i.texImage2D(3553, 0, g, d, m, l), e.__maxMipLevel = 0;
        b(n, c) && x(o, n, l.width, l.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
    }

    function D(e, s, o, a) {
        const l = s.texture,
            h = r.convert(l.format),
            c = r.convert(l.type),
            d = S(l.internalFormat, h, c);
        32879 === a || 35866 === a ? i.texImage3D(a, 0, d, s.width, s.height, s.depth, 0, h, c, null) : i.texImage2D(a, 0, d, s.width, s.height, 0, h, c, null), i.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, a, n.get(l).__webglTexture, 0), i.bindFramebuffer(36160, null)
    }

    function O(e, i, n) {
        if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) {
            let s = 33189;
            if (n) {
                const e = i.depthTexture;
                e && e.isDepthTexture && (1015 === e.type ? s = 36012 : 1014 === e.type && (s = 33190));
                const n = N(i);
                t.renderbufferStorageMultisample(36161, n, s, i.width, i.height)
            } else t.renderbufferStorage(36161, s, i.width, i.height);
            t.framebufferRenderbuffer(36160, 36096, 36161, e)
        } else if (i.depthBuffer && i.stencilBuffer) {
            if (n) {
                const e = N(i);
                t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height)
            } else t.renderbufferStorage(36161, 34041, i.width, i.height);
            t.framebufferRenderbuffer(36160, 33306, 36161, e)
        } else {
            const e = i.texture,
                s = r.convert(e.format),
                o = r.convert(e.type),
                a = S(e.internalFormat, s, o);
            if (n) {
                const e = N(i);
                t.renderbufferStorageMultisample(36161, e, a, i.width, i.height)
            } else t.renderbufferStorage(36161, a, i.width, i.height)
        }
        t.bindRenderbuffer(36161, null)
    }

    function F(e) {
        const s = n.get(e),
            r = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture) {
            if (r) throw new Error("target.depthTexture not supported in Cube render targets");
            ! function(e, s) {
                if (s && s.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                if (i.bindFramebuffer(36160, e), !s.depthTexture || !s.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                n.get(s.depthTexture).__webglTexture && s.depthTexture.image.width === s.width && s.depthTexture.image.height === s.height || (s.depthTexture.image.width = s.width, s.depthTexture.image.height = s.height, s.depthTexture.needsUpdate = !0), P(s.depthTexture, 0);
                const r = n.get(s.depthTexture).__webglTexture;
                if (1026 === s.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                else {
                    if (1027 !== s.depthTexture.format) throw new Error("Unknown depthTexture format");
                    t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                }
            }(s.__webglFramebuffer, e)
        } else if (r) {
            s.__webglDepthbuffer = [];
            for (let n = 0; n < 6; n++) i.bindFramebuffer(36160, s.__webglFramebuffer[n]), s.__webglDepthbuffer[n] = t.createRenderbuffer(), O(s.__webglDepthbuffer[n], e, !1)
        } else i.bindFramebuffer(36160, s.__webglFramebuffer), s.__webglDepthbuffer = t.createRenderbuffer(), O(s.__webglDepthbuffer, e, !1);
        i.bindFramebuffer(36160, null)
    }

    function N(t) {
        return h && t.isWebGLMultisampleRenderTarget ? Math.min(p, t.samples) : 0
    }
    let B = !1,
        V = !1;
    this.allocateTextureUnit = function() {
        const t = E;
        return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), E += 1, t
    }, this.resetTextureUnits = function() {
        E = 0
    }, this.setTexture2D = P, this.setTexture2DArray = function(t, e) {
        const s = n.get(t);
        t.version > 0 && s.__version !== t.version ? R(s, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, s.__webglTexture))
    }, this.setTexture3D = function(t, e) {
        const s = n.get(t);
        t.version > 0 && s.__version !== t.version ? R(s, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, s.__webglTexture))
    }, this.setTextureCube = T, this.setupRenderTarget = function(e) {
        const s = e.texture,
            a = n.get(e),
            l = n.get(s);
        e.addEventListener("dispose", _), l.__webglTexture = t.createTexture(), l.__version = s.version, o.memory.textures++;
        const c = !0 === e.isWebGLCubeRenderTarget,
            d = !0 === e.isWebGLMultisampleRenderTarget,
            u = s.isDataTexture3D || s.isDataTexture2DArray,
            p = w(e) || h;
        if (!h || 1022 !== s.format || 1015 !== s.type && 1016 !== s.type || (s.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c) {
            a.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++) a.__webglFramebuffer[e] = t.createFramebuffer()
        } else if (a.__webglFramebuffer = t.createFramebuffer(), d)
            if (h) {
                a.__webglMultisampledFramebuffer = t.createFramebuffer(), a.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, a.__webglColorRenderbuffer);
                const n = r.convert(s.format),
                    o = r.convert(s.type),
                    l = S(s.internalFormat, n, o),
                    h = N(e);
                t.renderbufferStorageMultisample(36161, h, l, e.width, e.height), i.bindFramebuffer(36160, a.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, a.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (a.__webglDepthRenderbuffer = t.createRenderbuffer(), O(a.__webglDepthRenderbuffer, e, !0)), i.bindFramebuffer(36160, null)
            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        if (c) {
            i.bindTexture(34067, l.__webglTexture), k(34067, s, p);
            for (let t = 0; t < 6; t++) D(a.__webglFramebuffer[t], e, 36064, 34069 + t);
            b(s, p) && x(34067, s, e.width, e.height), i.bindTexture(34067, null)
        } else {
            let t = 3553;
            if (u)
                if (h) {
                    t = s.isDataTexture3D ? 32879 : 35866
                } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
            i.bindTexture(t, l.__webglTexture), k(t, s, p), D(a.__webglFramebuffer, e, 36064, t), b(s, p) && x(3553, s, e.width, e.height), i.bindTexture(3553, null)
        }
        e.depthBuffer && F(e)
    }, this.updateRenderTargetMipmap = function(t) {
        const e = t.texture;
        if (b(e, w(t) || h)) {
            const s = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                r = n.get(e).__webglTexture;
            i.bindTexture(s, r), x(s, e, t.width, t.height), i.bindTexture(s, null)
        }
    }, this.updateMultisampleRenderTarget = function(e) {
        if (e.isWebGLMultisampleRenderTarget)
            if (h) {
                const s = e.width,
                    r = e.height;
                let o = 16384;
                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                const a = n.get(e);
                i.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, s, r, 0, 0, s, r, o, 9728), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
    }, this.safeSetTexture2D = function(t, e) {
        t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), P(t, e)
    }, this.safeSetTextureCube = function(t, e) {
        t && t.isWebGLCubeRenderTarget && (!1 === V && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), V = !0), t = t.texture), T(t, e)
    }
}

function Xn(t, e, i) {
    const n = i.isWebGL2;
    return {
        convert: function(t) {
            let i;
            if (1009 === t) return 5121;
            if (1017 === t) return 32819;
            if (1018 === t) return 32820;
            if (1019 === t) return 33635;
            if (1010 === t) return 5120;
            if (1011 === t) return 5122;
            if (1012 === t) return 5123;
            if (1013 === t) return 5124;
            if (1014 === t) return 5125;
            if (1015 === t) return 5126;
            if (1016 === t) return n ? 5131 : (i = e.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
            if (1021 === t) return 6406;
            if (1022 === t) return 6407;
            if (1023 === t) return 6408;
            if (1024 === t) return 6409;
            if (1025 === t) return 6410;
            if (1026 === t) return 6402;
            if (1027 === t) return 34041;
            if (1028 === t) return 6403;
            if (1029 === t) return 36244;
            if (1030 === t) return 33319;
            if (1031 === t) return 33320;
            if (1032 === t) return 36248;
            if (1033 === t) return 36249;
            if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                if (i = e.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
                if (33776 === t) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (33777 === t) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (33778 === t) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (33779 === t) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                if (i = e.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
                if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (36196 === t) return i = e.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
            if ((37492 === t || 37496 === t) && (i = e.get("WEBGL_compressed_texture_etc"), null !== i)) {
                if (37492 === t) return i.COMPRESSED_RGB8_ETC2;
                if (37496 === t) return i.COMPRESSED_RGBA8_ETC2_EAC
            }
            return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (i = e.get("WEBGL_compressed_texture_astc"), null !== i ? t : null) : 36492 === t ? (i = e.get("EXT_texture_compression_bptc"), null !== i ? t : null) : 1020 === t ? n ? 34042 : (i = e.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0
        }
    }
}
class $n extends Re {
    constructor(t = []) {
        super(), this.cameras = t
    }
}
$n.prototype.isArrayCamera = !0;
class Zn extends xt {
    constructor() {
        super(), this.type = "Group"
    }
}
Zn.prototype.isGroup = !0;
const Kn = {
    type: "move"
};
class Qn {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return null === this._hand && (this._hand = new Zn, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new Zn, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new w, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new w), this._targetRay
    }
    getGripSpace() {
        return null === this._grip && (this._grip = new Zn, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new w, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new w), this._grip
    }
    dispatchEvent(t) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
    }
    disconnect(t) {
        return this.dispatchEvent({
            type: "disconnected",
            data: t
        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
    }
    update(t, e, i) {
        let n = null,
            s = null,
            r = null;
        const o = this._targetRay,
            a = this._grip,
            l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState)
            if (null !== o && (n = e.getPose(t.targetRaySpace, i), null !== n && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), n.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = !1, n.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Kn))), l && t.hand) {
                r = !0;
                for (const n of t.hand.values()) {
                    const t = e.getJointPose(n, i);
                    if (void 0 === l.joints[n.jointName]) {
                        const t = new Zn;
                        t.matrixAutoUpdate = !1, t.visible = !1, l.joints[n.jointName] = t, l.add(t)
                    }
                    const s = l.joints[n.jointName];
                    null !== t && (s.matrix.fromArray(t.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.jointRadius = t.radius), s.visible = null !== t
                }
                const n = l.joints["index-finger-tip"],
                    s = l.joints["thumb-tip"],
                    o = n.position.distanceTo(s.position),
                    a = .02,
                    h = .005;
                l.inputState.pinching && o > a + h ? (l.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this
                })) : !l.inputState.pinching && o <= a - h && (l.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this
                }))
            } else null !== a && t.gripSpace && (s = e.getPose(t.gripSpace, i), null !== s && (a.matrix.fromArray(s.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), s.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = !1, s.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = !1));
        return null !== o && (o.visible = null !== n), null !== a && (a.visible = null !== s), null !== l && (l.visible = null !== r), this
    }
}
class ts extends t {
    constructor(t, e) {
        super();
        const i = this,
            n = t.state;
        let s = null,
            r = 1,
            o = null,
            a = "local-floor",
            l = null;
        const h = [],
            c = new Map,
            d = new Re;
        d.layers.enable(1), d.viewport = new f;
        const u = new Re;
        u.layers.enable(2), u.viewport = new f;
        const p = [d, u],
            m = new $n;
        m.layers.enable(1), m.layers.enable(2);
        let g = null,
            y = null;

        function v(t) {
            const e = c.get(t.inputSource);
            e && e.dispatchEvent({
                type: t.type,
                data: t.inputSource
            })
        }

        function b() {
            c.forEach((function(t, e) {
                t.disconnect(e)
            })), c.clear(), g = null, y = null, n.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), E.stop(), i.isPresenting = !1, i.dispatchEvent({
                type: "sessionend"
            })
        }

        function x(t) {
            const e = s.inputSources;
            for (let t = 0; t < h.length; t++) c.set(e[t], h[t]);
            for (let e = 0; e < t.removed.length; e++) {
                const i = t.removed[e],
                    n = c.get(i);
                n && (n.dispatchEvent({
                    type: "disconnected",
                    data: i
                }), c.delete(i))
            }
            for (let e = 0; e < t.added.length; e++) {
                const i = t.added[e],
                    n = c.get(i);
                n && n.dispatchEvent({
                    type: "connected",
                    data: i
                })
            }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
            let e = h[t];
            return void 0 === e && (e = new Qn, h[t] = e), e.getTargetRaySpace()
        }, this.getControllerGrip = function(t) {
            let e = h[t];
            return void 0 === e && (e = new Qn, h[t] = e), e.getGripSpace()
        }, this.getHand = function(t) {
            let e = h[t];
            return void 0 === e && (e = new Qn, h[t] = e), e.getHandSpace()
        }, this.setFramebufferScaleFactor = function(t) {
            r = t, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(t) {
            a = t, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return o
        }, this.getSession = function() {
            return s
        }, this.setSession = async function(t) {
            if (s = t, null !== s) {
                s.addEventListener("select", v), s.addEventListener("selectstart", v), s.addEventListener("selectend", v), s.addEventListener("squeeze", v), s.addEventListener("squeezestart", v), s.addEventListener("squeezeend", v), s.addEventListener("end", b), s.addEventListener("inputsourceschange", x);
                const t = e.getContextAttributes();
                !0 !== t.xrCompatible && await e.makeXRCompatible();
                const n = {
                        antialias: t.antialias,
                        alpha: t.alpha,
                        depth: t.depth,
                        stencil: t.stencil,
                        framebufferScaleFactor: r
                    },
                    l = new XRWebGLLayer(s, e, n);
                s.updateRenderState({
                    baseLayer: l
                }), o = await s.requestReferenceSpace(a), E.setContext(s), E.start(), i.isPresenting = !0, i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        };
        const S = new w,
            M = new w;

        function C(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
        }
        this.getCamera = function(t) {
            m.near = u.near = d.near = t.near, m.far = u.far = d.far = t.far, g === m.near && y === m.far || (s.updateRenderState({
                depthNear: m.near,
                depthFar: m.far
            }), g = m.near, y = m.far);
            const e = t.parent,
                i = m.cameras;
            C(m, e);
            for (let t = 0; t < i.length; t++) C(i[t], e);
            t.matrixWorld.copy(m.matrixWorld), t.matrix.copy(m.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++) n[t].updateMatrixWorld(!0);
            return 2 === i.length ? function(t, e, i) {
                S.setFromMatrixPosition(e.matrixWorld), M.setFromMatrixPosition(i.matrixWorld);
                const n = S.distanceTo(M),
                    s = e.projectionMatrix.elements,
                    r = i.projectionMatrix.elements,
                    o = s[14] / (s[10] - 1),
                    a = s[14] / (s[10] + 1),
                    l = (s[9] + 1) / s[5],
                    h = (s[9] - 1) / s[5],
                    c = (s[8] - 1) / s[0],
                    d = (r[8] + 1) / r[0],
                    u = o * c,
                    p = o * d,
                    m = n / (-c + d),
                    g = m * -c;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(g), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                const f = o + m,
                    y = a + m,
                    v = u - g,
                    w = p + (n - g),
                    b = l * a / y * f,
                    x = h * a / y * f;
                t.projectionMatrix.makePerspective(v, w, b, x, f, y)
            }(m, d, u) : m.projectionMatrix.copy(d.projectionMatrix), m
        };
        let _ = null;
        const E = new ze;
        E.setAnimationLoop((function(t, e) {
            if (l = e.getViewerPose(o), null !== l) {
                const t = l.views,
                    e = s.renderState.baseLayer;
                n.bindXRFramebuffer(e.framebuffer);
                let i = !1;
                t.length !== m.cameras.length && (m.cameras.length = 0, i = !0);
                for (let n = 0; n < t.length; n++) {
                    const s = t[n],
                        r = e.getViewport(s),
                        o = p[n];
                    o.matrix.fromArray(s.transform.matrix), o.projectionMatrix.fromArray(s.projectionMatrix), o.viewport.set(r.x, r.y, r.width, r.height), 0 === n && m.matrix.copy(o.matrix), !0 === i && m.cameras.push(o)
                }
            }
            const i = s.inputSources;
            for (let t = 0; t < h.length; t++) {
                const n = h[t],
                    s = i[t];
                n.update(s, e, o)
            }
            _ && _(t, e)
        })), this.setAnimationLoop = function(t) {
            _ = t
        }, this.dispose = function() {}
    }
}

function es(t) {
    function e(e, i) {
        e.opacity.value = i.opacity, i.color && e.diffuse.value.copy(i.color), i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (e.map.value = i.map), i.alphaMap && (e.alphaMap.value = i.alphaMap), i.specularMap && (e.specularMap.value = i.specularMap);
        const n = t.get(i).envMap;
        if (n) {
            e.envMap.value = n, e.flipEnvMap.value = n.isCubeTexture && n._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = i.reflectivity, e.refractionRatio.value = i.refractionRatio;
            const s = t.get(n).__maxMipLevel;
            void 0 !== s && (e.maxMipLevel.value = s)
        }
        let s, r;
        i.lightMap && (e.lightMap.value = i.lightMap, e.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (e.aoMap.value = i.aoMap, e.aoMapIntensity.value = i.aoMapIntensity), i.map ? s = i.map : i.specularMap ? s = i.specularMap : i.displacementMap ? s = i.displacementMap : i.normalMap ? s = i.normalMap : i.bumpMap ? s = i.bumpMap : i.roughnessMap ? s = i.roughnessMap : i.metalnessMap ? s = i.metalnessMap : i.alphaMap ? s = i.alphaMap : i.emissiveMap ? s = i.emissiveMap : i.clearcoatMap ? s = i.clearcoatMap : i.clearcoatNormalMap ? s = i.clearcoatNormalMap : i.clearcoatRoughnessMap && (s = i.clearcoatRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix)), i.aoMap ? r = i.aoMap : i.lightMap && (r = i.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uv2Transform.value.copy(r.matrix))
    }

    function i(e, i) {
        e.roughness.value = i.roughness, e.metalness.value = i.metalness, i.roughnessMap && (e.roughnessMap.value = i.roughnessMap), i.metalnessMap && (e.metalnessMap.value = i.metalnessMap), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
        t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity)
    }
    return {
        refreshFogUniforms: function(t, e) {
            t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
        },
        refreshMaterialUniforms: function(t, n, s, r) {
            n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n), function(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(t, n)) : n.isMeshToonMaterial ? (e(t, n), function(t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap);
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(t, n)) : n.isMeshPhongMaterial ? (e(t, n), function(t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(t, n)) : n.isMeshStandardMaterial ? (e(t, n), n.isMeshPhysicalMaterial ? function(t, e) {
                i(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
            }(t, n) : i(t, n)) : n.isMeshMatcapMaterial ? (e(t, n), function(t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(t, n)) : n.isMeshDepthMaterial ? (e(t, n), function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n), function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }(t, n)) : n.isMeshNormalMaterial ? (e(t, n), function(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(t, n)) : n.isLineBasicMaterial ? (function(t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
            }(t, n), n.isLineDashedMaterial && function(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }(t, n)) : n.isPointsMaterial ? function(t, e, i, n) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * n, e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                let s;
                e.map ? s = e.map : e.alphaMap && (s = e.alphaMap);
                void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), t.uvTransform.value.copy(s.matrix))
            }(t, n, s, r) : n.isSpriteMaterial ? function(t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                let i;
                e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
            }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
        }
    }
}

function is(t) {
    const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
            const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            return t.style.display = "block", t
        }(),
        i = void 0 !== t.context ? t.context : null,
        n = void 0 !== t.alpha && t.alpha,
        s = void 0 === t.depth || t.depth,
        r = void 0 === t.stencil || t.stencil,
        o = void 0 !== t.antialias && t.antialias,
        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
        d = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
    let u = null,
        p = null;
    const m = [],
        g = [];
    this.domElement = e, this.debug = {
        checkShaderErrors: !0
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
    const y = this;
    let v = !1,
        b = 0,
        x = 0,
        S = null,
        M = -1,
        C = null;
    const _ = new f,
        E = new f;
    let P = null,
        T = e.width,
        A = e.height,
        L = 1,
        k = null,
        I = null;
    const R = new f(0, 0, T, A),
        D = new f(0, 0, T, A);
    let O = !1;
    const F = new Ue;
    let N = !1,
        B = !1;
    const V = new $,
        U = new w,
        z = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };

    function H() {
        return null === S ? L : 1
    }
    let G, W, q, j, Y, J, X, Z, K, Q, tt, et, it, nt, st, rt, ot, at, lt, ht, ct, dt, ut = i;

    function pt(t, i) {
        for (let n = 0; n < t.length; n++) {
            const s = t[n],
                r = e.getContext(s, i);
            if (null !== r) return r
        }
        return null
    }
    try {
        const t = {
            alpha: n,
            depth: s,
            stencil: r,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: d
        };
        if (e.addEventListener("webglcontextlost", ft, !1), e.addEventListener("webglcontextrestored", yt, !1), null === ut) {
            const e = ["webgl2", "webgl", "experimental-webgl"];
            if (!0 === y.isWebGL1Renderer && e.shift(), ut = pt(e, t), null === ut) throw pt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        void 0 === ut.getShaderPrecisionFormat && (ut.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        })
    } catch (t) {
        throw console.error("THREE.WebGLRenderer: " + t.message), t
    }

    function mt() {
        G = new Qe(ut), W = new $e(ut, G, t), G.init(W), ct = new Xn(ut, G, W), q = new Yn(ut, G, W), j = new ii, Y = new Rn, J = new Jn(ut, G, q, Y, W, ct, j), X = new Ke(y), Z = new He(ut, W), dt = new Je(ut, G, Z, W), K = new ti(ut, Z, j, dt), Q = new oi(ut, K, Z, j), at = new ri(ut), st = new Ze(Y), tt = new In(y, X, G, W, dt, st), et = new es(Y), it = new Nn(Y), nt = new Gn(G, W), ot = new Ye(y, X, q, Q, a), rt = new jn(y, Q, W), lt = new Xe(ut, G, j, W), ht = new ei(ut, G, j, W), j.programs = tt.programs, y.capabilities = W, y.extensions = G, y.properties = Y, y.renderLists = it, y.shadowMap = rt, y.state = q, y.info = j
    }
    mt();
    const gt = new ts(y, ut);

    function ft(t) {
        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
    }

    function yt() {
        console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
        const t = j.autoReset,
            e = rt.enabled,
            i = rt.autoUpdate,
            n = rt.needsUpdate,
            s = rt.type;
        mt(), j.autoReset = t, rt.enabled = e, rt.autoUpdate = i, rt.needsUpdate = n, rt.type = s
    }

    function vt(t) {
        const e = t.target;
        e.removeEventListener("dispose", vt),
            function(t) {
                (function(t) {
                    const e = Y.get(t).programs;
                    void 0 !== e && e.forEach((function(t) {
                        tt.releaseProgram(t)
                    }))
                })(t), Y.remove(t)
            }(e)
    }
    this.xr = gt, this.getContext = function() {
        return ut
    }, this.getContextAttributes = function() {
        return ut.getContextAttributes()
    }, this.forceContextLoss = function() {
        const t = G.get("WEBGL_lose_context");
        t && t.loseContext()
    }, this.forceContextRestore = function() {
        const t = G.get("WEBGL_lose_context");
        t && t.restoreContext()
    }, this.getPixelRatio = function() {
        return L
    }, this.setPixelRatio = function(t) {
        void 0 !== t && (L = t, this.setSize(T, A, !1))
    }, this.getSize = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new h), t.set(T, A)
    }, this.setSize = function(t, i, n) {
        gt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, A = i, e.width = Math.floor(t * L), e.height = Math.floor(i * L), !1 !== n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i))
    }, this.getDrawingBufferSize = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new h), t.set(T * L, A * L).floor()
    }, this.setDrawingBufferSize = function(t, i, n) {
        T = t, A = i, L = n, e.width = Math.floor(t * n), e.height = Math.floor(i * n), this.setViewport(0, 0, t, i)
    }, this.getCurrentViewport = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new f), t.copy(_)
    }, this.getViewport = function(t) {
        return t.copy(R)
    }, this.setViewport = function(t, e, i, n) {
        t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, i, n), q.viewport(_.copy(R).multiplyScalar(L).floor())
    }, this.getScissor = function(t) {
        return t.copy(D)
    }, this.setScissor = function(t, e, i, n) {
        t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, i, n), q.scissor(E.copy(D).multiplyScalar(L).floor())
    }, this.getScissorTest = function() {
        return O
    }, this.setScissorTest = function(t) {
        q.setScissorTest(O = t)
    }, this.setOpaqueSort = function(t) {
        k = t
    }, this.setTransparentSort = function(t) {
        I = t
    }, this.getClearColor = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new qt), t.copy(ot.getClearColor())
    }, this.setClearColor = function() {
        ot.setClearColor.apply(ot, arguments)
    }, this.getClearAlpha = function() {
        return ot.getClearAlpha()
    }, this.setClearAlpha = function() {
        ot.setClearAlpha.apply(ot, arguments)
    }, this.clear = function(t, e, i) {
        let n = 0;
        (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), ut.clear(n)
    }, this.clearColor = function() {
        this.clear(!0, !1, !1)
    }, this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }, this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }, this.dispose = function() {
        e.removeEventListener("webglcontextlost", ft, !1), e.removeEventListener("webglcontextrestored", yt, !1), it.dispose(), nt.dispose(), Y.dispose(), X.dispose(), Q.dispose(), dt.dispose(), gt.dispose(), gt.removeEventListener("sessionstart", bt), gt.removeEventListener("sessionend", xt), St.stop()
    }, this.renderBufferImmediate = function(t, e) {
        dt.initAttributes();
        const i = Y.get(t);
        t.hasPositions && !i.position && (i.position = ut.createBuffer()), t.hasNormals && !i.normal && (i.normal = ut.createBuffer()), t.hasUvs && !i.uv && (i.uv = ut.createBuffer()), t.hasColors && !i.color && (i.color = ut.createBuffer());
        const n = e.getAttributes();
        t.hasPositions && (ut.bindBuffer(34962, i.position), ut.bufferData(34962, t.positionArray, 35048), dt.enableAttribute(n.position), ut.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ut.bindBuffer(34962, i.normal), ut.bufferData(34962, t.normalArray, 35048), dt.enableAttribute(n.normal), ut.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ut.bindBuffer(34962, i.uv), ut.bufferData(34962, t.uvArray, 35048), dt.enableAttribute(n.uv), ut.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ut.bindBuffer(34962, i.color), ut.bufferData(34962, t.colorArray, 35048), dt.enableAttribute(n.color), ut.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), dt.disableUnusedAttributes(), ut.drawArrays(4, 0, t.count), t.count = 0
    }, this.renderBufferDirect = function(t, e, i, n, s, r) {
        null === e && (e = z);
        const o = s.isMesh && s.matrixWorld.determinant() < 0,
            a = Tt(t, e, n, s);
        q.setMaterial(n, o);
        let l = i.index;
        const h = i.attributes.position;
        if (null === l) {
            if (void 0 === h || 0 === h.count) return
        } else if (0 === l.count) return;
        let c, d = 1;
        !0 === n.wireframe && (l = K.getWireframeAttribute(i), d = 2), (n.morphTargets || n.morphNormals) && at.update(s, i, n, a), dt.setup(s, n, a, i, l);
        let u = lt;
        null !== l && (c = Z.get(l), u = ht, u.setIndex(c));
        const p = null !== l ? l.count : h.count,
            m = i.drawRange.start * d,
            g = i.drawRange.count * d,
            f = null !== r ? r.start * d : 0,
            y = null !== r ? r.count * d : 1 / 0,
            v = Math.max(m, f),
            w = Math.min(p, m + g, f + y) - 1,
            b = Math.max(0, w - v + 1);
        if (0 !== b) {
            if (s.isMesh) !0 === n.wireframe ? (q.setLineWidth(n.wireframeLinewidth * H()), u.setMode(1)) : u.setMode(4);
            else if (s.isLine) {
                let t = n.linewidth;
                void 0 === t && (t = 1), q.setLineWidth(t * H()), s.isLineSegments ? u.setMode(1) : s.isLineLoop ? u.setMode(2) : u.setMode(3)
            } else s.isPoints ? u.setMode(0) : s.isSprite && u.setMode(4);
            if (s.isInstancedMesh) u.renderInstances(v, b, s.count);
            else if (i.isInstancedBufferGeometry) {
                const t = Math.min(i.instanceCount, i._maxInstanceCount);
                u.renderInstances(v, b, t)
            } else u.render(v, b)
        }
    }, this.compile = function(t, e) {
        p = nt.get(t), p.init(), t.traverseVisible((function(t) {
            t.isLight && t.layers.test(e.layers) && (p.pushLight(t), t.castShadow && p.pushShadow(t))
        })), p.setupLights(), t.traverse((function(e) {
            const i = e.material;
            if (i)
                if (Array.isArray(i))
                    for (let n = 0; n < i.length; n++) {
                        Et(i[n], t, e)
                    } else Et(i, t, e)
        }))
    };
    let wt = null;

    function bt() {
        St.stop()
    }

    function xt() {
        St.start()
    }
    const St = new ze;

    function Mt(t, e, i, n) {
        if (!1 === t.visible) return;
        if (t.layers.test(e.layers))
            if (t.isGroup) i = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
            else if (t.isSprite) {
                if (!t.frustumCulled || F.intersectsSprite(t)) {
                    n && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                    const e = Q.update(t),
                        s = t.material;
                    s.visible && u.push(t, e, s, i, U.z, null)
                }
            } else if (t.isImmediateRenderObject) n && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V), u.push(t, null, t.material, i, U.z, null);
            else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || F.intersectsObject(t))) {
                n && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                const e = Q.update(t),
                    s = t.material;
                if (Array.isArray(s)) {
                    const n = e.groups;
                    for (let r = 0, o = n.length; r < o; r++) {
                        const o = n[r],
                            a = s[o.materialIndex];
                        a && a.visible && u.push(t, e, a, i, U.z, o)
                    }
                } else s.visible && u.push(t, e, s, i, U.z, null)
            }
        const s = t.children;
        for (let t = 0, r = s.length; t < r; t++) Mt(s[t], e, i, n)
    }

    function Ct(t, e, i) {
        const n = !0 === e.isScene ? e.overrideMaterial : null;
        for (let s = 0, r = t.length; s < r; s++) {
            const r = t[s],
                o = r.object,
                a = r.geometry,
                l = null === n ? r.material : n,
                h = r.group;
            if (i.isArrayCamera) {
                const t = i.cameras;
                for (let i = 0, n = t.length; i < n; i++) {
                    const n = t[i];
                    o.layers.test(n.layers) && (q.viewport(_.copy(n.viewport)), p.setupLightsView(n), _t(o, e, n, a, l, h))
                }
            } else _t(o, e, i, a, l, h)
        }
    }

    function _t(t, e, i, n, s, r) {
        if (t.onBeforeRender(y, e, i, n, s, r), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
            const n = Tt(i, e, s, t);
            q.setMaterial(s), dt.reset(),
                function(t, e) {
                    t.render((function(t) {
                        y.renderBufferImmediate(t, e)
                    }))
                }(t, n)
        } else y.renderBufferDirect(i, e, n, s, t, r);
        t.onAfterRender(y, e, i, n, s, r)
    }

    function Et(t, e, i) {
        !0 !== e.isScene && (e = z);
        const n = Y.get(t),
            s = p.state.lights,
            r = p.state.shadowsArray,
            o = s.state.version,
            a = tt.getParameters(t, s.state, r, e, i),
            l = tt.getProgramCacheKey(a);
        let h = n.programs;
        n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = X.get(t.envMap || n.environment), void 0 === h && (t.addEventListener("dispose", vt), h = new Map, n.programs = h);
        let c = h.get(l);
        if (void 0 !== c) {
            if (n.currentProgram === c && n.lightsStateVersion === o) return Pt(t, a), c
        } else a.uniforms = tt.getUniforms(t), t.onBuild(a, y), t.onBeforeCompile(a, y), c = tt.acquireProgram(a, l), h.set(l, c), n.uniforms = a.uniforms;
        const d = n.uniforms;
        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (d.clippingPlanes = st.uniform), Pt(t, a), n.needsLights = function(t) {
            return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
        }(t), n.lightsStateVersion = o, n.needsLights && (d.ambientLightColor.value = s.state.ambient, d.lightProbe.value = s.state.probe, d.directionalLights.value = s.state.directional, d.directionalLightShadows.value = s.state.directionalShadow, d.spotLights.value = s.state.spot, d.spotLightShadows.value = s.state.spotShadow, d.rectAreaLights.value = s.state.rectArea, d.ltc_1.value = s.state.rectAreaLTC1, d.ltc_2.value = s.state.rectAreaLTC2, d.pointLights.value = s.state.point, d.pointLightShadows.value = s.state.pointShadow, d.hemisphereLights.value = s.state.hemi, d.directionalShadowMap.value = s.state.directionalShadowMap, d.directionalShadowMatrix.value = s.state.directionalShadowMatrix, d.spotShadowMap.value = s.state.spotShadowMap, d.spotShadowMatrix.value = s.state.spotShadowMatrix, d.pointShadowMap.value = s.state.pointShadowMap, d.pointShadowMatrix.value = s.state.pointShadowMatrix);
        const u = c.getUniforms(),
            m = dn.seqWithValue(u.seq, d);
        return n.currentProgram = c, n.uniformsList = m, c
    }

    function Pt(t, e) {
        const i = Y.get(t);
        i.outputEncoding = e.outputEncoding, i.instancing = e.instancing, i.numClippingPlanes = e.numClippingPlanes, i.numIntersection = e.numClipIntersection, i.vertexAlphas = e.vertexAlphas
    }

    function Tt(t, e, i, n) {
        !0 !== e.isScene && (e = z), J.resetTextureUnits();
        const s = e.fog,
            r = i.isMeshStandardMaterial ? e.environment : null,
            o = null === S ? y.outputEncoding : S.texture.encoding,
            a = X.get(i.envMap || r),
            l = !0 === i.vertexColors && n.geometry && n.geometry.attributes.color && 4 === n.geometry.attributes.color.itemSize,
            h = Y.get(i),
            c = p.state.lights;
        if (!0 === N && (!0 === B || t !== C)) {
            const e = t === C && i.id === M;
            st.setState(i, t, e)
        }
        let d = !1;
        i.version === h.__version ? h.needsLights && h.lightsStateVersion !== c.state.version || h.outputEncoding !== o || n.isInstancedMesh && !1 === h.instancing ? d = !0 : n.isInstancedMesh || !0 !== h.instancing ? h.envMap !== a || i.fog && h.fog !== s ? d = !0 : void 0 === h.numClippingPlanes || h.numClippingPlanes === st.numPlanes && h.numIntersection === st.numIntersection ? h.vertexAlphas !== l && (d = !0) : d = !0 : d = !0 : (d = !0, h.__version = i.version);
        let u = h.currentProgram;
        !0 === d && (u = Et(i, e, n));
        let m = !1,
            g = !1,
            f = !1;
        const v = u.getUniforms(),
            w = h.uniforms;
        if (q.useProgram(u.program) && (m = !0, g = !0, f = !0), i.id !== M && (M = i.id, g = !0), m || C !== t) {
            if (v.setValue(ut, "projectionMatrix", t.projectionMatrix), W.logarithmicDepthBuffer && v.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), C !== t && (C = t, g = !0, f = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                const e = v.map.cameraPosition;
                void 0 !== e && e.setValue(ut, U.setFromMatrixPosition(t.matrixWorld))
            }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && v.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && v.setValue(ut, "viewMatrix", t.matrixWorldInverse)
        }
        if (i.skinning) {
            v.setOptional(ut, n, "bindMatrix"), v.setOptional(ut, n, "bindMatrixInverse");
            const t = n.skeleton;
            if (t) {
                const e = t.bones;
                if (W.floatVertexTextures) {
                    if (null === t.boneTexture) {
                        let i = Math.sqrt(4 * e.length);
                        b = i, i = Math.pow(2, Math.ceil(Math.log(b) / Math.LN2)), i = Math.max(i, 4);
                        const n = new Float32Array(i * i * 4);
                        n.set(t.boneMatrices);
                        const s = new Ne(n, i, i, 1023, 1015);
                        t.boneMatrices = n, t.boneTexture = s, t.boneTextureSize = i
                    }
                    v.setValue(ut, "boneTexture", t.boneTexture, J), v.setValue(ut, "boneTextureSize", t.boneTextureSize)
                } else v.setOptional(ut, t, "boneMatrices")
            }
        }
        var b;
        return (g || h.receiveShadow !== n.receiveShadow) && (h.receiveShadow = n.receiveShadow, v.setValue(ut, "receiveShadow", n.receiveShadow)), g && (v.setValue(ut, "toneMappingExposure", y.toneMappingExposure), h.needsLights && function(t, e) {
            t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.directionalLightShadows.needsUpdate = e, t.pointLights.needsUpdate = e, t.pointLightShadows.needsUpdate = e, t.spotLights.needsUpdate = e, t.spotLightShadows.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
        }(w, f), s && i.fog && et.refreshFogUniforms(w, s), et.refreshMaterialUniforms(w, i, L, A), dn.upload(ut, h.uniformsList, w, J)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (dn.upload(ut, h.uniformsList, w, J), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && v.setValue(ut, "center", n.center), v.setValue(ut, "modelViewMatrix", n.modelViewMatrix), v.setValue(ut, "normalMatrix", n.normalMatrix), v.setValue(ut, "modelMatrix", n.matrixWorld), u
    }
    St.setAnimationLoop((function(t) {
        wt && wt(t)
    })), "undefined" != typeof window && St.setContext(window), this.setAnimationLoop = function(t) {
        wt = t, gt.setAnimationLoop(t), null === t ? St.stop() : St.start()
    }, gt.addEventListener("sessionstart", bt), gt.addEventListener("sessionend", xt), this.render = function(t, e) {
        let i, n;
        if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (!0 === v) return;
        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === gt.enabled && !0 === gt.isPresenting && (e = gt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(y, t, e, i || S), p = nt.get(t, g.length), p.init(), g.push(p), V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), F.setFromProjectionMatrix(V), B = this.localClippingEnabled, N = st.init(this.clippingPlanes, B, e), u = it.get(t, m.length), u.init(), m.push(u), Mt(t, e, 0, y.sortObjects), u.finish(), !0 === y.sortObjects && u.sort(k, I), !0 === N && st.beginShadows();
        const s = p.state.shadowsArray;
        rt.render(s, t, e), p.setupLights(), p.setupLightsView(e), !0 === N && st.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), ot.render(u, t, e, n);
        const r = u.opaque,
            o = u.transparent;
        r.length > 0 && Ct(r, t, e), o.length > 0 && Ct(o, t, e), null !== S && (J.updateRenderTargetMipmap(S), J.updateMultisampleRenderTarget(S)), !0 === t.isScene && t.onAfterRender(y, t, e), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1), dt.resetDefaultState(), M = -1, C = null, g.pop(), p = g.length > 0 ? g[g.length - 1] : null, m.pop(), u = m.length > 0 ? m[m.length - 1] : null
    }, this.getActiveCubeFace = function() {
        return b
    }, this.getActiveMipmapLevel = function() {
        return x
    }, this.getRenderTarget = function() {
        return S
    }, this.setRenderTarget = function(t, e = 0, i = 0) {
        S = t, b = e, x = i, t && void 0 === Y.get(t).__webglFramebuffer && J.setupRenderTarget(t);
        let n = null,
            s = !1,
            r = !1;
        if (t) {
            const i = t.texture;
            (i.isDataTexture3D || i.isDataTexture2DArray) && (r = !0);
            const o = Y.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget ? (n = o[e], s = !0) : n = t.isWebGLMultisampleRenderTarget ? Y.get(t).__webglMultisampledFramebuffer : o, _.copy(t.viewport), E.copy(t.scissor), P = t.scissorTest
        } else _.copy(R).multiplyScalar(L).floor(), E.copy(D).multiplyScalar(L).floor(), P = O;
        if (q.bindFramebuffer(36160, n), q.viewport(_), q.scissor(E), q.setScissorTest(P), s) {
            const n = Y.get(t.texture);
            ut.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i)
        } else if (r) {
            const n = Y.get(t.texture),
                s = e || 0;
            ut.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, s)
        }
    }, this.readRenderTargetPixels = function(t, e, i, n, s, r, o) {
        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let a = Y.get(t).__webglFramebuffer;
        if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
            q.bindFramebuffer(36160, a);
            try {
                const o = t.texture,
                    a = o.format,
                    l = o.type;
                if (1023 !== a && ct.convert(a) !== ut.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                const h = 1016 === l && (G.has("EXT_color_buffer_half_float") || W.isWebGL2 && G.has("EXT_color_buffer_float"));
                if (!(1009 === l || ct.convert(l) === ut.getParameter(35738) || 1015 === l && (W.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                36053 === ut.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - s && ut.readPixels(e, i, n, s, ct.convert(a), ct.convert(l), r) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
            } finally {
                const t = null !== S ? Y.get(S).__webglFramebuffer : null;
                q.bindFramebuffer(36160, t)
            }
        }
    }, this.copyFramebufferToTexture = function(t, e, i = 0) {
        const n = Math.pow(2, -i),
            s = Math.floor(e.image.width * n),
            r = Math.floor(e.image.height * n),
            o = ct.convert(e.format);
        J.setTexture2D(e, 0), ut.copyTexImage2D(3553, i, o, t.x, t.y, s, r, 0), q.unbindTexture()
    }, this.copyTextureToTexture = function(t, e, i, n = 0) {
        const s = e.image.width,
            r = e.image.height,
            o = ct.convert(i.format),
            a = ct.convert(i.type);
        J.setTexture2D(i, 0), ut.pixelStorei(37440, i.flipY), ut.pixelStorei(37441, i.premultiplyAlpha), ut.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? ut.texSubImage2D(3553, n, t.x, t.y, s, r, o, a, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ut.texSubImage2D(3553, n, t.x, t.y, o, a, e.image), 0 === n && i.generateMipmaps && ut.generateMipmap(3553), q.unbindTexture()
    }, this.copyTextureToTexture3D = function(t, e, i, n, s = 0) {
        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const {
            width: r,
            height: o,
            data: a
        } = i.image, l = ct.convert(n.format), h = ct.convert(n.type);
        let c;
        if (n.isDataTexture3D) J.setTexture3D(n, 0), c = 32879;
        else {
            if (!n.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            J.setTexture2DArray(n, 0), c = 35866
        }
        ut.pixelStorei(37440, n.flipY), ut.pixelStorei(37441, n.premultiplyAlpha), ut.pixelStorei(3317, n.unpackAlignment);
        const d = ut.getParameter(3314),
            u = ut.getParameter(32878),
            p = ut.getParameter(3316),
            m = ut.getParameter(3315),
            g = ut.getParameter(32877);
        ut.pixelStorei(3314, r), ut.pixelStorei(32878, o), ut.pixelStorei(3316, t.min.x), ut.pixelStorei(3315, t.min.y), ut.pixelStorei(32877, t.min.z), ut.texSubImage3D(c, s, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, h, a), ut.pixelStorei(3314, d), ut.pixelStorei(32878, u), ut.pixelStorei(3316, p), ut.pixelStorei(3315, m), ut.pixelStorei(32877, g), 0 === s && n.generateMipmaps && ut.generateMipmap(c), q.unbindTexture()
    }, this.initTexture = function(t) {
        J.setTexture2D(t, 0), q.unbindTexture()
    }, this.resetState = function() {
        b = 0, x = 0, S = null, q.reset(), dt.reset()
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
    }))
}(class extends is {}).prototype.isWebGL1Renderer = !0;
class ns extends xt {
    constructor() {
        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(t, e) {
        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
    }
}
ns.prototype.isScene = !0;
class ss {
    constructor(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = s(), this.onUploadCallback = function() {}
    }
    set needsUpdate(t) {
        !0 === t && this.version++
    }
    setUsage(t) {
        return this.usage = t, this
    }
    copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
    }
    copyAt(t, e, i) {
        t *= this.stride, i *= e.stride;
        for (let n = 0, s = this.stride; n < s; n++) this.array[t + n] = e.array[i + n];
        return this
    }
    set(t, e = 0) {
        return this.array.set(t, e), this
    }
    clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = s()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
            i = new ss(e, this.stride);
        return i.setUsage(this.usage), i
    }
    onUpload(t) {
        return this.onUploadCallback = t, this
    }
    toJSON(t) {
        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = s()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
ss.prototype.isInterleavedBuffer = !0;
const rs = new w;
class os {
    constructor(t, e, i, n) {
        this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(t) {
        this.data.needsUpdate = t
    }
    applyMatrix4(t) {
        for (let e = 0, i = this.data.count; e < i; e++) rs.x = this.getX(e), rs.y = this.getY(e), rs.z = this.getZ(e), rs.applyMatrix4(t), this.setXYZ(e, rs.x, rs.y, rs.z);
        return this
    }
    applyNormalMatrix(t) {
        for (let e = 0, i = this.count; e < i; e++) rs.x = this.getX(e), rs.y = this.getY(e), rs.z = this.getZ(e), rs.applyNormalMatrix(t), this.setXYZ(e, rs.x, rs.y, rs.z);
        return this
    }
    transformDirection(t) {
        for (let e = 0, i = this.count; e < i; e++) rs.x = this.getX(e), rs.y = this.getY(e), rs.z = this.getZ(e), rs.transformDirection(t), this.setXYZ(e, rs.x, rs.y, rs.z);
        return this
    }
    setX(t, e) {
        return this.data.array[t * this.data.stride + this.offset] = e, this
    }
    setY(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 1] = e, this
    }
    setZ(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 2] = e, this
    }
    setW(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 3] = e, this
    }
    getX(t) {
        return this.data.array[t * this.data.stride + this.offset]
    }
    getY(t) {
        return this.data.array[t * this.data.stride + this.offset + 1]
    }
    getZ(t) {
        return this.data.array[t * this.data.stride + this.offset + 2]
    }
    getW(t) {
        return this.data.array[t * this.data.stride + this.offset + 3]
    }
    setXY(t, e, i) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
    }
    setXYZ(t, e, i, n) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
    }
    setXYZW(t, e, i, n, s) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = s, this
    }
    clone(t) {
        if (void 0 === t) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const t = [];
            for (let e = 0; e < this.count; e++) {
                const i = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
            }
            return new Xt(new this.array.constructor(t), this.itemSize, this.normalized)
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new os(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(t) {
        if (void 0 === t) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const t = [];
            for (let e = 0; e < this.count; e++) {
                const i = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
os.prototype.isInterleavedBufferAttribute = !0;
class as extends Bt {
    constructor(t) {
        super(), this.type = "SpriteMaterial", this.color = new qt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
    }
}
let ls;
as.prototype.isSpriteMaterial = !0;
const hs = new w,
    cs = new w,
    ds = new w,
    us = new h,
    ps = new h,
    ms = new $,
    gs = new w,
    fs = new w,
    ys = new w,
    vs = new h,
    ws = new h,
    bs = new h;

function xs(t, e, i, n, s, r) {
    us.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== s ? (ps.x = r * us.x - s * us.y, ps.y = s * us.x + r * us.y) : ps.copy(us), t.copy(e), t.x += ps.x, t.y += ps.y, t.applyMatrix4(ms)
}(class extends xt {
    constructor(t) {
        if (super(), this.type = "Sprite", void 0 === ls) {
            ls = new ae;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                e = new ss(t, 5);
            ls.setIndex([0, 1, 2, 0, 2, 3]), ls.setAttribute("position", new os(e, 3, 0, !1)), ls.setAttribute("uv", new os(e, 2, 3, !1))
        }
        this.geometry = ls, this.material = void 0 !== t ? t : new as, this.center = new h(.5, .5)
    }
    raycast(t, e) {
        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), cs.setFromMatrixScale(this.matrixWorld), ms.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ds.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && cs.multiplyScalar(-ds.z);
        const i = this.material.rotation;
        let n, s;
        0 !== i && (s = Math.cos(i), n = Math.sin(i));
        const r = this.center;
        xs(gs.set(-.5, -.5, 0), ds, r, cs, n, s), xs(fs.set(.5, -.5, 0), ds, r, cs, n, s), xs(ys.set(.5, .5, 0), ds, r, cs, n, s), vs.set(0, 0), ws.set(1, 0), bs.set(1, 1);
        let o = t.ray.intersectTriangle(gs, fs, ys, !1, hs);
        if (null === o && (xs(fs.set(-.5, .5, 0), ds, r, cs, n, s), ws.set(0, 1), o = t.ray.intersectTriangle(gs, ys, fs, !1, hs), null === o)) return;
        const a = t.ray.origin.distanceTo(hs);
        a < t.near || a > t.far || e.push({
            distance: a,
            point: hs.clone(),
            uv: Ft.getUV(hs, gs, fs, ys, vs, ws, bs, new h),
            face: null,
            object: this
        })
    }
    copy(t) {
        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
    }
}).prototype.isSprite = !0;
const Ss = new w,
    Ms = new f,
    Cs = new f,
    _s = new w,
    Es = new $;
class Ps extends _e {
    constructor(t, e) {
        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new $, this.bindMatrixInverse = new $
    }
    copy(t) {
        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
    }
    bind(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const t = new f,
            e = this.geometry.attributes.skinWeight;
        for (let i = 0, n = e.count; i < n; i++) {
            t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
            const n = 1 / t.manhattanLength();
            n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
        }
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(t, e) {
        const i = this.skeleton,
            n = this.geometry;
        Ms.fromBufferAttribute(n.attributes.skinIndex, t), Cs.fromBufferAttribute(n.attributes.skinWeight, t), Ss.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
        for (let t = 0; t < 4; t++) {
            const n = Cs.getComponent(t);
            if (0 !== n) {
                const s = Ms.getComponent(t);
                Es.multiplyMatrices(i.bones[s].matrixWorld, i.boneInverses[s]), e.addScaledVector(_s.copy(Ss).applyMatrix4(Es), n)
            }
        }
        return e.applyMatrix4(this.bindMatrixInverse)
    }
}
Ps.prototype.isSkinnedMesh = !0;
(class extends xt {
    constructor() {
        super(), this.type = "Bone"
    }
}).prototype.isBone = !0;
const Ts = new $,
    As = new $,
    Ls = [],
    ks = new _e;
(class extends _e {
    constructor(t, e, i) {
        super(t, e), this.instanceMatrix = new Xt(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1
    }
    copy(t) {
        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
    }
    getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, 3 * t)
    }
    getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t)
    }
    raycast(t, e) {
        const i = this.matrixWorld,
            n = this.count;
        if (ks.geometry = this.geometry, ks.material = this.material, void 0 !== ks.material)
            for (let s = 0; s < n; s++) {
                this.getMatrixAt(s, Ts), As.multiplyMatrices(i, Ts), ks.matrixWorld = As, ks.raycast(t, Ls);
                for (let t = 0, i = Ls.length; t < i; t++) {
                    const i = Ls[t];
                    i.instanceId = s, i.object = this, e.push(i)
                }
                Ls.length = 0
            }
    }
    setColorAt(t, e) {
        null === this.instanceColor && (this.instanceColor = new Xt(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
    }
    setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}).prototype.isInstancedMesh = !0;
class Is extends Bt {
    constructor(t) {
        super(), this.type = "LineBasicMaterial", this.color = new qt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
    }
}
Is.prototype.isLineBasicMaterial = !0;
const Rs = new w,
    Ds = new w,
    Os = new $,
    Fs = new X,
    Ns = new z;
class Bs extends xt {
    constructor(t = new ae, e = new Is) {
        super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
    }
    copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
    }
    computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry)
            if (null === t.index) {
                const e = t.attributes.position,
                    i = [0];
                for (let t = 1, n = e.count; t < n; t++) Rs.fromBufferAttribute(e, t - 1), Ds.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += Rs.distanceTo(Ds);
                t.setAttribute("lineDistance", new Kt(i, 1))
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
    }
    raycast(t, e) {
        const i = this.geometry,
            n = this.matrixWorld,
            s = t.params.Line.threshold,
            r = i.drawRange;
        if (null === i.boundingSphere && i.computeBoundingSphere(), Ns.copy(i.boundingSphere), Ns.applyMatrix4(n), Ns.radius += s, !1 === t.ray.intersectsSphere(Ns)) return;
        Os.copy(n).invert(), Fs.copy(t.ray).applyMatrix4(Os);
        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            l = new w,
            h = new w,
            c = new w,
            d = new w,
            u = this.isLineSegments ? 2 : 1;
        if (i.isBufferGeometry) {
            const n = i.index,
                s = i.attributes.position;
            if (null !== n) {
                for (let i = Math.max(0, r.start), o = Math.min(n.count, r.start + r.count) - 1; i < o; i += u) {
                    const r = n.getX(i),
                        o = n.getX(i + 1);
                    l.fromBufferAttribute(s, r), h.fromBufferAttribute(s, o);
                    if (Fs.distanceSqToSegment(l, h, d, c) > a) continue;
                    d.applyMatrix4(this.matrixWorld);
                    const u = t.ray.origin.distanceTo(d);
                    u < t.near || u > t.far || e.push({
                        distance: u,
                        point: c.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            } else {
                for (let i = Math.max(0, r.start), n = Math.min(s.count, r.start + r.count) - 1; i < n; i += u) {
                    l.fromBufferAttribute(s, i), h.fromBufferAttribute(s, i + 1);
                    if (Fs.distanceSqToSegment(l, h, d, c) > a) continue;
                    d.applyMatrix4(this.matrixWorld);
                    const n = t.ray.origin.distanceTo(d);
                    n < t.near || n > t.far || e.push({
                        distance: n,
                        point: c.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
    updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            const e = t.morphAttributes,
                i = Object.keys(e);
            if (i.length > 0) {
                const t = e[i[0]];
                if (void 0 !== t) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e].name || String(e);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                    }
                }
            }
        } else {
            const e = t.morphTargets;
            void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
}
Bs.prototype.isLine = !0;
const Vs = new w,
    Us = new w;
class zs extends Bs {
    constructor(t, e) {
        super(t, e), this.type = "LineSegments"
    }
    computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry)
            if (null === t.index) {
                const e = t.attributes.position,
                    i = [];
                for (let t = 0, n = e.count; t < n; t += 2) Vs.fromBufferAttribute(e, t), Us.fromBufferAttribute(e, t + 1), i[t] = 0 === t ? 0 : i[t - 1], i[t + 1] = i[t] + Vs.distanceTo(Us);
                t.setAttribute("lineDistance", new Kt(i, 1))
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
    }
}
zs.prototype.isLineSegments = !0;
(class extends Bs {
    constructor(t, e) {
        super(t, e), this.type = "LineLoop"
    }
}).prototype.isLineLoop = !0;
class Hs extends Bt {
    constructor(t) {
        super(), this.type = "PointsMaterial", this.color = new qt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
    }
}
Hs.prototype.isPointsMaterial = !0;
const Gs = new $,
    Ws = new X,
    qs = new z,
    js = new w;

function Ys(t, e, i, n, s, r, o) {
    const a = Ws.distanceSqToPoint(t);
    if (a < i) {
        const i = new w;
        Ws.closestPointToPoint(t, i), i.applyMatrix4(n);
        const l = s.ray.origin.distanceTo(i);
        if (l < s.near || l > s.far) return;
        r.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: i,
            index: e,
            face: null,
            object: o
        })
    }
}(class extends xt {
    constructor(t = new ae, e = new Hs) {
        super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
    }
    copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
    }
    raycast(t, e) {
        const i = this.geometry,
            n = this.matrixWorld,
            s = t.params.Points.threshold,
            r = i.drawRange;
        if (null === i.boundingSphere && i.computeBoundingSphere(), qs.copy(i.boundingSphere), qs.applyMatrix4(n), qs.radius += s, !1 === t.ray.intersectsSphere(qs)) return;
        Gs.copy(n).invert(), Ws.copy(t.ray).applyMatrix4(Gs);
        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o;
        if (i.isBufferGeometry) {
            const s = i.index,
                o = i.attributes.position;
            if (null !== s) {
                for (let i = Math.max(0, r.start), l = Math.min(s.count, r.start + r.count); i < l; i++) {
                    const r = s.getX(i);
                    js.fromBufferAttribute(o, r), Ys(js, r, a, n, t, e, this)
                }
            } else {
                for (let i = Math.max(0, r.start), s = Math.min(o.count, r.start + r.count); i < s; i++) js.fromBufferAttribute(o, i), Ys(js, i, a, n, t, e, this)
            }
        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
    updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            const e = t.morphAttributes,
                i = Object.keys(e);
            if (i.length > 0) {
                const t = e[i[0]];
                if (void 0 !== t) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e].name || String(e);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                    }
                }
            }
        } else {
            const e = t.morphTargets;
            void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
}).prototype.isPoints = !0;
(class extends m {
    constructor(t, e, i, n, s, r, o, a, l) {
        super(t, e, i, n, s, r, o, a, l), this.format = void 0 !== o ? o : 1022, this.minFilter = void 0 !== r ? r : 1006, this.magFilter = void 0 !== s ? s : 1006, this.generateMipmaps = !1;
        const h = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
            h.needsUpdate = !0, t.requestVideoFrameCallback(e)
        }))
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const t = this.image;
        !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}).prototype.isVideoTexture = !0;
(class extends m {
    constructor(t, e, i, n, s, r, o, a, l, h, c, d) {
        super(null, r, o, a, l, h, n, s, c, d), this.image = {
            width: e,
            height: i
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }
}).prototype.isCompressedTexture = !0;
(class extends m {
    constructor(t, e, i, n, s, r, o, a, l) {
        super(t, e, i, n, s, r, o, a, l), this.needsUpdate = !0
    }
}).prototype.isCanvasTexture = !0;
(class extends m {
    constructor(t, e, i, n, s, r, o, a, l, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), super(null, n, s, r, o, a, h, i, l), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== o ? o : 1003, this.minFilter = void 0 !== a ? a : 1003, this.flipY = !1, this.generateMipmaps = !1
    }
}).prototype.isDepthTexture = !0;
class Js extends ae {
    constructor(t, e, i = 1, n = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        };
        const s = [],
            r = [];

        function o(t, e, i, n) {
            const s = n + 1,
                r = [];
            for (let n = 0; n <= s; n++) {
                r[n] = [];
                const o = t.clone().lerp(i, n / s),
                    a = e.clone().lerp(i, n / s),
                    l = s - n;
                for (let t = 0; t <= l; t++) r[n][t] = 0 === t && n === s ? o : o.clone().lerp(a, t / l)
            }
            for (let t = 0; t < s; t++)
                for (let e = 0; e < 2 * (s - t) - 1; e++) {
                    const i = Math.floor(e / 2);
                    e % 2 == 0 ? (a(r[t][i + 1]), a(r[t + 1][i]), a(r[t][i])) : (a(r[t][i + 1]), a(r[t + 1][i + 1]), a(r[t + 1][i]))
                }
        }

        function a(t) {
            s.push(t.x, t.y, t.z)
        }

        function l(e, i) {
            const n = 3 * e;
            i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
        }

        function c(t, e, i, n) {
            n < 0 && 1 === t.x && (r[e] = t.x - 1), 0 === i.x && 0 === i.z && (r[e] = n / 2 / Math.PI + .5)
        }

        function d(t) {
            return Math.atan2(t.z, -t.x)
        }! function(t) {
            const i = new w,
                n = new w,
                s = new w;
            for (let r = 0; r < e.length; r += 3) l(e[r + 0], i), l(e[r + 1], n), l(e[r + 2], s), o(i, n, s, t)
        }(n),
            function(t) {
                const e = new w;
                for (let i = 0; i < s.length; i += 3) e.x = s[i + 0], e.y = s[i + 1], e.z = s[i + 2], e.normalize().multiplyScalar(t), s[i + 0] = e.x, s[i + 1] = e.y, s[i + 2] = e.z
            }(i),
            function() {
                const t = new w;
                for (let i = 0; i < s.length; i += 3) {
                    t.x = s[i + 0], t.y = s[i + 1], t.z = s[i + 2];
                    const n = d(t) / 2 / Math.PI + .5,
                        o = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                    r.push(n, 1 - o)
                }
                var e;
                (function() {
                    const t = new w,
                        e = new w,
                        i = new w,
                        n = new w,
                        o = new h,
                        a = new h,
                        l = new h;
                    for (let h = 0, u = 0; h < s.length; h += 9, u += 6) {
                        t.set(s[h + 0], s[h + 1], s[h + 2]), e.set(s[h + 3], s[h + 4], s[h + 5]), i.set(s[h + 6], s[h + 7], s[h + 8]), o.set(r[u + 0], r[u + 1]), a.set(r[u + 2], r[u + 3]), l.set(r[u + 4], r[u + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                        const p = d(n);
                        c(o, u + 0, t, p), c(a, u + 2, e, p), c(l, u + 4, i, p)
                    }
                })(),
                    function() {
                        for (let t = 0; t < r.length; t += 6) {
                            const e = r[t + 0],
                                i = r[t + 2],
                                n = r[t + 4],
                                s = Math.max(e, i, n),
                                o = Math.min(e, i, n);
                            s > .9 && o < .1 && (e < .2 && (r[t + 0] += 1), i < .2 && (r[t + 2] += 1), n < .2 && (r[t + 4] += 1))
                        }
                    }()
            }(), this.setAttribute("position", new Kt(s, 3)), this.setAttribute("normal", new Kt(s.slice(), 3)), this.setAttribute("uv", new Kt(r, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }
}
new w, new w, new w, new Ft;
const Xs = function(t, e, i) {
    i = i || 2;
    const n = e && e.length,
        s = n ? e[0] * i : t.length;
    let r = $s(t, 0, s, i, !0);
    const o = [];
    if (!r || r.next === r.prev) return o;
    let a, l, h, c, d, u, p;
    if (n && (r = function(t, e, i, n) {
        const s = [];
        let r, o, a, l, h;
        for (r = 0, o = e.length; r < o; r++) a = e[r] * n, l = r < o - 1 ? e[r + 1] * n : t.length, h = $s(t, a, l, n, !1), h === h.next && (h.steiner = !0), s.push(ar(h));
        for (s.sort(nr), r = 0; r < s.length; r++) sr(s[r], i), i = Zs(i, i.next);
        return i
    }(t, e, r, i)), t.length > 80 * i) {
        a = h = t[0], l = c = t[1];
        for (let e = i; e < s; e += i) d = t[e], u = t[e + 1], d < a && (a = d), u < l && (l = u), d > h && (h = d), u > c && (c = u);
        p = Math.max(h - a, c - l), p = 0 !== p ? 1 / p : 0
    }
    return Ks(r, o, i, a, l, p), o
};

function $s(t, e, i, n, s) {
    let r, o;
    if (s === function(t, e, i, n) {
        let s = 0;
        for (let r = e, o = i - n; r < i; r += n) s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
        return s
    }(t, e, i, n) > 0)
        for (r = e; r < i; r += n) o = yr(r, t[r], t[r + 1], o);
    else
        for (r = i - n; r >= e; r -= n) o = yr(r, t[r], t[r + 1], o);
    return o && dr(o, o.next) && (vr(o), o = o.next), o
}

function Zs(t, e) {
    if (!t) return t;
    e || (e = t);
    let i, n = t;
    do {
        if (i = !1, n.steiner || !dr(n, n.next) && 0 !== cr(n.prev, n, n.next)) n = n.next;
        else {
            if (vr(n), n = e = n.prev, n === n.next) break;
            i = !0
        }
    } while (i || n !== e);
    return e
}

function Ks(t, e, i, n, s, r, o) {
    if (!t) return;
    !o && r && function(t, e, i, n) {
        let s = t;
        do {
            null === s.z && (s.z = or(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next
        } while (s !== t);
        s.prevZ.nextZ = null, s.prevZ = null,
            function(t) {
                let e, i, n, s, r, o, a, l, h = 1;
                do {
                    for (i = t, t = null, r = null, o = 0; i;) {
                        for (o++, n = i, a = 0, e = 0; e < h && (a++, n = n.nextZ, n); e++);
                        for (l = h; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || i.z <= n.z) ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, l--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s;
                        i = n
                    }
                    r.nextZ = null, h *= 2
                } while (o > 1)
            }(s)
    }(t, n, s, r);
    let a, l, h = t;
    for (; t.prev !== t.next;)
        if (a = t.prev, l = t.next, r ? tr(t, n, s, r) : Qs(t)) e.push(a.i / i), e.push(t.i / i), e.push(l.i / i), vr(t), t = l.next, h = l.next;
        else if ((t = l) === h) {
            o ? 1 === o ? Ks(t = er(Zs(t), e, i), e, i, n, s, r, 2) : 2 === o && ir(t, e, i, n, s, r) : Ks(Zs(t), e, i, n, s, r, 1);
            break
        }
}

function Qs(t) {
    const e = t.prev,
        i = t,
        n = t.next;
    if (cr(e, i, n) >= 0) return !1;
    let s = t.next.next;
    for (; s !== t.prev;) {
        if (lr(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && cr(s.prev, s, s.next) >= 0) return !1;
        s = s.next
    }
    return !0
}

function tr(t, e, i, n) {
    const s = t.prev,
        r = t,
        o = t.next;
    if (cr(s, r, o) >= 0) return !1;
    const a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x,
        l = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y,
        h = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x,
        c = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y,
        d = or(a, l, e, i, n),
        u = or(h, c, e, i, n);
    let p = t.prevZ,
        m = t.nextZ;
    for (; p && p.z >= d && m && m.z <= u;) {
        if (p !== t.prev && p !== t.next && lr(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && cr(p.prev, p, p.next) >= 0) return !1;
        if (p = p.prevZ, m !== t.prev && m !== t.next && lr(s.x, s.y, r.x, r.y, o.x, o.y, m.x, m.y) && cr(m.prev, m, m.next) >= 0) return !1;
        m = m.nextZ
    }
    for (; p && p.z >= d;) {
        if (p !== t.prev && p !== t.next && lr(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && cr(p.prev, p, p.next) >= 0) return !1;
        p = p.prevZ
    }
    for (; m && m.z <= u;) {
        if (m !== t.prev && m !== t.next && lr(s.x, s.y, r.x, r.y, o.x, o.y, m.x, m.y) && cr(m.prev, m, m.next) >= 0) return !1;
        m = m.nextZ
    }
    return !0
}

function er(t, e, i) {
    let n = t;
    do {
        const s = n.prev,
            r = n.next.next;
        !dr(s, r) && ur(s, n, n.next, r) && gr(s, r) && gr(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), vr(n), vr(n.next), n = t = r), n = n.next
    } while (n !== t);
    return Zs(n)
}

function ir(t, e, i, n, s, r) {
    let o = t;
    do {
        let t = o.next.next;
        for (; t !== o.prev;) {
            if (o.i !== t.i && hr(o, t)) {
                let a = fr(o, t);
                return o = Zs(o, o.next), a = Zs(a, a.next), Ks(o, e, i, n, s, r), void Ks(a, e, i, n, s, r)
            }
            t = t.next
        }
        o = o.next
    } while (o !== t)
}

function nr(t, e) {
    return t.x - e.x
}

function sr(t, e) {
    if (e = function(t, e) {
        let i = e;
        const n = t.x,
            s = t.y;
        let r, o = -1 / 0;
        do {
            if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                const t = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                if (t <= n && t > o) {
                    if (o = t, t === n) {
                        if (s === i.y) return i;
                        if (s === i.next.y) return i.next
                    }
                    r = i.x < i.next.x ? i : i.next
                }
            }
            i = i.next
        } while (i !== e);
        if (!r) return null;
        if (n === o) return r;
        const a = r,
            l = r.x,
            h = r.y;
        let c, d = 1 / 0;
        i = r;
        do {
            n >= i.x && i.x >= l && n !== i.x && lr(s < h ? n : o, s, l, h, s < h ? o : n, s, i.x, i.y) && (c = Math.abs(s - i.y) / (n - i.x), gr(i, t) && (c < d || c === d && (i.x > r.x || i.x === r.x && rr(r, i))) && (r = i, d = c)), i = i.next
        } while (i !== a);
        return r
    }(t, e)) {
        const i = fr(e, t);
        Zs(e, e.next), Zs(i, i.next)
    }
}

function rr(t, e) {
    return cr(t.prev, t, e.prev) < 0 && cr(e.next, t, t.next) < 0
}

function or(t, e, i, n, s) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
}

function ar(t) {
    let e = t,
        i = t;
    do {
        (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next
    } while (e !== t);
    return i
}

function lr(t, e, i, n, s, r, o, a) {
    return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0
}

function hr(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
        let i = t;
        do {
            if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && ur(i, i.next, t, e)) return !0;
            i = i.next
        } while (i !== t);
        return !1
    }(t, e) && (gr(t, e) && gr(e, t) && function(t, e) {
        let i = t,
            n = !1;
        const s = (t.x + e.x) / 2,
            r = (t.y + e.y) / 2;
        do {
            i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
        } while (i !== t);
        return n
    }(t, e) && (cr(t.prev, t, e.prev) || cr(t, e.prev, e)) || dr(t, e) && cr(t.prev, t, t.next) > 0 && cr(e.prev, e, e.next) > 0)
}

function cr(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
}

function dr(t, e) {
    return t.x === e.x && t.y === e.y
}

function ur(t, e, i, n) {
    const s = mr(cr(t, e, i)),
        r = mr(cr(t, e, n)),
        o = mr(cr(i, n, t)),
        a = mr(cr(i, n, e));
    return s !== r && o !== a || (!(0 !== s || !pr(t, i, e)) || (!(0 !== r || !pr(t, n, e)) || (!(0 !== o || !pr(i, t, n)) || !(0 !== a || !pr(i, e, n)))))
}

function pr(t, e, i) {
    return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
}

function mr(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}

function gr(t, e) {
    return cr(t.prev, t, t.next) < 0 ? cr(t, e, t.next) >= 0 && cr(t, t.prev, e) >= 0 : cr(t, e, t.prev) < 0 || cr(t, t.next, e) < 0
}

function fr(t, e) {
    const i = new wr(t.i, t.x, t.y),
        n = new wr(e.i, e.x, e.y),
        s = t.next,
        r = e.prev;
    return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, r.next = n, n.prev = r, n
}

function yr(t, e, i, n) {
    const s = new wr(t, e, i);
    return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s
}

function vr(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
}

function wr(t, e, i) {
    this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
}
class br {
    static area(t) {
        const e = t.length;
        let i = 0;
        for (let n = e - 1, s = 0; s < e; n = s++) i += t[n].x * t[s].y - t[s].x * t[n].y;
        return .5 * i
    }
    static isClockWise(t) {
        return br.area(t) < 0
    }
    static triangulateShape(t, e) {
        const i = [],
            n = [],
            s = [];
        xr(t), Sr(i, t);
        let r = t.length;
        e.forEach(xr);
        for (let t = 0; t < e.length; t++) n.push(r), r += e[t].length, Sr(i, e[t]);
        const o = Xs(i, n);
        for (let t = 0; t < o.length; t += 3) s.push(o.slice(t, t + 3));
        return s
    }
}

function xr(t) {
    const e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop()
}

function Sr(t, e) {
    for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
}
class Mr extends ae {
    constructor(t, e) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, t = Array.isArray(t) ? t : [t];
        const i = this,
            n = [],
            s = [];
        for (let e = 0, i = t.length; e < i; e++) {
            r(t[e])
        }

        function r(t) {
            const r = [],
                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                a = void 0 !== e.steps ? e.steps : 1;
            let l = void 0 !== e.depth ? e.depth : 100,
                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                d = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                u = void 0 !== e.bevelSize ? e.bevelSize : d - 2,
                p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                m = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
            const g = e.extrudePath,
                f = void 0 !== e.UVGenerator ? e.UVGenerator : Cr;
            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
            let y, v, b, x, S, M = !1;
            g && (y = g.getSpacedPoints(a), M = !0, c = !1, v = g.computeFrenetFrames(a, !1), b = new w, x = new w, S = new w), c || (m = 0, d = 0, u = 0, p = 0);
            const C = t.extractPoints(o);
            let _ = C.shape;
            const E = C.holes;
            if (!br.isClockWise(_)) {
                _ = _.reverse();
                for (let t = 0, e = E.length; t < e; t++) {
                    const e = E[t];
                    br.isClockWise(e) && (E[t] = e.reverse())
                }
            }
            const P = br.triangulateShape(_, E),
                T = _;
            for (let t = 0, e = E.length; t < e; t++) {
                const e = E[t];
                _ = _.concat(e)
            }

            function A(t, e, i) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
            }
            const L = _.length,
                k = P.length;

            function I(t, e, i) {
                let n, s, r;
                const o = t.x - e.x,
                    a = t.y - e.y,
                    l = i.x - t.x,
                    c = i.y - t.y,
                    d = o * o + a * a,
                    u = o * c - a * l;
                if (Math.abs(u) > Number.EPSILON) {
                    const u = Math.sqrt(d),
                        p = Math.sqrt(l * l + c * c),
                        m = e.x - a / u,
                        g = e.y + o / u,
                        f = ((i.x - c / p - m) * c - (i.y + l / p - g) * l) / (o * c - a * l);
                    n = m + o * f - t.x, s = g + a * f - t.y;
                    const y = n * n + s * s;
                    if (y <= 2) return new h(n, s);
                    r = Math.sqrt(y / 2)
                } else {
                    let t = !1;
                    o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (n = -a, s = o, r = Math.sqrt(d)) : (n = o, s = a, r = Math.sqrt(d / 2))
                }
                return new h(n / r, s / r)
            }
            const R = [];
            for (let t = 0, e = T.length, i = e - 1, n = t + 1; t < e; t++, i++, n++) i === e && (i = 0), n === e && (n = 0), R[t] = I(T[t], T[i], T[n]);
            const D = [];
            let O, F = R.concat();
            for (let t = 0, e = E.length; t < e; t++) {
                const e = E[t];
                O = [];
                for (let t = 0, i = e.length, n = i - 1, s = t + 1; t < i; t++, n++, s++) n === i && (n = 0), s === i && (s = 0), O[t] = I(e[t], e[n], e[s]);
                D.push(O), F = F.concat(O)
            }
            for (let t = 0; t < m; t++) {
                const e = t / m,
                    i = d * Math.cos(e * Math.PI / 2),
                    n = u * Math.sin(e * Math.PI / 2) + p;
                for (let t = 0, e = T.length; t < e; t++) {
                    const e = A(T[t], R[t], n);
                    V(e.x, e.y, -i)
                }
                for (let t = 0, e = E.length; t < e; t++) {
                    const e = E[t];
                    O = D[t];
                    for (let t = 0, s = e.length; t < s; t++) {
                        const s = A(e[t], O[t], n);
                        V(s.x, s.y, -i)
                    }
                }
            }
            const N = u + p;
            for (let t = 0; t < L; t++) {
                const e = c ? A(_[t], F[t], N) : _[t];
                M ? (x.copy(v.normals[0]).multiplyScalar(e.x), b.copy(v.binormals[0]).multiplyScalar(e.y), S.copy(y[0]).add(x).add(b), V(S.x, S.y, S.z)) : V(e.x, e.y, 0)
            }
            for (let t = 1; t <= a; t++)
                for (let e = 0; e < L; e++) {
                    const i = c ? A(_[e], F[e], N) : _[e];
                    M ? (x.copy(v.normals[t]).multiplyScalar(i.x), b.copy(v.binormals[t]).multiplyScalar(i.y), S.copy(y[t]).add(x).add(b), V(S.x, S.y, S.z)) : V(i.x, i.y, l / a * t)
                }
            for (let t = m - 1; t >= 0; t--) {
                const e = t / m,
                    i = d * Math.cos(e * Math.PI / 2),
                    n = u * Math.sin(e * Math.PI / 2) + p;
                for (let t = 0, e = T.length; t < e; t++) {
                    const e = A(T[t], R[t], n);
                    V(e.x, e.y, l + i)
                }
                for (let t = 0, e = E.length; t < e; t++) {
                    const e = E[t];
                    O = D[t];
                    for (let t = 0, s = e.length; t < s; t++) {
                        const s = A(e[t], O[t], n);
                        M ? V(s.x, s.y + y[a - 1].y, y[a - 1].x + i) : V(s.x, s.y, l + i)
                    }
                }
            }

            function B(t, e) {
                let i = t.length;
                for (; --i >= 0;) {
                    const n = i;
                    let s = i - 1;
                    s < 0 && (s = t.length - 1);
                    for (let t = 0, i = a + 2 * m; t < i; t++) {
                        const i = L * t,
                            r = L * (t + 1);
                        z(e + n + i, e + s + i, e + s + r, e + n + r)
                    }
                }
            }

            function V(t, e, i) {
                r.push(t), r.push(e), r.push(i)
            }

            function U(t, e, s) {
                H(t), H(e), H(s);
                const r = n.length / 3,
                    o = f.generateTopUV(i, n, r - 3, r - 2, r - 1);
                G(o[0]), G(o[1]), G(o[2])
            }

            function z(t, e, s, r) {
                H(t), H(e), H(r), H(e), H(s), H(r);
                const o = n.length / 3,
                    a = f.generateSideWallUV(i, n, o - 6, o - 3, o - 2, o - 1);
                G(a[0]), G(a[1]), G(a[3]), G(a[1]), G(a[2]), G(a[3])
            }

            function H(t) {
                n.push(r[3 * t + 0]), n.push(r[3 * t + 1]), n.push(r[3 * t + 2])
            }

            function G(t) {
                s.push(t.x), s.push(t.y)
            }! function() {
                const t = n.length / 3;
                if (c) {
                    let t = 0,
                        e = L * t;
                    for (let t = 0; t < k; t++) {
                        const i = P[t];
                        U(i[2] + e, i[1] + e, i[0] + e)
                    }
                    t = a + 2 * m, e = L * t;
                    for (let t = 0; t < k; t++) {
                        const i = P[t];
                        U(i[0] + e, i[1] + e, i[2] + e)
                    }
                } else {
                    for (let t = 0; t < k; t++) {
                        const e = P[t];
                        U(e[2], e[1], e[0])
                    }
                    for (let t = 0; t < k; t++) {
                        const e = P[t];
                        U(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                    }
                }
                i.addGroup(t, n.length / 3 - t, 0)
            }(),
                function() {
                    const t = n.length / 3;
                    let e = 0;
                    B(T, e), e += T.length;
                    for (let t = 0, i = E.length; t < i; t++) {
                        const i = E[t];
                        B(i, e), e += i.length
                    }
                    i.addGroup(t, n.length / 3 - t, 1)
                }()
        }
        this.setAttribute("position", new Kt(n, 3)), this.setAttribute("uv", new Kt(s, 2)), this.computeVertexNormals()
    }
    toJSON() {
        const t = ae.prototype.toJSON.call(this);
        return function(t, e, i) {
            if (i.shapes = [], Array.isArray(t))
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    i.shapes.push(n.uuid)
                } else i.shapes.push(t.uuid);
            void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON());
            return i
        }(this.parameters.shapes, this.parameters.options, t)
    }
}
const Cr = {
    generateTopUV: function(t, e, i, n, s) {
        const r = e[3 * i],
            o = e[3 * i + 1],
            a = e[3 * n],
            l = e[3 * n + 1],
            c = e[3 * s],
            d = e[3 * s + 1];
        return [new h(r, o), new h(a, l), new h(c, d)]
    },
    generateSideWallUV: function(t, e, i, n, s, r) {
        const o = e[3 * i],
            a = e[3 * i + 1],
            l = e[3 * i + 2],
            c = e[3 * n],
            d = e[3 * n + 1],
            u = e[3 * n + 2],
            p = e[3 * s],
            m = e[3 * s + 1],
            g = e[3 * s + 2],
            f = e[3 * r],
            y = e[3 * r + 1],
            v = e[3 * r + 2];
        return Math.abs(a - d) < .01 ? [new h(o, 1 - l), new h(c, 1 - u), new h(p, 1 - g), new h(f, 1 - v)] : [new h(a, 1 - l), new h(d, 1 - u), new h(m, 1 - g), new h(y, 1 - v)]
    }
};
class _r extends Js {
    constructor(t = 1, e = 0) {
        const i = (1 + Math.sqrt(5)) / 2;
        super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }
}
class Er extends ae {
    constructor(t, e = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        };
        const i = [],
            n = [],
            s = [],
            r = [];
        let o = 0,
            a = 0;
        if (!1 === Array.isArray(t)) l(t);
        else
            for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), o += a, a = 0;

        function l(t) {
            const o = n.length / 3,
                l = t.extractPoints(e);
            let h = l.shape;
            const c = l.holes;
            !1 === br.isClockWise(h) && (h = h.reverse());
            for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                !0 === br.isClockWise(e) && (c[t] = e.reverse())
            }
            const d = br.triangulateShape(h, c);
            for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                h = h.concat(e)
            }
            for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                n.push(e.x, e.y, 0), s.push(0, 0, 1), r.push(e.x, e.y)
            }
            for (let t = 0, e = d.length; t < e; t++) {
                const e = d[t],
                    n = e[0] + o,
                    s = e[1] + o,
                    r = e[2] + o;
                i.push(n, s, r), a += 3
            }
        }
        this.setIndex(i), this.setAttribute("position", new Kt(n, 3)), this.setAttribute("normal", new Kt(s, 3)), this.setAttribute("uv", new Kt(r, 2))
    }
    toJSON() {
        const t = ae.prototype.toJSON.call(this);
        return function(t, e) {
            if (e.shapes = [], Array.isArray(t))
                for (let i = 0, n = t.length; i < n; i++) {
                    const n = t[i];
                    e.shapes.push(n.uuid)
                } else e.shapes.push(t.uuid);
            return e
        }(this.parameters.shapes, t)
    }
}
class Pr extends ae {
    constructor(t = 1, e = 8, i = 6, n = 0, s = 2 * Math.PI, r = 0, o = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: s,
            thetaStart: r,
            thetaLength: o
        }, e = Math.max(3, Math.floor(e)), i = Math.max(2, Math.floor(i));
        const a = Math.min(r + o, Math.PI);
        let l = 0;
        const h = [],
            c = new w,
            d = new w,
            u = [],
            p = [],
            m = [],
            g = [];
        for (let u = 0; u <= i; u++) {
            const f = [],
                y = u / i;
            let v = 0;
            0 == u && 0 == r ? v = .5 / e : u == i && a == Math.PI && (v = -.5 / e);
            for (let i = 0; i <= e; i++) {
                const a = i / e;
                c.x = -t * Math.cos(n + a * s) * Math.sin(r + y * o), c.y = t * Math.cos(r + y * o), c.z = t * Math.sin(n + a * s) * Math.sin(r + y * o), p.push(c.x, c.y, c.z), d.copy(c).normalize(), m.push(d.x, d.y, d.z), g.push(a + v, 1 - y), f.push(l++)
            }
            h.push(f)
        }
        for (let t = 0; t < i; t++)
            for (let n = 0; n < e; n++) {
                const e = h[t][n + 1],
                    s = h[t][n],
                    o = h[t + 1][n],
                    l = h[t + 1][n + 1];
                (0 !== t || r > 0) && u.push(e, s, l), (t !== i - 1 || a < Math.PI) && u.push(s, o, l)
            }
        this.setIndex(u), this.setAttribute("position", new Kt(p, 3)), this.setAttribute("normal", new Kt(m, 3)), this.setAttribute("uv", new Kt(g, 2))
    }
}(class extends Bt {
    constructor(t) {
        super(), this.type = "ShadowMaterial", this.color = new qt(0), this.transparent = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this
    }
}).prototype.isShadowMaterial = !0;
(class extends ke {
    constructor(t) {
        super(t), this.type = "RawShaderMaterial"
    }
}).prototype.isRawShaderMaterial = !0;
class Tr extends Bt {
    constructor(t) {
        super(), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new qt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new h(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this
    }
}
Tr.prototype.isMeshStandardMaterial = !0;
(class extends Tr {
    constructor(t) {
        super(), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new h(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
            get: function() {
                return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
            },
            set: function(t) {
                this.reflectivity = r(2.5 * (t - 1) / (t + 1), 0, 1)
            }
        }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new qt).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
    }
}).prototype.isMeshPhysicalMaterial = !0;
(class extends Bt {
    constructor(t) {
        super(), this.type = "MeshPhongMaterial", this.color = new qt(16777215), this.specular = new qt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new h(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
    }
}).prototype.isMeshPhongMaterial = !0;
(class extends Bt {
    constructor(t) {
        super(), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new qt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new h(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }
}).prototype.isMeshToonMaterial = !0;
(class extends Bt {
    constructor(t) {
        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new h(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
    }
}).prototype.isMeshNormalMaterial = !0;
(class extends Bt {
    constructor(t) {
        super(), this.type = "MeshLambertMaterial", this.color = new qt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }
}).prototype.isMeshLambertMaterial = !0;
(class extends Bt {
    constructor(t) {
        super(), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new qt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new h(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
    }
}).prototype.isMeshMatcapMaterial = !0;
(class extends Is {
    constructor(t) {
        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    }
}).prototype.isLineDashedMaterial = !0;
const Ar = {
    arraySlice: function(t, e, i) {
        return Ar.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
    },
    convertArray: function(t, e, i) {
        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
    },
    isTypedArray: function(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView)
    },
    getKeyframeOrder: function(t) {
        const e = t.length,
            i = new Array(e);
        for (let t = 0; t !== e; ++t) i[t] = t;
        return i.sort((function(e, i) {
            return t[e] - t[i]
        })), i
    },
    sortedArray: function(t, e, i) {
        const n = t.length,
            s = new t.constructor(n);
        for (let r = 0, o = 0; o !== n; ++r) {
            const n = i[r] * e;
            for (let i = 0; i !== e; ++i) s[o++] = t[n + i]
        }
        return s
    },
    flattenJSON: function(t, e, i, n) {
        let s = 1,
            r = t[0];
        for (; void 0 !== r && void 0 === r[n];) r = t[s++];
        if (void 0 === r) return;
        let o = r[n];
        if (void 0 !== o)
            if (Array.isArray(o))
                do {
                    o = r[n], void 0 !== o && (e.push(r.time), i.push.apply(i, o)), r = t[s++]
                } while (void 0 !== r);
            else if (void 0 !== o.toArray)
                do {
                    o = r[n], void 0 !== o && (e.push(r.time), o.toArray(i, i.length)), r = t[s++]
                } while (void 0 !== r);
            else
                do {
                    o = r[n], void 0 !== o && (e.push(r.time), i.push(o)), r = t[s++]
                } while (void 0 !== r)
    },
    subclip: function(t, e, i, n, s = 30) {
        const r = t.clone();
        r.name = e;
        const o = [];
        for (let t = 0; t < r.tracks.length; ++t) {
            const e = r.tracks[t],
                a = e.getValueSize(),
                l = [],
                h = [];
            for (let t = 0; t < e.times.length; ++t) {
                const r = e.times[t] * s;
                if (!(r < i || r >= n)) {
                    l.push(e.times[t]);
                    for (let i = 0; i < a; ++i) h.push(e.values[t * a + i])
                }
            }
            0 !== l.length && (e.times = Ar.convertArray(l, e.times.constructor), e.values = Ar.convertArray(h, e.values.constructor), o.push(e))
        }
        r.tracks = o;
        let a = 1 / 0;
        for (let t = 0; t < r.tracks.length; ++t) a > r.tracks[t].times[0] && (a = r.tracks[t].times[0]);
        for (let t = 0; t < r.tracks.length; ++t) r.tracks[t].shift(-1 * a);
        return r.resetDuration(), r
    },
    makeClipAdditive: function(t, e = 0, i = t, n = 30) {
        n <= 0 && (n = 30);
        const s = i.tracks.length,
            r = e / n;
        for (let e = 0; e < s; ++e) {
            const n = i.tracks[e],
                s = n.ValueTypeName;
            if ("bool" === s || "string" === s) continue;
            const o = t.tracks.find((function(t) {
                return t.name === n.name && t.ValueTypeName === s
            }));
            if (void 0 === o) continue;
            let a = 0;
            const l = n.getValueSize();
            n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
            let h = 0;
            const c = o.getValueSize();
            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
            const d = n.times.length - 1;
            let u;
            if (r <= n.times[0]) {
                const t = a,
                    e = l - a;
                u = Ar.arraySlice(n.values, t, e)
            } else if (r >= n.times[d]) {
                const t = d * l + a,
                    e = t + l - a;
                u = Ar.arraySlice(n.values, t, e)
            } else {
                const t = n.createInterpolant(),
                    e = a,
                    i = l - a;
                t.evaluate(r), u = Ar.arraySlice(t.resultBuffer, e, i)
            }
            if ("quaternion" === s) {
                (new v).fromArray(u).normalize().conjugate().toArray(u)
            }
            const p = o.times.length;
            for (let t = 0; t < p; ++t) {
                const e = t * c + h;
                if ("quaternion" === s) v.multiplyQuaternionsFlat(o.values, e, u, 0, o.values, e);
                else {
                    const t = c - 2 * h;
                    for (let i = 0; i < t; ++i) o.values[e + i] -= u[i]
                }
            }
        }
        return t.blendMode = 2501, t
    }
};
class Lr {
    constructor(t, e, i, n) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(t) {
        const e = this.parameterPositions;
        let i = this._cachedIndex,
            n = e[i],
            s = e[i - 1];
        t: {
            e: {
                let r;i: {
                    n: if (!(t < n)) {
                        for (let r = i + 2;;) {
                            if (void 0 === n) {
                                if (t < s) break n;
                                return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, s)
                            }
                            if (i === r) break;
                            if (s = n, n = e[++i], t < n) break e
                        }
                        r = e.length;
                        break i
                    }if (t >= s) break t; {
                        const o = e[1];
                        t < o && (i = 2, s = o);
                        for (let r = i - 2;;) {
                            if (void 0 === s) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                            if (i === r) break;
                            if (n = s, s = e[--i - 1], t >= s) break e
                        }
                        r = i, i = 0
                    }
                }
                for (; i < r;) {
                    const n = i + r >>> 1;
                    t < e[n] ? r = n : i = n + 1
                }
                if (n = e[i], s = e[i - 1], void 0 === s) return this._cachedIndex = 0,
                    this.beforeStart_(0, t, n);
                if (void 0 === n) return i = e.length,
                    this._cachedIndex = i,
                    this.afterEnd_(i - 1, s, t)
            }
            this._cachedIndex = i,
                this.intervalChanged_(i, s, n)
        }
        return this.interpolate_(i, s, t, n)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(t) {
        const e = this.resultBuffer,
            i = this.sampleValues,
            n = this.valueSize,
            s = t * n;
        for (let t = 0; t !== n; ++t) e[t] = i[s + t];
        return e
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
Lr.prototype.beforeStart_ = Lr.prototype.copySampleValue_, Lr.prototype.afterEnd_ = Lr.prototype.copySampleValue_;
class kr extends Lr {
    constructor(t, e, i, n) {
        super(t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: 2400,
            endingEnd: 2400
        }
    }
    intervalChanged_(t, e, i) {
        const n = this.parameterPositions;
        let s = t - 2,
            r = t + 1,
            o = n[s],
            a = n[r];
        if (void 0 === o) switch (this.getSettings_().endingStart) {
            case 2401:
                s = t, o = 2 * e - i;
                break;
            case 2402:
                s = n.length - 2, o = e + n[s] - n[s + 1];
                break;
            default:
                s = t, o = i
        }
        if (void 0 === a) switch (this.getSettings_().endingEnd) {
            case 2401:
                r = t, a = 2 * i - e;
                break;
            case 2402:
                r = 1, a = i + n[1] - n[0];
                break;
            default:
                r = t - 1, a = e
        }
        const l = .5 * (i - e),
            h = this.valueSize;
        this._weightPrev = l / (e - o), this._weightNext = l / (a - i), this._offsetPrev = s * h, this._offsetNext = r * h
    }
    interpolate_(t, e, i, n) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            h = this._offsetPrev,
            c = this._offsetNext,
            d = this._weightPrev,
            u = this._weightNext,
            p = (i - e) / (n - e),
            m = p * p,
            g = m * p,
            f = -d * g + 2 * d * m - d * p,
            y = (1 + d) * g + (-1.5 - 2 * d) * m + (-.5 + d) * p + 1,
            v = (-1 - u) * g + (1.5 + u) * m + .5 * p,
            w = u * g - u * m;
        for (let t = 0; t !== o; ++t) s[t] = f * r[h + t] + y * r[l + t] + v * r[a + t] + w * r[c + t];
        return s
    }
}
class Ir extends Lr {
    constructor(t, e, i, n) {
        super(t, e, i, n)
    }
    interpolate_(t, e, i, n) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            h = (i - e) / (n - e),
            c = 1 - h;
        for (let t = 0; t !== o; ++t) s[t] = r[l + t] * c + r[a + t] * h;
        return s
    }
}
class Rr extends Lr {
    constructor(t, e, i, n) {
        super(t, e, i, n)
    }
    interpolate_(t) {
        return this.copySampleValue_(t - 1)
    }
}
class Dr {
    constructor(t, e, i, n) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Ar.convertArray(e, this.TimeBufferType), this.values = Ar.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
    }
    static toJSON(t) {
        const e = t.constructor;
        let i;
        if (e.toJSON !== this.toJSON) i = e.toJSON(t);
        else {
            i = {
                name: t.name,
                times: Ar.convertArray(t.times, Array),
                values: Ar.convertArray(t.values, Array)
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (i.interpolation = e)
        }
        return i.type = t.ValueTypeName, i
    }
    InterpolantFactoryMethodDiscrete(t) {
        return new Rr(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodLinear(t) {
        return new Ir(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodSmooth(t) {
        return new kr(this.times, this.values, this.getValueSize(), t)
    }
    setInterpolation(t) {
        let e;
        switch (t) {
            case 2300:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                e = this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === e) {
            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("THREE.KeyframeTrack:", e), this
        }
        return this.createInterpolant = e, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(t) {
        if (0 !== t) {
            const e = this.times;
            for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
        }
        return this
    }
    scale(t) {
        if (1 !== t) {
            const e = this.times;
            for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
        }
        return this
    }
    trim(t, e) {
        const i = this.times,
            n = i.length;
        let s = 0,
            r = n - 1;
        for (; s !== n && i[s] < t;) ++s;
        for (; - 1 !== r && i[r] > e;) --r;
        if (++r, 0 !== s || r !== n) {
            s >= r && (r = Math.max(r, 1), s = r - 1);
            const t = this.getValueSize();
            this.times = Ar.arraySlice(i, s, r), this.values = Ar.arraySlice(this.values, s * t, r * t)
        }
        return this
    }
    validate() {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const i = this.times,
            n = this.values,
            s = i.length;
        0 === s && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let r = null;
        for (let e = 0; e !== s; e++) {
            const n = i[e];
            if ("number" == typeof n && isNaN(n)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), t = !1;
                break
            }
            if (null !== r && r > n) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, r), t = !1;
                break
            }
            r = n
        }
        if (void 0 !== n && Ar.isTypedArray(n))
            for (let e = 0, i = n.length; e !== i; ++e) {
                const i = n[e];
                if (isNaN(i)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i), t = !1;
                    break
                }
            }
        return t
    }
    optimize() {
        const t = Ar.arraySlice(this.times),
            e = Ar.arraySlice(this.values),
            i = this.getValueSize(),
            n = 2302 === this.getInterpolation(),
            s = t.length - 1;
        let r = 1;
        for (let o = 1; o < s; ++o) {
            let s = !1;
            const a = t[o];
            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                if (n) s = !0;
                else {
                    const t = o * i,
                        n = t - i,
                        r = t + i;
                    for (let o = 0; o !== i; ++o) {
                        const i = e[t + o];
                        if (i !== e[n + o] || i !== e[r + o]) {
                            s = !0;
                            break
                        }
                    }
                } if (s) {
                if (o !== r) {
                    t[r] = t[o];
                    const n = o * i,
                        s = r * i;
                    for (let t = 0; t !== i; ++t) e[s + t] = e[n + t]
                }++r
            }
        }
        if (s > 0) {
            t[r] = t[s];
            for (let t = s * i, n = r * i, o = 0; o !== i; ++o) e[n + o] = e[t + o];
            ++r
        }
        return r !== t.length ? (this.times = Ar.arraySlice(t, 0, r), this.values = Ar.arraySlice(e, 0, r * i)) : (this.times = t, this.values = e), this
    }
    clone() {
        const t = Ar.arraySlice(this.times, 0),
            e = Ar.arraySlice(this.values, 0),
            i = new(0, this.constructor)(this.name, t, e);
        return i.createInterpolant = this.createInterpolant, i
    }
}
Dr.prototype.TimeBufferType = Float32Array, Dr.prototype.ValueBufferType = Float32Array, Dr.prototype.DefaultInterpolation = 2301;
class Or extends Dr {}
Or.prototype.ValueTypeName = "bool", Or.prototype.ValueBufferType = Array, Or.prototype.DefaultInterpolation = 2300, Or.prototype.InterpolantFactoryMethodLinear = void 0, Or.prototype.InterpolantFactoryMethodSmooth = void 0;
class Fr extends Dr {}
Fr.prototype.ValueTypeName = "color";
class Nr extends Dr {}
Nr.prototype.ValueTypeName = "number";
class Br extends Lr {
    constructor(t, e, i, n) {
        super(t, e, i, n)
    }
    interpolate_(t, e, i, n) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = (i - e) / (n - e);
        let l = t * o;
        for (let t = l + o; l !== t; l += 4) v.slerpFlat(s, 0, r, l - o, r, l, a);
        return s
    }
}
class Vr extends Dr {
    InterpolantFactoryMethodLinear(t) {
        return new Br(this.times, this.values, this.getValueSize(), t)
    }
}
Vr.prototype.ValueTypeName = "quaternion", Vr.prototype.DefaultInterpolation = 2301, Vr.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ur extends Dr {}
Ur.prototype.ValueTypeName = "string", Ur.prototype.ValueBufferType = Array, Ur.prototype.DefaultInterpolation = 2300, Ur.prototype.InterpolantFactoryMethodLinear = void 0, Ur.prototype.InterpolantFactoryMethodSmooth = void 0;
class zr extends Dr {}
zr.prototype.ValueTypeName = "vector";
class Hr {
    constructor(t, e = -1, i, n = 2500) {
        this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = s(), this.duration < 0 && this.resetDuration()
    }
    static parse(t) {
        const e = [],
            i = t.tracks,
            n = 1 / (t.fps || 1);
        for (let t = 0, s = i.length; t !== s; ++t) e.push(Gr(i[t]).scale(n));
        const s = new this(t.name, t.duration, e, t.blendMode);
        return s.uuid = t.uuid, s
    }
    static toJSON(t) {
        const e = [],
            i = t.tracks,
            n = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
        for (let t = 0, n = i.length; t !== n; ++t) e.push(Dr.toJSON(i[t]));
        return n
    }
    static CreateFromMorphTargetSequence(t, e, i, n) {
        const s = e.length,
            r = [];
        for (let t = 0; t < s; t++) {
            let o = [],
                a = [];
            o.push((t + s - 1) % s, t, (t + 1) % s), a.push(0, 1, 0);
            const l = Ar.getKeyframeOrder(o);
            o = Ar.sortedArray(o, 1, l), a = Ar.sortedArray(a, 1, l), n || 0 !== o[0] || (o.push(s), a.push(a[0])), r.push(new Nr(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / i))
        }
        return new this(t, -1, r)
    }
    static findByName(t, e) {
        let i = t;
        if (!Array.isArray(t)) {
            const e = t;
            i = e.geometry && e.geometry.animations || e.animations
        }
        for (let t = 0; t < i.length; t++)
            if (i[t].name === e) return i[t];
        return null
    }
    static CreateClipsFromMorphTargetSequences(t, e, i) {
        const n = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e],
                r = i.name.match(s);
            if (r && r.length > 1) {
                const t = r[1];
                let e = n[t];
                e || (n[t] = e = []), e.push(i)
            }
        }
        const r = [];
        for (const t in n) r.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
        return r
    }
    static parseAnimation(t, e) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function(t, e, i, n, s) {
                if (0 !== i.length) {
                    const r = [],
                        o = [];
                    Ar.flattenJSON(i, r, o, n), 0 !== r.length && s.push(new t(e, r, o))
                }
            },
            n = [],
            s = t.name || "default",
            r = t.fps || 30,
            o = t.blendMode;
        let a = t.length || -1;
        const l = t.hierarchy || [];
        for (let t = 0; t < l.length; t++) {
            const s = l[t].keys;
            if (s && 0 !== s.length)
                if (s[0].morphTargets) {
                    const t = {};
                    let e;
                    for (e = 0; e < s.length; e++)
                        if (s[e].morphTargets)
                            for (let i = 0; i < s[e].morphTargets.length; i++) t[s[e].morphTargets[i]] = -1;
                    for (const i in t) {
                        const t = [],
                            r = [];
                        for (let n = 0; n !== s[e].morphTargets.length; ++n) {
                            const n = s[e];
                            t.push(n.time), r.push(n.morphTarget === i ? 1 : 0)
                        }
                        n.push(new Nr(".morphTargetInfluence[" + i + "]", t, r))
                    }
                    a = t.length * (r || 1)
                } else {
                    const r = ".bones[" + e[t].name + "]";
                    i(zr, r + ".position", s, "pos", n), i(Vr, r + ".quaternion", s, "rot", n), i(zr, r + ".scale", s, "scl", n)
                }
        }
        if (0 === n.length) return null;
        return new this(s, a, n, o)
    }
    resetDuration() {
        let t = 0;
        for (let e = 0, i = this.tracks.length; e !== i; ++e) {
            const i = this.tracks[e];
            t = Math.max(t, i.times[i.times.length - 1])
        }
        return this.duration = t, this
    }
    trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this
    }
    validate() {
        let t = !0;
        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
        return t
    }
    optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this
    }
    clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function Gr(t) {
    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = function(t) {
        switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Nr;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return zr;
            case "color":
                return Fr;
            case "quaternion":
                return Vr;
            case "bool":
            case "boolean":
                return Or;
            case "string":
                return Ur
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
    }(t.type);
    if (void 0 === t.times) {
        const e = [],
            i = [];
        Ar.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i
    }
    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
}
const Wr = {
    enabled: !1,
    files: {},
    add: function(t, e) {
        !1 !== this.enabled && (this.files[t] = e)
    },
    get: function(t) {
        if (!1 !== this.enabled) return this.files[t]
    },
    remove: function(t) {
        delete this.files[t]
    },
    clear: function() {
        this.files = {}
    }
};
const qr = new class {
    constructor(t, e, i) {
        const n = this;
        let s, r = !1,
            o = 0,
            a = 0;
        const l = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
            a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0
        }, this.itemEnd = function(t) {
            o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
        }, this.itemError = function(t) {
            void 0 !== n.onError && n.onError(t)
        }, this.resolveURL = function(t) {
            return s ? s(t) : t
        }, this.setURLModifier = function(t) {
            return s = t, this
        }, this.addHandler = function(t, e) {
            return l.push(t, e), this
        }, this.removeHandler = function(t) {
            const e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2), this
        }, this.getHandler = function(t) {
            for (let e = 0, i = l.length; e < i; e += 2) {
                const i = l[e],
                    n = l[e + 1];
                if (i.global && (i.lastIndex = 0), i.test(t)) return n
            }
            return null
        }
    }
};
class jr {
    constructor(t) {
        this.manager = void 0 !== t ? t : qr, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(t, e) {
        const i = this;
        return new Promise((function(n, s) {
            i.load(t, n, e, s)
        }))
    }
    parse() {}
    setCrossOrigin(t) {
        return this.crossOrigin = t, this
    }
    setWithCredentials(t) {
        return this.withCredentials = t, this
    }
    setPath(t) {
        return this.path = t, this
    }
    setResourcePath(t) {
        return this.resourcePath = t, this
    }
    setRequestHeader(t) {
        return this.requestHeader = t, this
    }
}
const Yr = {};
class Jr extends jr {
    constructor(t) {
        super(t)
    }
    load(t, e, i, n) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const s = this,
            r = Wr.get(t);
        if (void 0 !== r) return s.manager.itemStart(t), setTimeout((function() {
            e && e(r), s.manager.itemEnd(t)
        }), 0), r;
        if (void 0 !== Yr[t]) return void Yr[t].push({
            onLoad: e,
            onProgress: i,
            onError: n
        });
        const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        let a;
        if (o) {
            const i = o[1],
                r = !!o[2];
            let a = o[3];
            a = decodeURIComponent(a), r && (a = atob(a));
            try {
                let n;
                const r = (this.responseType || "").toLowerCase();
                switch (r) {
                    case "arraybuffer":
                    case "blob":
                        const t = new Uint8Array(a.length);
                        for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                        n = "blob" === r ? new Blob([t.buffer], {
                            type: i
                        }) : t.buffer;
                        break;
                    case "document":
                        const e = new DOMParser;
                        n = e.parseFromString(a, i);
                        break;
                    case "json":
                        n = JSON.parse(a);
                        break;
                    default:
                        n = a
                }
                setTimeout((function() {
                    e && e(n), s.manager.itemEnd(t)
                }), 0)
            } catch (e) {
                setTimeout((function() {
                    n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
                }), 0)
            }
        } else {
            Yr[t] = [], Yr[t].push({
                onLoad: e,
                onProgress: i,
                onError: n
            }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                const i = this.response,
                    n = Yr[t];
                if (delete Yr[t], 200 === this.status || 0 === this.status) {
                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Wr.add(t, i);
                    for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t];
                        e.onLoad && e.onLoad(i)
                    }
                    s.manager.itemEnd(t)
                } else {
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    s.manager.itemError(t), s.manager.itemEnd(t)
                }
            }), !1), a.addEventListener("progress", (function(e) {
                const i = Yr[t];
                for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    n.onProgress && n.onProgress(e)
                }
            }), !1), a.addEventListener("error", (function(e) {
                const i = Yr[t];
                delete Yr[t];
                for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    n.onError && n.onError(e)
                }
                s.manager.itemError(t), s.manager.itemEnd(t)
            }), !1), a.addEventListener("abort", (function(e) {
                const i = Yr[t];
                delete Yr[t];
                for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    n.onError && n.onError(e)
                }
                s.manager.itemError(t), s.manager.itemEnd(t)
            }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
            for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
            a.send(null)
        }
        return s.manager.itemStart(t), a
    }
    setResponseType(t) {
        return this.responseType = t, this
    }
    setMimeType(t) {
        return this.mimeType = t, this
    }
}
class Xr extends jr {
    constructor(t) {
        super(t)
    }
    load(t, e, i, n) {
        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const s = this,
            r = Wr.get(t);
        if (void 0 !== r) return s.manager.itemStart(t), setTimeout((function() {
            e && e(r), s.manager.itemEnd(t)
        }), 0), r;
        const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

        function a() {
            o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), Wr.add(t, this), e && e(this), s.manager.itemEnd(t)
        }

        function l(e) {
            o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
        }
        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(t), o.src = t, o
    }
}
class $r extends jr {
    constructor(t) {
        super(t)
    }
    load(t, e, i, n) {
        const s = new Oe,
            r = new Xr(this.manager);
        r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
        let o = 0;

        function a(i) {
            r.load(t[i], (function(t) {
                s.images[i] = t, o++, 6 === o && (s.needsUpdate = !0, e && e(s))
            }), void 0, n)
        }
        for (let e = 0; e < t.length; ++e) a(e);
        return s
    }
}
class Zr extends jr {
    constructor(t) {
        super(t)
    }
    load(t, e, i, n) {
        const s = new m,
            r = new Xr(this.manager);
        return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(t, (function(i) {
            s.image = i;
            const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
            s.format = n ? 1022 : 1023, s.needsUpdate = !0, void 0 !== e && e(s)
        }), i, n), s
    }
}
class Kr {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(t, e) {
        const i = this.getUtoTmapping(t);
        return this.getPoint(i, e)
    }
    getPoints(t = 5) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return e
    }
    getSpacedPoints(t = 5) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
        return e
    }
    getLength() {
        const t = this.getLengths();
        return t[t.length - 1]
    }
    getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const e = [];
        let i, n = this.getPoint(0),
            s = 0;
        e.push(0);
        for (let r = 1; r <= t; r++) i = this.getPoint(r / t), s += i.distanceTo(n), e.push(s), n = i;
        return this.cacheArcLengths = e, e
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(t, e) {
        const i = this.getLengths();
        let n = 0;
        const s = i.length;
        let r;
        r = e || t * i[s - 1];
        let o, a = 0,
            l = s - 1;
        for (; a <= l;)
            if (n = Math.floor(a + (l - a) / 2), o = i[n] - r, o < 0) a = n + 1;
            else {
                if (!(o > 0)) {
                    l = n;
                    break
                }
                l = n - 1
            } if (n = l, i[n] === r) return n / (s - 1);
        const h = i[n];
        return (n + (r - h) / (i[n + 1] - h)) / (s - 1)
    }
    getTangent(t, e) {
        const i = 1e-4;
        let n = t - i,
            s = t + i;
        n < 0 && (n = 0), s > 1 && (s = 1);
        const r = this.getPoint(n),
            o = this.getPoint(s),
            a = e || (r.isVector2 ? new h : new w);
        return a.copy(o).sub(r).normalize(), a
    }
    getTangentAt(t, e) {
        const i = this.getUtoTmapping(t);
        return this.getTangent(i, e)
    }
    computeFrenetFrames(t, e) {
        const i = new w,
            n = [],
            s = [],
            o = [],
            a = new w,
            l = new $;
        for (let e = 0; e <= t; e++) {
            const i = e / t;
            n[e] = this.getTangentAt(i, new w), n[e].normalize()
        }
        s[0] = new w, o[0] = new w;
        let h = Number.MAX_VALUE;
        const c = Math.abs(n[0].x),
            d = Math.abs(n[0].y),
            u = Math.abs(n[0].z);
        c <= h && (h = c, i.set(1, 0, 0)), d <= h && (h = d, i.set(0, 1, 0)), u <= h && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), s[0].crossVectors(n[0], a), o[0].crossVectors(n[0], s[0]);
        for (let e = 1; e <= t; e++) {
            if (s[e] = s[e - 1].clone(), o[e] = o[e - 1].clone(), a.crossVectors(n[e - 1], n[e]), a.length() > Number.EPSILON) {
                a.normalize();
                const t = Math.acos(r(n[e - 1].dot(n[e]), -1, 1));
                s[e].applyMatrix4(l.makeRotationAxis(a, t))
            }
            o[e].crossVectors(n[e], s[e])
        }
        if (!0 === e) {
            let e = Math.acos(r(s[0].dot(s[t]), -1, 1));
            e /= t, n[0].dot(a.crossVectors(s[0], s[t])) > 0 && (e = -e);
            for (let i = 1; i <= t; i++) s[i].applyMatrix4(l.makeRotationAxis(n[i], e * i)), o[i].crossVectors(n[i], s[i])
        }
        return {
            tangents: n,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
    }
    fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
}
class Qr extends Kr {
    constructor(t = 0, e = 0, i = 1, n = 1, s = 0, r = 2 * Math.PI, o = !1, a = 0) {
        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = r, this.aClockwise = o, this.aRotation = a
    }
    getPoint(t, e) {
        const i = e || new h,
            n = 2 * Math.PI;
        let s = this.aEndAngle - this.aStartAngle;
        const r = Math.abs(s) < Number.EPSILON;
        for (; s < 0;) s += n;
        for (; s > n;) s -= n;
        s < Number.EPSILON && (s = r ? 0 : n), !0 !== this.aClockwise || r || (s === n ? s = -n : s -= n);
        const o = this.aStartAngle + t * s;
        let a = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                i = a - this.aX,
                n = l - this.aY;
            a = i * t - n * e + this.aX, l = i * e + n * t + this.aY
        }
        return i.set(a, l)
    }
    copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }
    toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }
}
Qr.prototype.isEllipseCurve = !0;
class to extends Qr {
    constructor(t, e, i, n, s, r) {
        super(t, e, i, i, n, s, r), this.type = "ArcCurve"
    }
}

function eo() {
    let t = 0,
        e = 0,
        i = 0,
        n = 0;

    function s(s, r, o, a) {
        t = s, e = o, i = -3 * s + 3 * r - 2 * o - a, n = 2 * s - 2 * r + o + a
    }
    return {
        initCatmullRom: function(t, e, i, n, r) {
            s(e, i, r * (i - t), r * (n - e))
        },
        initNonuniformCatmullRom: function(t, e, i, n, r, o, a) {
            let l = (e - t) / r - (i - t) / (r + o) + (i - e) / o,
                h = (i - e) / o - (n - e) / (o + a) + (n - i) / a;
            l *= o, h *= o, s(e, i, l, h)
        },
        calc: function(s) {
            const r = s * s;
            return t + e * s + i * r + n * (r * s)
        }
    }
}
to.prototype.isArcCurve = !0;
const io = new w,
    no = new eo,
    so = new eo,
    ro = new eo;
class oo extends Kr {
    constructor(t = [], e = !1, i = "centripetal", n = .5) {
        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n
    }
    getPoint(t, e = new w) {
        const i = e,
            n = this.points,
            s = n.length,
            r = (s - (this.closed ? 0 : 1)) * t;
        let o, a, l = Math.floor(r),
            h = r - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s : 0 === h && l === s - 1 && (l = s - 2, h = 1), this.closed || l > 0 ? o = n[(l - 1) % s] : (io.subVectors(n[0], n[1]).add(n[0]), o = io);
        const c = n[l % s],
            d = n[(l + 1) % s];
        if (this.closed || l + 2 < s ? a = n[(l + 2) % s] : (io.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), a = io), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t = "chordal" === this.curveType ? .5 : .25;
            let e = Math.pow(o.distanceToSquared(c), t),
                i = Math.pow(c.distanceToSquared(d), t),
                n = Math.pow(d.distanceToSquared(a), t);
            i < 1e-4 && (i = 1), e < 1e-4 && (e = i), n < 1e-4 && (n = i), no.initNonuniformCatmullRom(o.x, c.x, d.x, a.x, e, i, n), so.initNonuniformCatmullRom(o.y, c.y, d.y, a.y, e, i, n), ro.initNonuniformCatmullRom(o.z, c.z, d.z, a.z, e, i, n)
        } else "catmullrom" === this.curveType && (no.initCatmullRom(o.x, c.x, d.x, a.x, this.tension), so.initCatmullRom(o.y, c.y, d.y, a.y, this.tension), ro.initCatmullRom(o.z, c.z, d.z, a.z, this.tension));
        return i.set(no.calc(h), so.calc(h), ro.calc(h)), i
    }
    copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(i.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }
    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e];
            t.points.push(i.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }
    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push((new w).fromArray(i))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }
}

function ao(t, e, i, n, s) {
    const r = .5 * (n - e),
        o = .5 * (s - i),
        a = t * t;
    return (2 * i - 2 * n + r + o) * (t * a) + (-3 * i + 3 * n - 2 * r - o) * a + r * t + i
}

function lo(t, e, i, n) {
    return function(t, e) {
        const i = 1 - t;
        return i * i * e
    }(t, e) + function(t, e) {
        return 2 * (1 - t) * t * e
    }(t, i) + function(t, e) {
        return t * t * e
    }(t, n)
}

function ho(t, e, i, n, s) {
    return function(t, e) {
        const i = 1 - t;
        return i * i * i * e
    }(t, e) + function(t, e) {
        const i = 1 - t;
        return 3 * i * i * t * e
    }(t, i) + function(t, e) {
        return 3 * (1 - t) * t * t * e
    }(t, n) + function(t, e) {
        return t * t * t * e
    }(t, s)
}
oo.prototype.isCatmullRomCurve3 = !0;
class co extends Kr {
    constructor(t = new h, e = new h, i = new h, n = new h) {
        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
    }
    getPoint(t, e = new h) {
        const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2,
            o = this.v3;
        return i.set(ho(t, n.x, s.x, r.x, o.x), ho(t, n.y, s.y, r.y, o.y)), i
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
}
co.prototype.isCubicBezierCurve = !0;
class uo extends Kr {
    constructor(t = new w, e = new w, i = new w, n = new w) {
        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
    }
    getPoint(t, e = new w) {
        const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2,
            o = this.v3;
        return i.set(ho(t, n.x, s.x, r.x, o.x), ho(t, n.y, s.y, r.y, o.y), ho(t, n.z, s.z, r.z, o.z)), i
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
}
uo.prototype.isCubicBezierCurve3 = !0;
class po extends Kr {
    constructor(t = new h, e = new h) {
        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
    }
    getPoint(t, e = new h) {
        const i = e;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
    }
    getPointAt(t, e) {
        return this.getPoint(t, e)
    }
    getTangent(t, e) {
        const i = e || new h;
        return i.copy(this.v2).sub(this.v1).normalize(), i
    }
    copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
po.prototype.isLineCurve = !0;
class mo extends Kr {
    constructor(t = new h, e = new h, i = new h) {
        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i
    }
    getPoint(t, e = new h) {
        const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2;
        return i.set(lo(t, n.x, s.x, r.x), lo(t, n.y, s.y, r.y)), i
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
mo.prototype.isQuadraticBezierCurve = !0;
class go extends Kr {
    constructor(t = new w, e = new w, i = new w) {
        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i
    }
    getPoint(t, e = new w) {
        const i = e,
            n = this.v0,
            s = this.v1,
            r = this.v2;
        return i.set(lo(t, n.x, s.x, r.x), lo(t, n.y, s.y, r.y), lo(t, n.z, s.z, r.z)), i
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
go.prototype.isQuadraticBezierCurve3 = !0;
class fo extends Kr {
    constructor(t = []) {
        super(), this.type = "SplineCurve", this.points = t
    }
    getPoint(t, e = new h) {
        const i = e,
            n = this.points,
            s = (n.length - 1) * t,
            r = Math.floor(s),
            o = s - r,
            a = n[0 === r ? r : r - 1],
            l = n[r],
            c = n[r > n.length - 2 ? n.length - 1 : r + 1],
            d = n[r > n.length - 3 ? n.length - 1 : r + 2];
        return i.set(ao(o, a.x, l.x, c.x, d.x), ao(o, a.y, l.y, c.y, d.y)), i
    }
    copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, i = this.points.length; e < i; e++) {
            const i = this.points[e];
            t.points.push(i.toArray())
        }
        return t
    }
    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
            const i = t.points[e];
            this.points.push((new h).fromArray(i))
        }
        return this
    }
}
fo.prototype.isSplineCurve = !0;
var yo = Object.freeze({
    __proto__: null,
    ArcCurve: to,
    CatmullRomCurve3: oo,
    CubicBezierCurve: co,
    CubicBezierCurve3: uo,
    EllipseCurve: Qr,
    LineCurve: po,
    LineCurve3: class extends Kr {
        constructor(t = new w, e = new w) {
            super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
        }
        getPoint(t, e = new w) {
            const i = e;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }
        getPointAt(t, e) {
            return this.getPoint(t, e)
        }
        copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
    },
    QuadraticBezierCurve: mo,
    QuadraticBezierCurve3: go,
    SplineCurve: fo
});
class vo extends Kr {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(t) {
        this.curves.push(t)
    }
    closePath() {
        const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new po(e, t))
    }
    getPoint(t) {
        const e = t * this.getLength(),
            i = this.getCurveLengths();
        let n = 0;
        for (; n < i.length;) {
            if (i[n] >= e) {
                const t = i[n] - e,
                    s = this.curves[n],
                    r = s.getLength(),
                    o = 0 === r ? 0 : 1 - t / r;
                return s.getPointAt(o)
            }
            n++
        }
        return null
    }
    getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
        return this.cacheLengths = t, t
    }
    getSpacedPoints(t = 40) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return this.autoClose && e.push(e[0]), e
    }
    getPoints(t = 12) {
        const e = [];
        let i;
        for (let n = 0, s = this.curves; n < s.length; n++) {
            const r = s[n],
                o = r && r.isEllipseCurve ? 2 * t : r && (r.isLineCurve || r.isLineCurve3) ? 1 : r && r.isSplineCurve ? t * r.points.length : t,
                a = r.getPoints(o);
            for (let t = 0; t < a.length; t++) {
                const n = a[t];
                i && i.equals(n) || (e.push(n), i = n)
            }
        }
        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
    }
    copy(t) {
        super.copy(t), this.curves = [];
        for (let e = 0, i = t.curves.length; e < i; e++) {
            const i = t.curves[e];
            this.curves.push(i.clone())
        }
        return this.autoClose = t.autoClose, this
    }
    toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for (let e = 0, i = this.curves.length; e < i; e++) {
            const i = this.curves[e];
            t.curves.push(i.toJSON())
        }
        return t
    }
    fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for (let e = 0, i = t.curves.length; e < i; e++) {
            const i = t.curves[e];
            this.curves.push((new yo[i.type]).fromJSON(i))
        }
        return this
    }
}
class wo extends vo {
    constructor(t) {
        super(), this.type = "Path", this.currentPoint = new h, t && this.setFromPoints(t)
    }
    setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
        return this
    }
    moveTo(t, e) {
        return this.currentPoint.set(t, e), this
    }
    lineTo(t, e) {
        const i = new po(this.currentPoint.clone(), new h(t, e));
        return this.curves.push(i), this.currentPoint.set(t, e), this
    }
    quadraticCurveTo(t, e, i, n) {
        const s = new mo(this.currentPoint.clone(), new h(t, e), new h(i, n));
        return this.curves.push(s), this.currentPoint.set(i, n), this
    }
    bezierCurveTo(t, e, i, n, s, r) {
        const o = new co(this.currentPoint.clone(), new h(t, e), new h(i, n), new h(s, r));
        return this.curves.push(o), this.currentPoint.set(s, r), this
    }
    splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t),
            i = new fo(e);
        return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
    }
    arc(t, e, i, n, s, r) {
        const o = this.currentPoint.x,
            a = this.currentPoint.y;
        return this.absarc(t + o, e + a, i, n, s, r), this
    }
    absarc(t, e, i, n, s, r) {
        return this.absellipse(t, e, i, i, n, s, r), this
    }
    ellipse(t, e, i, n, s, r, o, a) {
        const l = this.currentPoint.x,
            h = this.currentPoint.y;
        return this.absellipse(t + l, e + h, i, n, s, r, o, a), this
    }
    absellipse(t, e, i, n, s, r, o, a) {
        const l = new Qr(t, e, i, n, s, r, o, a);
        if (this.curves.length > 0) {
            const t = l.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
        }
        this.curves.push(l);
        const h = l.getPoint(1);
        return this.currentPoint.copy(h), this
    }
    copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
    }
}
class bo extends wo {
    constructor(t) {
        super(t), this.uuid = s(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(t) {
        const e = [];
        for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
        return e
    }
    extractPoints(t) {
        return {
            shape: this.getPoints(t),
            holes: this.getPointsHoles(t)
        }
    }
    copy(t) {
        super.copy(t), this.holes = [];
        for (let e = 0, i = t.holes.length; e < i; e++) {
            const i = t.holes[e];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for (let e = 0, i = this.holes.length; e < i; e++) {
            const i = this.holes[e];
            t.holes.push(i.toJSON())
        }
        return t
    }
    fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for (let e = 0, i = t.holes.length; e < i; e++) {
            const i = t.holes[e];
            this.holes.push((new wo).fromJSON(i))
        }
        return this
    }
}
class xo extends xt {
    constructor(t, e = 1) {
        super(), this.type = "Light", this.color = new qt(t), this.intensity = e
    }
    dispose() {}
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
    }
}
xo.prototype.isLight = !0;
(class extends xo {
    constructor(t, e, i) {
        super(t, i), this.type = "HemisphereLight", this.position.copy(xt.DefaultUp), this.updateMatrix(), this.groundColor = new qt(e)
    }
    copy(t) {
        return xo.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
    }
}).prototype.isHemisphereLight = !0;
const So = new $,
    Mo = new w,
    Co = new w;
class _o {
    constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new h(512, 512), this.map = null, this.mapPass = null, this.matrix = new $, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ue, this._frameExtents = new h(1, 1), this._viewportCount = 1, this._viewports = [new f(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(t) {
        const e = this.camera,
            i = this.matrix;
        Mo.setFromMatrixPosition(t.matrixWorld), e.position.copy(Mo), Co.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Co), e.updateMatrixWorld(), So.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(So), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse)
    }
    getViewport(t) {
        return this._viewports[t]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    toJSON() {
        const t = {};
        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
}
class Eo extends _o {
    constructor() {
        super(new Re(50, 1, .5, 500)), this.focus = 1
    }
    updateMatrices(t) {
        const e = this.camera,
            i = 2 * n * t.angle * this.focus,
            s = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
        i === e.fov && s === e.aspect && r === e.far || (e.fov = i, e.aspect = s, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
    }
    copy(t) {
        return super.copy(t), this.focus = t.focus, this
    }
}
Eo.prototype.isSpotLightShadow = !0;
(class extends xo {
    constructor(t, e, i = 0, n = Math.PI / 3, s = 0, r = 1) {
        super(t, e), this.type = "SpotLight", this.position.copy(xt.DefaultUp), this.updateMatrix(), this.target = new xt, this.distance = i, this.angle = n, this.penumbra = s, this.decay = r, this.shadow = new Eo
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(t) {
        this.intensity = t / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(t) {
        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}).prototype.isSpotLight = !0;
const Po = new $,
    To = new w,
    Ao = new w;
class Lo extends _o {
    constructor() {
        super(new Re(90, 1, .5, 500)), this._frameExtents = new h(4, 2), this._viewportCount = 6, this._viewports = [new f(2, 1, 1, 1), new f(0, 1, 1, 1), new f(3, 1, 1, 1), new f(1, 1, 1, 1), new f(3, 0, 1, 1), new f(1, 0, 1, 1)], this._cubeDirections = [new w(1, 0, 0), new w(-1, 0, 0), new w(0, 0, 1), new w(0, 0, -1), new w(0, 1, 0), new w(0, -1, 0)], this._cubeUps = [new w(0, 1, 0), new w(0, 1, 0), new w(0, 1, 0), new w(0, 1, 0), new w(0, 0, 1), new w(0, 0, -1)]
    }
    updateMatrices(t, e = 0) {
        const i = this.camera,
            n = this.matrix,
            s = t.distance || i.far;
        s !== i.far && (i.far = s, i.updateProjectionMatrix()), To.setFromMatrixPosition(t.matrixWorld), i.position.copy(To), Ao.copy(i.position), Ao.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(Ao), i.updateMatrixWorld(), n.makeTranslation(-To.x, -To.y, -To.z), Po.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Po)
    }
}
Lo.prototype.isPointLightShadow = !0;
(class extends xo {
    constructor(t, e, i = 0, n = 1) {
        super(t, e), this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new Lo
    }
    get power() {
        return 4 * this.intensity * Math.PI
    }
    set power(t) {
        this.intensity = t / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(t) {
        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
}).prototype.isPointLight = !0;
class ko extends Ie {
    constructor(t = -1, e = 1, i = 1, n = -1, s = .1, r = 2e3) {
        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = s, this.far = r, this.updateProjectionMatrix()
    }
    copy(t, e) {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
    }
    setViewOffset(t, e, i, n, s, r) {
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = r, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            n = (this.top + this.bottom) / 2;
        let s = i - t,
            r = i + t,
            o = n + e,
            a = n - e;
        if (null !== this.view && this.view.enabled) {
            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += t * this.view.offsetX, r = s + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, r, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
    }
}
ko.prototype.isOrthographicCamera = !0;
class Io extends _o {
    constructor() {
        super(new ko(-5, 5, 5, -5, .5, 500))
    }
}
Io.prototype.isDirectionalLightShadow = !0;
(class extends xo {
    constructor(t, e) {
        super(t, e), this.type = "DirectionalLight", this.position.copy(xt.DefaultUp), this.updateMatrix(), this.target = new xt, this.shadow = new Io
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}).prototype.isDirectionalLight = !0;
(class extends xo {
    constructor(t, e) {
        super(t, e), this.type = "AmbientLight"
    }
}).prototype.isAmbientLight = !0;
(class extends xo {
    constructor(t, e, i = 10, n = 10) {
        super(t, e), this.type = "RectAreaLight", this.width = i, this.height = n
    }
    copy(t) {
        return super.copy(t), this.width = t.width, this.height = t.height, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.width = this.width, e.object.height = this.height, e
    }
}).prototype.isRectAreaLight = !0;
class Ro {
    constructor() {
        this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new w)
    }
    set(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this
    }
    zero() {
        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this
    }
    getAt(t, e) {
        const i = t.x,
            n = t.y,
            s = t.z,
            r = this.coefficients;
        return e.copy(r[0]).multiplyScalar(.282095), e.addScaledVector(r[1], .488603 * n), e.addScaledVector(r[2], .488603 * s), e.addScaledVector(r[3], .488603 * i), e.addScaledVector(r[4], i * n * 1.092548), e.addScaledVector(r[5], n * s * 1.092548), e.addScaledVector(r[6], .315392 * (3 * s * s - 1)), e.addScaledVector(r[7], i * s * 1.092548), e.addScaledVector(r[8], .546274 * (i * i - n * n)), e
    }
    getIrradianceAt(t, e) {
        const i = t.x,
            n = t.y,
            s = t.z,
            r = this.coefficients;
        return e.copy(r[0]).multiplyScalar(.886227), e.addScaledVector(r[1], 1.023328 * n), e.addScaledVector(r[2], 1.023328 * s), e.addScaledVector(r[3], 1.023328 * i), e.addScaledVector(r[4], .858086 * i * n), e.addScaledVector(r[5], .858086 * n * s), e.addScaledVector(r[6], .743125 * s * s - .247708), e.addScaledVector(r[7], .858086 * i * s), e.addScaledVector(r[8], .429043 * (i * i - n * n)), e
    }
    add(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this
    }
    addScaledSH(t, e) {
        for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
        return this
    }
    scale(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this
    }
    lerp(t, e) {
        for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
        return this
    }
    equals(t) {
        for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
        return !0
    }
    copy(t) {
        return this.set(t.coefficients)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    fromArray(t, e = 0) {
        const i = this.coefficients;
        for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
        return this
    }
    toArray(t = [], e = 0) {
        const i = this.coefficients;
        for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
        return t
    }
    static getBasisAt(t, e) {
        const i = t.x,
            n = t.y,
            s = t.z;
        e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * s, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * s, e[6] = .315392 * (3 * s * s - 1), e[7] = 1.092548 * i * s, e[8] = .546274 * (i * i - n * n)
    }
}
Ro.prototype.isSphericalHarmonics3 = !0;
class Do extends xo {
    constructor(t = new Ro, e = 1) {
        super(void 0, e), this.sh = t
    }
    copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this
    }
    fromJSON(t) {
        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.sh = this.sh.toArray(), e
    }
}
Do.prototype.isLightProbe = !0;
(class extends ae {
    constructor() {
        super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    toJSON() {
        const t = super.toJSON(this);
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
    }
}).prototype.isInstancedBufferGeometry = !0;
(class extends Xt {
    constructor(t, e, i, n) {
        "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, i), this.meshPerAttribute = n || 1
    }
    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }
    toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
    }
}).prototype.isInstancedBufferAttribute = !0;
let Oo;
(class extends jr {
    constructor(t) {
        super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(t) {
        return this.options = t, this
    }
    load(t, e, i, n) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const s = this,
            r = Wr.get(t);
        if (void 0 !== r) return s.manager.itemStart(t), setTimeout((function() {
            e && e(r), s.manager.itemEnd(t)
        }), 0), r;
        const o = {};
        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function(t) {
            return t.blob()
        })).then((function(t) {
            return createImageBitmap(t, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        })).then((function(i) {
            Wr.add(t, i), e && e(i), s.manager.itemEnd(t)
        })).catch((function(e) {
            n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
        })), s.manager.itemStart(t)
    }
}).prototype.isImageBitmapLoader = !0;
const Fo = function() {
    return void 0 === Oo && (Oo = new(window.AudioContext || window.webkitAudioContext)), Oo
};
class No extends jr {
    constructor(t) {
        super(t)
    }
    load(t, e, i, n) {
        const s = this,
            r = new Jr(this.manager);
        r.setResponseType("arraybuffer"), r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(t, (function(i) {
            try {
                const t = i.slice(0);
                Fo().decodeAudioData(t, (function(t) {
                    e(t)
                }))
            } catch (e) {
                n ? n(e) : console.error(e), s.manager.itemError(t)
            }
        }), i, n)
    }
}(class extends Do {
    constructor(t, e, i = 1) {
        super(void 0, i);
        const n = (new qt).set(t),
            s = (new qt).set(e),
            r = new w(n.r, n.g, n.b),
            o = new w(s.r, s.g, s.b),
            a = Math.sqrt(Math.PI),
            l = a * Math.sqrt(.75);
        this.sh.coefficients[0].copy(r).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(r).sub(o).multiplyScalar(l)
    }
}).prototype.isHemisphereLightProbe = !0;
(class extends Do {
    constructor(t, e = 1) {
        super(void 0, e);
        const i = (new qt).set(t);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}).prototype.isAmbientLightProbe = !0;
class Bo {
    constructor(t, e, i) {
        let n, s, r;
        switch (this.binding = t, this.valueSize = i, e) {
            case "quaternion":
                n = this._slerp, s = this._slerpAdditive, r = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                n = this._select, s = this._select, r = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                break;
            default:
                n = this._lerp, s = this._lerpAdditive, r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
        }
        this._mixBufferRegion = n, this._mixBufferRegionAdditive = s, this._setIdentity = r, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    accumulate(t, e) {
        const i = this.buffer,
            n = this.valueSize,
            s = t * n + n;
        let r = this.cumulativeWeight;
        if (0 === r) {
            for (let t = 0; t !== n; ++t) i[s + t] = i[t];
            r = e
        } else {
            r += e;
            const t = e / r;
            this._mixBufferRegion(i, s, 0, t, n)
        }
        this.cumulativeWeight = r
    }
    accumulateAdditive(t) {
        const e = this.buffer,
            i = this.valueSize,
            n = i * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t
    }
    apply(t) {
        const e = this.valueSize,
            i = this.buffer,
            n = t * e + e,
            s = this.cumulativeWeight,
            r = this.cumulativeWeightAdditive,
            o = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
            const t = e * this._origIndex;
            this._mixBufferRegion(i, n, t, 1 - s, e)
        }
        r > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
        for (let t = e, s = e + e; t !== s; ++t)
            if (i[t] !== i[t + e]) {
                o.setValue(i, n);
                break
            }
    }
    saveOriginalState() {
        const t = this.binding,
            e = this.buffer,
            i = this.valueSize,
            n = i * this._origIndex;
        t.getValue(e, n);
        for (let t = i, s = n; t !== s; ++t) e[t] = e[n + t % i];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t)
    }
    _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize,
            e = t + this.valueSize;
        for (let i = t; i < e; i++) this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
    }
    _select(t, e, i, n, s) {
        if (n >= .5)
            for (let n = 0; n !== s; ++n) t[e + n] = t[i + n]
    }
    _slerp(t, e, i, n) {
        v.slerpFlat(t, e, t, e, t, i, n)
    }
    _slerpAdditive(t, e, i, n, s) {
        const r = this._workIndex * s;
        v.multiplyQuaternionsFlat(t, r, t, e, t, i), v.slerpFlat(t, e, t, e, t, r, n)
    }
    _lerp(t, e, i, n, s) {
        const r = 1 - n;
        for (let o = 0; o !== s; ++o) {
            const s = e + o;
            t[s] = t[s] * r + t[i + o] * n
        }
    }
    _lerpAdditive(t, e, i, n, s) {
        for (let r = 0; r !== s; ++r) {
            const s = e + r;
            t[s] = t[s] + t[i + r] * n
        }
    }
}
const Vo = new RegExp("[\\[\\]\\.:\\/]", "g"),
    Uo = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
    zo = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    Ho = /(WCOD+)?/.source.replace("WCOD", Uo),
    Go = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    Wo = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
    qo = new RegExp("^" + zo + Ho + Go + Wo + "$"),
    jo = ["material", "materials", "bones"];
class Yo {
    constructor(t, e, i) {
        this.path = e, this.parsedPath = i || Yo.parseTrackName(e), this.node = Yo.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(t, e, i) {
        return t && t.isAnimationObjectGroup ? new Yo.Composite(t, e, i) : new Yo(t, e, i)
    }
    static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(Vo, "")
    }
    static parseTrackName(t) {
        const e = qo.exec(t);
        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const i = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            },
            n = i.nodeName && i.nodeName.lastIndexOf(".");
        if (void 0 !== n && -1 !== n) {
            const t = i.nodeName.substring(n + 1); - 1 !== jo.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = t)
        }
        if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return i
    }
    static findNode(t, e) {
        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
            const i = t.skeleton.getBoneByName(e);
            if (void 0 !== i) return i
        }
        if (t.children) {
            const i = function(t) {
                    for (let n = 0; n < t.length; n++) {
                        const s = t[n];
                        if (s.name === e || s.uuid === e) return s;
                        const r = i(s.children);
                        if (r) return r
                    }
                    return null
                },
                n = i(t.children);
            if (n) return n
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
        t[e] = this.node[this.propertyName]
    }
    _getValue_array(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) t[e++] = i[n]
    }
    _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e)
    }
    _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e]
    }
    _setValue_direct_setNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++]
    }
    _setValue_array_setNeedsUpdate(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e]
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e)
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e)
    }
    _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e)
    }
    bind() {
        let t = this.node;
        const e = this.parsedPath,
            i = e.objectName,
            n = e.propertyName;
        let s = e.propertyIndex;
        if (t || (t = Yo.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (i) {
            let n = e.objectIndex;
            switch (i) {
                case "materials":
                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    t = t.material.materials;
                    break;
                case "bones":
                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    t = t.skeleton.bones;
                    for (let e = 0; e < t.length; e++)
                        if (t[e].name === n) {
                            n = e;
                            break
                        } break;
                default:
                    if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    t = t[i]
            }
            if (void 0 !== n) {
                if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                t = t[n]
            }
        }
        const r = t[n];
        if (void 0 === r) {
            const i = e.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
        }
        let o = this.Versioning.None;
        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== s) {
            if ("morphTargetInfluences" === n) {
                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                void 0 !== t.morphTargetDictionary[s] && (s = t.morphTargetDictionary[s])
            }
            a = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = s
        } else void 0 !== r.fromArray && void 0 !== r.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (a = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = n;
        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
Yo.Composite = class {
    constructor(t, e, i) {
        const n = i || Yo.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, n)
    }
    getValue(t, e) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
            n = this._bindings[i];
        void 0 !== n && n.getValue(t, e)
    }
    setValue(t, e) {
        const i = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n) i[n].setValue(t, e)
    }
    bind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
    }
    unbind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
    }
}, Yo.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
}, Yo.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
}, Yo.prototype.GetterByBindingType = [Yo.prototype._getValue_direct, Yo.prototype._getValue_array, Yo.prototype._getValue_arrayElement, Yo.prototype._getValue_toArray], Yo.prototype.SetterByBindingTypeAndVersioning = [
    [Yo.prototype._setValue_direct, Yo.prototype._setValue_direct_setNeedsUpdate, Yo.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [Yo.prototype._setValue_array, Yo.prototype._setValue_array_setNeedsUpdate, Yo.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [Yo.prototype._setValue_arrayElement, Yo.prototype._setValue_arrayElement_setNeedsUpdate, Yo.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [Yo.prototype._setValue_fromArray, Yo.prototype._setValue_fromArray_setNeedsUpdate, Yo.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class Jo {
    constructor(t, e, i = null, n = e.blendMode) {
        this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
        const s = e.tracks,
            r = s.length,
            o = new Array(r),
            a = {
                endingStart: 2400,
                endingEnd: 2400
            };
        for (let t = 0; t !== r; ++t) {
            const e = s[t].createInterpolant(null);
            o[t] = e, e.settings = a
        }
        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this), this
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset()
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(t) {
        return this._startTime = t, this
    }
    setLoop(t, e) {
        return this.loop = t, this.repetitions = e, this
    }
    setEffectiveWeight(t) {
        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(t) {
        return this._scheduleFading(t, 0, 1)
    }
    fadeOut(t) {
        return this._scheduleFading(t, 1, 0)
    }
    crossFadeFrom(t, e, i) {
        if (t.fadeOut(e), this.fadeIn(e), i) {
            const i = this._clip.duration,
                n = t._clip.duration,
                s = n / i,
                r = i / n;
            t.warp(1, s, e), this.warp(r, 1, e)
        }
        return this
    }
    crossFadeTo(t, e, i) {
        return t.crossFadeFrom(this, e, i)
    }
    stopFading() {
        const t = this._weightInterpolant;
        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }
    setEffectiveTimeScale(t) {
        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(t) {
        return this.timeScale = this._clip.duration / t, this.stopWarping()
    }
    syncWith(t) {
        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
    }
    halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t)
    }
    warp(t, e, i) {
        const n = this._mixer,
            s = n.time,
            r = this.timeScale;
        let o = this._timeScaleInterpolant;
        null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
        const a = o.parameterPositions,
            l = o.sampleValues;
        return a[0] = s, a[1] = s + i, l[0] = t / r, l[1] = e / r, this
    }
    stopWarping() {
        const t = this._timeScaleInterpolant;
        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(t, e, i, n) {
        if (!this.enabled) return void this._updateWeight(t);
        const s = this._startTime;
        if (null !== s) {
            const n = (t - s) * i;
            if (n < 0 || 0 === i) return;
            this._startTime = null, e = i * n
        }
        e *= this._updateTimeScale(t);
        const r = this._updateTime(e),
            o = this._updateWeight(t);
        if (o > 0) {
            const t = this._interpolants,
                e = this._propertyBindings;
            switch (this.blendMode) {
                case 2501:
                    for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(r), e[i].accumulateAdditive(o);
                    break;
                case 2500:
                default:
                    for (let i = 0, s = t.length; i !== s; ++i) t[i].evaluate(r), e[i].accumulate(n, o)
            }
        }
    }
    _updateWeight(t) {
        let e = 0;
        if (this.enabled) {
            e = this.weight;
            const i = this._weightInterpolant;
            if (null !== i) {
                const n = i.evaluate(t)[0];
                e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = e, e
    }
    _updateTimeScale(t) {
        let e = 0;
        if (!this.paused) {
            e = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (null !== i) {
                e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
            }
        }
        return this._effectiveTimeScale = e, e
    }
    _updateTime(t) {
        const e = this._clip.duration,
            i = this.loop;
        let n = this.time + t,
            s = this._loopCount;
        const r = 2202 === i;
        if (0 === t) return -1 === s ? n : r && 1 == (1 & s) ? e - n : n;
        if (2200 === i) {
            -1 === s && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            t: {
                if (n >= e) n = e;
                else {
                    if (!(n < 0)) {
                        this.time = n;
                        break t
                    }
                    n = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = n,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
            }
        } else {
            if (-1 === s && (t >= 0 ? (s = 0, this._setEndings(!0, 0 === this.repetitions, r)) : this._setEndings(0 === this.repetitions, !0, r)), n >= e || n < 0) {
                const i = Math.floor(n / e);
                n -= e * i, s += Math.abs(i);
                const o = this.repetitions - s;
                if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1
                });
                else {
                    if (1 === o) {
                        const e = t < 0;
                        this._setEndings(e, !e, r)
                    } else this._setEndings(!1, !1, r);
                    this._loopCount = s, this.time = n, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: i
                    })
                }
            } else this.time = n;
            if (r && 1 == (1 & s)) return e - n
        }
        return n
    }
    _setEndings(t, e, i) {
        const n = this._interpolantSettings;
        i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
    }
    _scheduleFading(t, e, i) {
        const n = this._mixer,
            s = n.time;
        let r = this._weightInterpolant;
        null === r && (r = n._lendControlInterpolant(), this._weightInterpolant = r);
        const o = r.parameterPositions,
            a = r.sampleValues;
        return o[0] = s, a[0] = e, o[1] = s + t, a[1] = i, this
    }
}(class extends t {
    constructor(t) {
        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }
    _bindAction(t, e) {
        const i = t._localRoot || this._root,
            n = t._clip.tracks,
            s = n.length,
            r = t._propertyBindings,
            o = t._interpolants,
            a = i.uuid,
            l = this._bindingsByRootAndName;
        let h = l[a];
        void 0 === h && (h = {}, l[a] = h);
        for (let t = 0; t !== s; ++t) {
            const s = n[t],
                l = s.name;
            let c = h[l];
            if (void 0 !== c) r[t] = c;
            else {
                if (c = r[t], void 0 !== c) {
                    null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, a, l));
                    continue
                }
                const n = e && e._propertyBindings[t].binding.parsedPath;
                c = new Bo(Yo.create(i, l, n), s.ValueTypeName, s.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, a, l), r[t] = c
            }
            o[t].resultBuffer = c.buffer
        }
    }
    _activateAction(t) {
        if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                    i = t._clip.uuid,
                    n = this._actionsByClip[i];
                this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
            }
            const e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
                const i = e[t];
                0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState())
            }
            this._lendAction(t)
        }
    }
    _deactivateAction(t) {
        if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
                const i = e[t];
                0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
            }
            this._takeBackAction(t)
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t = this;
        this.stats = {
            actions: {
                get total() {
                    return t._actions.length
                },
                get inUse() {
                    return t._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return t._bindings.length
                },
                get inUse() {
                    return t._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return t._controlInterpolants.length
                },
                get inUse() {
                    return t._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(t) {
        const e = t._cacheIndex;
        return null !== e && e < this._nActiveActions
    }
    _addInactiveAction(t, e, i) {
        const n = this._actions,
            s = this._actionsByClip;
        let r = s[e];
        if (void 0 === r) r = {
            knownActions: [t],
            actionByRoot: {}
        }, t._byClipCacheIndex = 0, s[e] = r;
        else {
            const e = r.knownActions;
            t._byClipCacheIndex = e.length, e.push(t)
        }
        t._cacheIndex = n.length, n.push(t), r.actionByRoot[i] = t
    }
    _removeInactiveAction(t) {
        const e = this._actions,
            i = e[e.length - 1],
            n = t._cacheIndex;
        i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
        const s = t._clip.uuid,
            r = this._actionsByClip,
            o = r[s],
            a = o.knownActions,
            l = a[a.length - 1],
            h = t._byClipCacheIndex;
        l._byClipCacheIndex = h, a[h] = l, a.pop(), t._byClipCacheIndex = null;
        delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete r[s], this._removeInactiveBindingsForAction(t)
    }
    _removeInactiveBindingsForAction(t) {
        const e = t._propertyBindings;
        for (let t = 0, i = e.length; t !== i; ++t) {
            const i = e[t];
            0 == --i.referenceCount && this._removeInactiveBinding(i)
        }
    }
    _lendAction(t) {
        const e = this._actions,
            i = t._cacheIndex,
            n = this._nActiveActions++,
            s = e[n];
        t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s
    }
    _takeBackAction(t) {
        const e = this._actions,
            i = t._cacheIndex,
            n = --this._nActiveActions,
            s = e[n];
        t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s
    }
    _addInactiveBinding(t, e, i) {
        const n = this._bindingsByRootAndName,
            s = this._bindings;
        let r = n[e];
        void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = s.length, s.push(t)
    }
    _removeInactiveBinding(t) {
        const e = this._bindings,
            i = t.binding,
            n = i.rootNode.uuid,
            s = i.path,
            r = this._bindingsByRootAndName,
            o = r[n],
            a = e[e.length - 1],
            l = t._cacheIndex;
        a._cacheIndex = l, e[l] = a, e.pop(), delete o[s], 0 === Object.keys(o).length && delete r[n]
    }
    _lendBinding(t) {
        const e = this._bindings,
            i = t._cacheIndex,
            n = this._nActiveBindings++,
            s = e[n];
        t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s
    }
    _takeBackBinding(t) {
        const e = this._bindings,
            i = t._cacheIndex,
            n = --this._nActiveBindings,
            s = e[n];
        t._cacheIndex = n, e[n] = t, s._cacheIndex = i, e[i] = s
    }
    _lendControlInterpolant() {
        const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++;
        let i = t[e];
        return void 0 === i && (i = new Ir(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i
    }
    _takeBackControlInterpolant(t) {
        const e = this._controlInterpolants,
            i = t.__cacheIndex,
            n = --this._nActiveControlInterpolants,
            s = e[n];
        t.__cacheIndex = n, e[n] = t, s.__cacheIndex = i, e[i] = s
    }
    clipAction(t, e, i) {
        const n = e || this._root,
            s = n.uuid;
        let r = "string" == typeof t ? Hr.findByName(n, t) : t;
        const o = null !== r ? r.uuid : t,
            a = this._actionsByClip[o];
        let l = null;
        if (void 0 === i && (i = null !== r ? r.blendMode : 2500), void 0 !== a) {
            const t = a.actionByRoot[s];
            if (void 0 !== t && t.blendMode === i) return t;
            l = a.knownActions[0], null === r && (r = l._clip)
        }
        if (null === r) return null;
        const h = new Jo(this, r, e, i);
        return this._bindAction(h, l), this._addInactiveAction(h, o, s), h
    }
    existingAction(t, e) {
        const i = e || this._root,
            n = i.uuid,
            s = "string" == typeof t ? Hr.findByName(i, t) : t,
            r = s ? s.uuid : t,
            o = this._actionsByClip[r];
        return void 0 !== o && o.actionByRoot[n] || null
    }
    stopAllAction() {
        const t = this._actions;
        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
        return this
    }
    update(t) {
        t *= this.timeScale;
        const e = this._actions,
            i = this._nActiveActions,
            n = this.time += t,
            s = Math.sign(t),
            r = this._accuIndex ^= 1;
        for (let o = 0; o !== i; ++o) {
            e[o]._update(n, t, s, r)
        }
        const o = this._bindings,
            a = this._nActiveBindings;
        for (let t = 0; t !== a; ++t) o[t].apply(r);
        return this
    }
    setTime(t) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(t)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(t) {
        const e = this._actions,
            i = t.uuid,
            n = this._actionsByClip,
            s = n[i];
        if (void 0 !== s) {
            const t = s.knownActions;
            for (let i = 0, n = t.length; i !== n; ++i) {
                const n = t[i];
                this._deactivateAction(n);
                const s = n._cacheIndex,
                    r = e[e.length - 1];
                n._cacheIndex = null, n._byClipCacheIndex = null, r._cacheIndex = s, e[s] = r, e.pop(), this._removeInactiveBindingsForAction(n)
            }
            delete n[i]
        }
    }
    uncacheRoot(t) {
        const e = t.uuid,
            i = this._actionsByClip;
        for (const t in i) {
            const n = i[t].actionByRoot[e];
            void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
        }
        const n = this._bindingsByRootAndName[e];
        if (void 0 !== n)
            for (const t in n) {
                const e = n[t];
                e.restoreOriginalState(), this._removeInactiveBinding(e)
            }
    }
    uncacheAction(t, e) {
        const i = this.existingAction(t, e);
        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
    }
}).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
(class extends ss {
    constructor(t, e, i = 1) {
        super(t, e), this.meshPerAttribute = i || 1
    }
    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }
    clone(t) {
        const e = super.clone(t);
        return e.meshPerAttribute = this.meshPerAttribute, e
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
    }
}).prototype.isInstancedInterleavedBuffer = !0;
(class extends xt {
    constructor(t) {
        super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
    }
}).prototype.isImmediateRenderObject = !0;
const Xo = new w,
    $o = new $,
    Zo = new $;

function Ko(t) {
    const e = [];
    t && t.isBone && e.push(t);
    for (let i = 0; i < t.children.length; i++) e.push.apply(e, Ko(t.children[i]));
    return e
}
const Qo = new Float32Array(1);
new Int32Array(Qo.buffer);
const ta = new jt({
    side: 1,
    depthWrite: !1,
    depthTest: !1
});
new _e(new Pe, ta), Kr.create = function(t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Kr.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
}, wo.prototype.fromPoints = function(t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
}, class extends zs {
    constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
        i = new qt(i), n = new qt(n);
        const s = e / 2,
            r = t / e,
            o = t / 2,
            a = [],
            l = [];
        for (let t = 0, h = 0, c = -o; t <= e; t++, c += r) {
            a.push(-o, 0, c, o, 0, c), a.push(c, 0, -o, c, 0, o);
            const e = t === s ? i : n;
            e.toArray(l, h), h += 3, e.toArray(l, h), h += 3, e.toArray(l, h), h += 3, e.toArray(l, h), h += 3
        }
        const h = new ae;
        h.setAttribute("position", new Kt(a, 3)), h.setAttribute("color", new Kt(l, 3));
        super(h, new Is({
            vertexColors: !0,
            toneMapped: !1
        })), this.type = "GridHelper"
    }
}.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
}, class extends zs {
    constructor(t) {
        const e = Ko(t),
            i = new ae,
            n = [],
            s = [],
            r = new qt(0, 0, 1),
            o = new qt(0, 1, 0);
        for (let t = 0; t < e.length; t++) {
            const i = e[t];
            i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), s.push(r.r, r.g, r.b), s.push(o.r, o.g, o.b))
        }
        i.setAttribute("position", new Kt(n, 3)), i.setAttribute("color", new Kt(s, 3));
        super(i, new Is({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(t) {
        const e = this.bones,
            i = this.geometry,
            n = i.getAttribute("position");
        Zo.copy(this.root.matrixWorld).invert();
        for (let t = 0, i = 0; t < e.length; t++) {
            const s = e[t];
            s.parent && s.parent.isBone && ($o.multiplyMatrices(Zo, s.matrixWorld), Xo.setFromMatrixPosition($o), n.setXYZ(i, Xo.x, Xo.y, Xo.z), $o.multiplyMatrices(Zo, s.parent.matrixWorld), Xo.setFromMatrixPosition($o), n.setXYZ(i + 1, Xo.x, Xo.y, Xo.z), i += 2)
        }
        i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
    }
}.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
}, jr.prototype.extractUrlBase = function(t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), class {
        static decodeText(t) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
            let e = "";
            for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
            try {
                return decodeURIComponent(escape(e))
            } catch (t) {
                return e
            }
        }
        static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    }.extractUrlBase(t)
}, jr.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
    }
}, S.prototype.center = function(t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
}, S.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
}, S.prototype.isIntersectionBox = function(t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
}, S.prototype.isIntersectionSphere = function(t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
}, S.prototype.size = function(t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
}, z.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
}, Ue.prototype.setFromMatrix = function(t) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
}, c.prototype.flattenToArrayOffset = function(t, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
}, c.prototype.multiplyVector3 = function(t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
}, c.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
}, c.prototype.applyToBufferAttribute = function(t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
}, c.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
}, c.prototype.getInverse = function(t) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
}, $.prototype.extractPosition = function(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
}, $.prototype.flattenToArrayOffset = function(t, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
}, $.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new w).setFromMatrixColumn(this, 3)
}, $.prototype.setRotationFromQuaternion = function(t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
}, $.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
}, $.prototype.multiplyVector3 = function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
}, $.prototype.multiplyVector4 = function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
}, $.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
}, $.prototype.rotateAxis = function(t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
}, $.prototype.crossVector = function(t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
}, $.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.")
}, $.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.")
}, $.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.")
}, $.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.")
}, $.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
}, $.prototype.applyToBufferAttribute = function(t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
}, $.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
}, $.prototype.makeFrustum = function(t, e, i, n, s, r) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, s, r)
}, $.prototype.getInverse = function(t) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
}, _t.prototype.isIntersectionLine = function(t) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
}, v.prototype.multiplyVector3 = function(t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
}, v.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
}, X.prototype.isIntersectionBox = function(t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
}, X.prototype.isIntersectionPlane = function(t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
}, X.prototype.isIntersectionSphere = function(t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
}, Ft.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
}, Ft.prototype.barycoordFromPoint = function(t, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
}, Ft.prototype.midpoint = function(t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
}, Ft.prototypenormal = function(t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
}, Ft.prototype.plane = function(t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
}, Ft.barycoordFromPoint = function(t, e, i, n, s) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ft.getBarycoord(t, e, i, n, s)
}, Ft.normal = function(t, e, i, n) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ft.getNormal(t, e, i, n)
}, bo.prototype.extractAllPoints = function(t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
}, bo.prototype.extrude = function(t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Mr(this, t)
}, bo.prototype.makeGeometry = function(t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Er(this, t)
}, h.prototype.fromAttribute = function(t, e, i) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
}, h.prototype.distanceToManhattan = function(t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
}, h.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
}, w.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
}, w.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
}, w.prototype.getPositionFromMatrix = function(t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
}, w.prototype.getScaleFromMatrix = function(t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
}, w.prototype.getColumnFromMatrix = function(t, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
}, w.prototype.applyProjection = function(t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
}, w.prototype.fromAttribute = function(t, e, i) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
}, w.prototype.distanceToManhattan = function(t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
}, w.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
}, f.prototype.fromAttribute = function(t, e, i) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
}, f.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
}, xt.prototype.getChildByName = function(t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
}, xt.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
}, xt.prototype.translate = function(t, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
}, xt.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
}, xt.prototype.applyMatrix = function(t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
}, Object.defineProperties(xt.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
        },
        set: function(t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
    }
}), _e.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
}, Object.defineProperties(_e.prototype, {
    drawMode: {
        get: function() {
            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }
}), Ps.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.")
}, Re.prototype.setLens = function(t, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
}, Object.defineProperties(xo.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.")
        }
    },
    shadowCameraFov: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
        }
    },
    shadowCameraLeft: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
        }
    },
    shadowCameraRight: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
        }
    },
    shadowCameraTop: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
        }
    },
    shadowCameraBottom: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
        }
    },
    shadowCameraNear: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
        }
    },
    shadowCameraFar: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
    },
    shadowBias: {
        set: function(t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
    },
    shadowMapWidth: {
        set: function(t) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
        }
    },
    shadowMapHeight: {
        set: function(t) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
        }
    }
}), Object.defineProperties(Xt.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
        }
    },
    dynamic: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
        }
    }
}), Xt.prototype.setDynamic = function(t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this
}, Xt.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
}, Xt.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}, ae.prototype.addIndex = function(t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
}, ae.prototype.addAttribute = function(t, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Xt(arguments[1], arguments[2])))
}, ae.prototype.addDrawCall = function(t, e, i) {
    void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
}, ae.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
}, ae.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
}, ae.prototype.removeAttribute = function(t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
}, ae.prototype.applyMatrix = function(t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
}, Object.defineProperties(ae.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
        }
    }
}), ss.prototype.setDynamic = function(t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this
}, ss.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}, Mr.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
}, Mr.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
}, Mr.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
}, ns.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.")
}, Object.defineProperties(Bt.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE.Material: .wrapRGB has been removed."), new qt
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
        },
        set: function(t) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
        }
    },
    stencilMask: {
        get: function() {
            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
        },
        set: function(t) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
        }
    }
}), Object.defineProperties(ke.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
        },
        set: function(t) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
        }
    }
}), is.prototype.clearTarget = function(t, e, i, n) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
}, is.prototype.animate = function(t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
}, is.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
}, is.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
}, is.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
}, is.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
}, is.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
}, is.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
}, is.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
}, is.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
}, is.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
}, is.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
}, is.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
}, is.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
}, is.prototype.enableScissorTest = function(t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
}, is.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
}, is.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
}, is.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
}, is.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
}, is.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
}, is.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
}, is.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
}, is.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
}, is.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
}, is.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
}, Object.defineProperties(is.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    context: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
        }
    },
    vr: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
        }
    },
    gammaInput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
        }
    },
    gammaOutput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : 3e3
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
        }
    }
}), Object.defineProperties(jn.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        }
    }
}), Object.defineProperties(y.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
        }
    }
}), class extends xt {
    constructor(t) {
        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
    }
    setMediaElementSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
    }
    setMediaStreamSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
    }
    setBuffer(t) {
        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
    }
    play(t = 0) {
        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + t;
        const e = this.context.createBufferSource();
        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }
    pause() {
        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    stop() {
        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this
    }
    getFilters() {
        return this.filters
    }
    setFilters(t) {
        return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
    }
    setDetune(t) {
        if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(t) {
        return this.setFilters(t ? [t] : [])
    }
    setPlaybackRate(t) {
        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }
    setLoop(t) {
        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    setLoopStart(t) {
        return this.loopStart = t, this
    }
    setLoopEnd(t) {
        return this.loopEnd = t, this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
    }
}.prototype.load = function(t) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const e = this;
    return (new No).load(t, (function(t) {
        e.setBuffer(t)
    })), this
}, De.prototype.updateCubeMap = function(t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
}, De.prototype.clear = function(t, e, i, n) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, i, n)
}, u.crossOrigin = void 0, u.loadTexture = function(t, e, i, n) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const s = new Zr;
    s.setCrossOrigin(this.crossOrigin);
    const r = s.load(t, i, void 0, n);
    return e && (r.mapping = e), r
}, u.loadTextureCube = function(t, e, i, n) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const s = new $r;
    s.setCrossOrigin(this.crossOrigin);
    const r = s.load(t, i, void 0, n);
    return e && (r.mapping = e), r
}, u.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
}, u.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: "128"
    }
})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "128");
class ea {
    constructor() {}
    static init() {
        this.listeners || (this.listeners = []), window.addEventListener("resize", (t => {
            this.testResized()
        })), this.loop()
    }
    static loop() {
        this.testResized(), window.requestAnimationFrame((t => {
            this.loop()
        }))
    }
    static testResized() {
        const t = window.innerWidth,
            e = window.innerHeight;
        if (t != this.prevW || e != this.prevH) {
            this.prevW = t, this.prevH = e;
            for (const t of this.listeners) t()
        }
    }
    static addListener(t) {
        this.listeners || (this.listeners = []), this.listeners.push(t)
    }
    static removeListener(t) {
        this.listeners || (this.listeners = []);
        const e = this.listeners.indexOf(t);
        e >= 0 && this.listeners.splice(e, 1)
    }
}
class ia {
    constructor(t = "keyValuesDb", e = ["keyValues"]) {
        this.dbName = t, this.objectStoreNames = e, this.supported = !1;
        try {
            const i = indexedDB.open(t);
            i.onupgradeneeded = t => {
                for (const t of e) i.result.createObjectStore(t)
            }, this.supported = !0
        } catch (t) {
            console.log("error while opening indexedDB: ", t)
        }
    }
    async promisifyRequest(t) {
        return "done" == t.readyState ? t.result : await new Promise(((e, i) => {
            t.onsuccess = i => {
                e(t.result)
            }, t.onerror = i
        }))
    }
    getLocalStorageName(t, e = this.objectStoreNames[0]) {
        return "indexedDBFallback-" + this.dbName + "-" + e + "-" + t
    }
    async get(t, e = this.objectStoreNames[0]) {
        if (!this.supported) {
            let i = localStorage.getItem(this.getLocalStorageName(t, e));
            try {
                i = JSON.parse(i)
            } catch (t) {
                i = null
            }
            return i
        }
        const i = await indexedDB.open(this.dbName),
            n = (await this.promisifyRequest(i)).transaction(e, "readonly").objectStore(e).get(t);
        return await this.promisifyRequest(n)
    }
    set(t, e, i = this.objectStoreNames[0]) {
        return this.getSet(t, (t => e), i)
    }
    async getSet(t, e, i = this.objectStoreNames[0], n = !1) {
        if (!this.supported) {
            const n = this.getLocalStorageName(t, i);
            let s = localStorage.getItem(n);
            try {
                s = JSON.parse(s)
            } catch (t) {
                s = null
            }
            const r = e(s);
            return void localStorage.setItem(n, JSON.stringify(r))
        }
        const s = indexedDB.open(this.dbName),
            r = (await this.promisifyRequest(s)).transaction(i, "readwrite").objectStore(i),
            o = r.openCursor(t),
            a = await this.promisifyRequest(o);
        if (a)
            if (n) {
                const t = a.delete();
                await this.promisifyRequest(t)
            } else {
                const t = e(a.value),
                    i = a.update(t);
                await this.promisifyRequest(i)
            }
        else {
            const i = r.put(e(null), t);
            await this.promisifyRequest(i)
        }
    }
    delete(t, e = this.objectStoreNames[0]) {
        this.getSet(t, (t => {}), e, !0)
    }
}
class na {
    constructor(t) {
        this.indexedDb = t, this.defaultValues = {
            sfxVolume: 100,
            musicVolume: 100,
            fov: 90,
            mouseAcceleration: !1,
            mouseSensitivity: 1,
            invertMouseY: !1,
            autoShoot: !1,
            walkHeadBob: !0,
            landHeadBob: !0,
            afFlipScreen: !0,
            hideUi: !1,
            smoothCam: !1
        }, this.currentValues = new Map, this.onValueChangeCbs = new Map;
        for (const [t, e] of Object.entries(this.defaultValues)) {
            const i = t;
            this.currentValues.set(i, e)
        }
        this.onSettingsLoadedCbs = new Set, this._settingsLoaded = !1, this._isLoadingSettings = !1
    }
    init() {
        this.loadSettings()
    }
    async loadSettings() {
        if (this.settingsLoaded || this._isLoadingSettings) return;
        this._isLoadingSettings = !0;
        let t = null;
        try {
            t = await this.indexedDb.get("settings")
        } catch (t) {
            console.warn("Unable to load settings, third party cookies are probably blocked")
        }
        if (t)
            for (const [e, i] of Object.entries(t)) {
                const t = e;
                this.currentValues.set(t, i), this.fireValueChange(t, i)
            }
        this._settingsLoaded = !0, this.onSettingsLoadedCbs.forEach((t => t()))
    }
    get settingsLoaded() {
        return this._settingsLoaded
    }
    async saveSettings() {
        if (!this.settingsLoaded) return !1;
        const t = {};
        for (const [e, i] of this.currentValues) this.defaultValues[e] != i && (t[e] = i);
        try {
            await this.indexedDb.set("settings", t)
        } catch (t) {
            return !1
        }
        return !0
    }
    getValue(t) {
        return this.currentValues.get(t)
    }
    setValue(t, e) {
        this.currentValues.set(t, e), this.fireValueChange(t, e), this.saveSettings()
    }
    fireValueChange(t, e) {
        const i = this.onValueChangeCbs.get(t);
        if (i)
            for (const t of i) t(e)
    }
    onValueChange(t, e) {
        let i = this.onValueChangeCbs.get(t);
        i || (i = new Set, this.onValueChangeCbs.set(t, i)), i.add(e)
    }
    removeOnValueChange(t, e) {
        const i = this.onValueChangeCbs.get(t);
        i && (i.delete(e), i.size <= 0 && this.onValueChangeCbs.delete(t))
    }
    onSettingsLoaded(t) {
        this.onSettingsLoadedCbs.add(t)
    }
}
class sa {
    constructor(t, {
        startLoading: e = !1,
        showPercentage: i = !1,
        shouldBounce: n = !0,
        priority: s = 0
    } = {}) {
        this.text = t, this.showPercentage = i, this.shouldBounce = n, this.priority = s, this.percentage = 0, this.isLoading = e, this.onStateChangeCbs = new Set
    }
    setIsLoading(t) {
        this.isLoading != t && (this.isLoading = t, this.fireStateChange())
    }
    onStateChange(t) {
        this.onStateChangeCbs.add(t)
    }
    fireStateChange() {
        for (const t of this.onStateChangeCbs) t()
    }
    setShowPercentage(t) {
        this.showPercentage = t, this.fireStateChange()
    }
    setPercentage(t) {
        this.percentage = t, this.fireStateChange()
    }
    getText() {
        let t = this.text;
        return this.showPercentage && this.percentage > 0 && (t += " " + Math.round(100 * this.percentage) + "%"), t
    }
}
class ra {
    constructor(t, e, i) {
        this.cb = t, this.id = -1, this.ms = e, this.isDestructed = !1, i && this.start()
    }
    destructor() {
        this.stop(), this.isDestructed = !0, this.cb = null
    }
    get isRunning() {
        return -1 != this.id
    }
    stop() {
        if (!this.isDestructed) return this.id >= 0 && (window.clearTimeout(this.id), this.id = -1, !0)
    }
    start(t = this.ms) {
        this.isDestructed || (this.stop(), this.id = window.setTimeout(this.execute.bind(this), t))
    }
    execute() {
        this.id = -1, this.cb && this.cb()
    }
    static promise(t) {
        return new Promise(((e, i) => {
            window.setTimeout((() => {
                e()
            }), t)
        }))
    }
}

function* oa(t, {
    skipObjsFn: e = null
} = {}) {
    if (!e || e(t)) {
        yield t;
        for (const i of t.children)
            for (const t of oa(i, {
                skipObjsFn: e
            })) yield t
    }
}

function aa(t, e) {
    return (t % e + e) % e
}

function la(t, e, i) {
    return t + i * (e - t)
}

function ha(t, e, i) {
    return (i - t) / (e - t)
}

function ca(t, e, i, n, s, r = !1) {
    let o = ha(t, e, s);
    return r && (o = ua(o)), la(i, n, o)
}

function da(t, e, i) {
    return Math.max(e, Math.min(i, t))
}

function ua(t) {
    return da(t, 0, 1)
}

function pa(t, e) {
    return Math.floor(ga(t, e))
}

function ma(t, e, i) {
    return Math.floor(function(t, e, i) {
        return function(t) {
            const e = 1e4 * Math.sin(t++);
            return e - Math.floor(e)
        }(i) * (e - t) + t
    }(t, e, i))
}

function ga(t, e) {
    return Math.random() * (e - t) + t
}

function fa(t) {
    return function(t, e) {
        return t[Math.floor(e * t.length)]
    }(t, Math.random())
}
const ya = new Map;

function va() {
    return function(t) {
        const e = new URLSearchParams(t),
            i = {};
        for (const t of e.entries()) i[t[0]] = t[1];
        return i
    }(location.search)
}
async function wa(t, e = {}) {
    const {
        timeout: i = 8e3
    } = e, n = new AbortController, s = setTimeout((() => n.abort()), i);
    e.signal = n.signal;
    const r = await fetch(t, e);
    return clearTimeout(s), r
}
class ba {
    constructor({
                    text: t = "",
                    icon: e = "",
                    testLabel: i = "",
                    iconSizeMultiplier: n = .9,
                    onClick: s = null
                } = {}) {
        this.containerEl = document.createElement("div"), this.containerEl.classList.add("main-menu-button-container"), this.el = document.createElement("button"), this.el.classList.add("wrinkledPaper"), this.containerEl.appendChild(this.el), this.el.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, t && (this.el.ariaLabel = t), this.el.classList.add("main-menu-button"), this.el.addEventListener("click", (t => {
            s && s()
        })), this.textEl = document.createElement("div"), this.textEl.classList.add("main-menu-button-text", "whiteBigText", "blueNight"), this.textEl.textContent = t, this.textEl.ariaHidden = "true", this.containerEl.appendChild(this.textEl), this.visible = !0, e && (this.iconEl = document.createElement("div"), this.iconEl.classList.add("buttonImage"), this.iconEl.style.backgroundImage = `url(${e})`, this.iconEl.style.backgroundSize = 100 * n + "%", this.el.appendChild(this.iconEl))
    }
    setVisibility(t) {
        this.visible = t, this.el.style.display = t ? "" : "none"
    }
    click(t = !1) {
        t && !this.visible || this.el.click()
    }
    setText(t) {
        this.textEl.textContent = t
    }
}
class xa {
    constructor({
                    amount: t = 0,
                    testLabel: e = ""
                } = {}) {
        this._amount = t, this.el = document.createElement("div"), this.el.classList.add("currency-container");
        const i = document.createElement("div");
        i.classList.add("coin-icon"), this.el.appendChild(i), this.textEl = document.createElement("span"), this.textEl.classList.add("coin-count-text", "blueNight"), this.el.appendChild(this.textEl), this.isAnimatingAmount = !1, this.animatingStartValue = 0, this.animatingTargetValue = 0, this.animatingCurrentValue = 0, this.animatingDurationMs = 0, this.animatingStartTime = 0, this.animatingSfxEnabled = !0, this.lastIncrementSfxTime = 0, this.boundAnimationLoop = this.animationLoop.bind(this), this.setAmount(t)
    }
    setAmount(t) {
        this._amount = t, this._setAmountText(String(t))
    }
    _setAmountText(t) {
        this.textEl.textContent = t, this.textEl.dataset.textContent = t
    }
    get amount() {
        return this._amount
    }
    animateAmount(t, {
        durationMultiplier: e = 1,
        sfx: i = !0
    } = {}) {
        this.isAnimatingAmount ? this.animatingStartValue = this.animatingCurrentValue : this.animatingStartValue = this._amount, this._amount = t, this.animatingTargetValue = t;
        const n = Math.abs(this.animatingTargetValue - this.animatingStartValue);
        this.animatingDurationMs = da(n, 30, 100) * e * 30, this.animatingStartTime = performance.now(), this.animatingSfxEnabled = i;
        const s = !this.isAnimatingAmount;
        this.isAnimatingAmount = !0, s && this.boundAnimationLoop()
    }
    animationLoop() {
        let t = (performance.now() - this.animatingStartTime) / this.animatingDurationMs;
        t = ua(t);
        const e = Math.pow(t, .2);
        let i = la(this.animatingStartValue, this.animatingTargetValue, e);
        if (i = Math.round(i), this.animatingCurrentValue != i && (this.animatingCurrentValue = i, this._setAmountText(String(i)), this.animatingSfxEnabled && performance.now() > this.lastIncrementSfxTime + 40)) {
            this.lastIncrementSfxTime = performance.now(), uc().sfx.playSound("ui/coin/pile", {
                volume: .3 * (1 - t)
            });
            const i = la(.7, 1, e),
                n = pa(0, 4);
            uc().sfx.playSound("ui/coin/" + n, {
                volume: .5 * t,
                minPitch: i,
                maxPitch: i
            })
        }
        e >= 1 ? this.isAnimatingAmount = !1 : window.requestAnimationFrame(this.boundAnimationLoop)
    }
}
class Sa {
    constructor({
                    text: t = "",
                    ariaLabel: e = "",
                    onClick: i = null,
                    showCurrency: n = !1,
                    currency: s = 0,
                    extraClasses: r = [],
                    testLabel: o = "",
                    isIconButton: a = !1,
                    icon: l = null,
                    iconSize: h = 1
                } = {}) {
        this.el = document.createElement("button"), a ? this.el.classList.add("icon-button", ...r) : this.el.classList.add("dialog-button", "blueNight", "wrinkledPaper", ...r), this.el.classList.toggle("currency-button", n), this.el.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, e && (this.el.ariaLabel = e), this.textEl = document.createElement("span"), this.textEl.textContent = t, this.el.appendChild(this.textEl), this._iconEl = null, this._iconSize = h, this._currentIcon = null, this.setIcon(l), this._visible = !0, n && (this.currencyContainer = new xa({
            amount: s
        }), this.el.appendChild(this.currencyContainer.el)), i && this.onClick(i)
    }
    get visible() {
        return this._visible
    }
    set visible(t) {
        this._visible = t, this.el.style.display = t ? "" : "none"
    }
    click() {
        this.el.click()
    }
    onClick(t) {
        this.el.addEventListener("click", t)
    }
    set enabled(t) {
        this.el.disabled = !t
    }
    get enabled() {
        return !this.el.disabled
    }
    setIcon(t) {
        const e = !!t;
        !!this._iconEl != e && (e ? (this._iconEl = document.createElement("div"), this._iconEl.classList.add("dialog-button-icon"), this.el.insertBefore(this._iconEl, this.textEl), 1 != this._iconSize && (this._iconEl.style.transform = `scale(${this._iconSize})`)) : (this._iconEl && this.el.removeChild(this._iconEl), this._iconEl = null)), t && this._iconEl && (this._iconEl.style.backgroundImage = `url(${t})`), this._currentIcon = t
    }
    get icon() {
        return this._currentIcon
    }
    setText(t) {
        this.textEl.textContent = t
    }
}
class Ma {
    constructor({
                    allowCurtainClose: t = !0,
                    startVisible: e = !0,
                    needsCurtain: i = !0,
                    extraClasses: n = [],
                    testLabel: s = "",
                    indexPriority: r = 0,
                    needsWrapper: o = !1,
                    title: a = null
                } = {}) {
        var l;
        this.allowCurtainClose = t, this.needsCurtain = i, this.indexPriority = r, this.wrapperEl = null, o && (this.wrapperEl = document.createElement("div"), this.wrapperEl.classList.add("dialogWrapper"), document.body.appendChild(this.wrapperEl)), this.el = document.createElement("div"), this.el.classList.add("dialog", "wrinkledPaper", ...n), this.el.style.setProperty("--wrinkled-paper-seed", String(pa(1, 99999))), this._transitionVisible = !1, this.rootEl.addEventListener("transitionend", (t => {
            t.target == this.rootEl && "visibility" == t.propertyName && (this.rootEl.classList.contains("hidden") || (this._transitionVisible = !0))
        })), this.rootEl.classList.add("hidden"), o && this.wrapperEl ? this.wrapperEl.appendChild(this.el) : document.body.appendChild(this.el), e && (l = this.el, window.getComputedStyle(l).getPropertyValue("top"), this.rootEl.classList.remove("hidden")), a && (this.titleEl = document.createElement("h2"), this.titleEl.classList.add("dialogTitle", "blueNight"), this.titleEl.textContent = a, this.el.appendChild(this.titleEl)), this.startVisible = e, this._visible = e, this._inert = !1, this.onVisibilityChangeCbs = new Set, this.onInertChangeCbs = new Set, this.closed = !1, this.onCloseCbs = new Set
    }
    destructor() {
        this.wrapperEl ? document.body.removeChild(this.wrapperEl) : document.body.removeChild(this.el)
    }
    get rootEl() {
        return this.wrapperEl ? this.wrapperEl : this.el
    }
    setZIndex(t) {
        this.rootEl.style.zIndex = String(t)
    }
    setInert(t) {
        this._inert = t, this.rootEl.inert = t, this.onInertChangeCbs.forEach((e => e(t)))
    }
    get inert() {
        return this._inert
    }
    set visible(t) {
        this._visible = t, t || (this._transitionVisible = !1), this.rootEl.classList.toggle("hidden", !t);
        for (const e of this.onVisibilityChangeCbs) e(t);
        this.onVisibilityChange(t)
    }
    get visible() {
        return this._visible
    }
    get transitionVisible() {
        return this._transitionVisible
    }
    close() {
        if (!this.closed) {
            this.closed = !0, this.visible = !1;
            for (const t of this.onCloseCbs) t();
            this.onCloseCbs.clear(), this.onClose(), window.setTimeout((() => {
                this.destructor()
            }), 500)
        }
    }
    onVisibilityChange(t) {}
    onClose() {}
    addOnVisibilityChangeCb(t) {
        this.onVisibilityChangeCbs.add(t)
    }
    addOnInertChangeCb(t) {
        this.onInertChangeCbs.add(t)
    }
    addOnCloseCb(t) {
        this.onCloseCbs.add(t)
    }
    addButtonsContainer({
                            vertical: t = !1,
                            parent: e = this.el
                        } = {}) {
        this.buttonsContainer = document.createElement("div"), this.buttonsContainer.classList.add("dialogButtonsContainer"), this.buttonsContainer.classList.toggle("vertical", t), e.appendChild(this.buttonsContainer)
    }
    addButton(t) {
        const e = new Sa(t);
        let i = this.el;
        return this.buttonsContainer && (i = this.buttonsContainer), i.appendChild(e.el), e
    }
}
class Ca {
    constructor(t) {
        const {
            text: e,
            type: i
        } = t;
        if (this.type = i, this.el = document.createElement("div"), this.el.classList.add("settingsItem"), this.textEl = document.createElement("div"), this.el.appendChild(this.textEl), this.textEl.textContent = e, this.textEl.classList.add("settingsItemText"), this.onValueChangeCbs = new Set, "slider" == this.type) {
            this.inputContainer = document.createElement("div"), this.inputContainer.classList.add("settingsItemSlider"), this.el.appendChild(this.inputContainer), this.inputEl = document.createElement("input"), this.inputContainer.appendChild(this.inputEl), this.inputEl.type = "range", this.inputEl.min = String(t.min), this.inputEl.max = String(t.max), this.inputEl.step = String(t.step || 1), this.valueEl = document.createElement("div"), this.valueEl.classList.add("settingsItemSliderValue"), this.inputContainer.appendChild(this.valueEl), this.valueEl.textContent = this.inputEl.value;
            const e = this.valueEl,
                i = this.inputEl;
            this.inputEl.addEventListener("input", (t => {
                e.textContent = i.value;
                const n = Number(i.value);
                this.onValueChangeCbs.forEach((t => t(n)))
            }))
        } else if ("toggle" == this.type) {
            this.inputEl = document.createElement("input"), this.inputEl.type = "checkbox", this.inputEl.classList.add("dialog-checkbox-input", "wrinkledPaper"), this.el.appendChild(this.inputEl);
            const t = this.inputEl;
            this.inputEl.addEventListener("input", (() => {
                this.onValueChangeCbs.forEach((e => e(t.checked)))
            }))
        }
    }
    setValue(t) {
        if (!this.inputEl) throw new Error("Assertion failed, input element doesn't exist.");
        if ("slider" == this.type) {
            if ("number" != typeof t) throw new Error("Failed to set value of slider setting item: value is not a number");
            if (this.inputEl.value = String(t), !this.valueEl) throw new Error("Assertion failed, value element doesn't exist.");
            this.valueEl.textContent = this.inputEl.value
        } else "toggle" == this.type && "boolean" == typeof t && (this.inputEl.checked = t)
    }
    onValueChange(t) {
        this.onValueChangeCbs.add(t)
    }
    setDisabled(t) {
        this.inputEl && (this.inputEl.disabled = t)
    }
}
class _a extends Ma {
    constructor(t, e, i) {
        if (super(), this.settingsManager = t, this.dialogManager = e, this.titleEl = document.createElement("h2"), this.titleEl.classList.add("dialogTitle", "blueNight"), this.titleEl.textContent = "Settings", this.el.appendChild(this.titleEl), this.settings = new Map, this.settings.set("sfxVolume", new Ca({
            text: "Sound effects volume",
            type: "slider",
            min: 0,
            max: 100
        })), this.settings.set("musicVolume", new Ca({
            text: "Music volume",
            type: "slider",
            min: 0,
            max: 100
        })), this.settings.set("fov", new Ca({
            text: "Field of view",
            type: "slider",
            min: 40,
            max: 140
        })), this.settings.set("mouseSensitivity", new Ca({
            text: "Mouse sensitivity",
            type: "slider",
            min: .1,
            max: 5,
            step: .01
        })), this.settings.set("invertMouseY", new Ca({
            text: "Invert vertical mouse",
            type: "toggle"
        })), this.settings.set("mouseAcceleration", new Ca({
            text: "Mouse Acceleration",
            type: "toggle"
        })), this.settings.set("autoShoot", new Ca({
            text: "Auto shoot",
            type: "toggle"
        })), this.settings.set("walkHeadBob", new Ca({
            text: "Walk head bob",
            type: "toggle"
        })), this.settings.set("landHeadBob", new Ca({
            text: "Land head bob",
            type: "toggle"
        })), this.settings.set("hideUi", new Ca({
            text: "Hide in game UI",
            type: "toggle"
        })), this.settings.set("smoothCam", new Ca({
            text: "Smooth camera",
            type: "toggle"
        })), i.isAprilFirst) {
            const t = new Ca({
                text: "April Fools' Mode",
                type: "toggle"
            });
            t.el.style.transform = "scale(-1, 1)", this.settings.set("afFlipScreen", t)
        }
        this.settingsListEl = document.createElement("div"), this.settingsListEl.classList.add("settings-list"), this.el.appendChild(this.settingsListEl);
        for (const [e, i] of this.settings) {
            this.settingsListEl.appendChild(i.el);
            const n = t.getValue(e);
            i.setValue(n), i.onValueChange((i => {
                t.setValue(e, i)
            }))
        }
        this.addButtonsContainer(), this.addButton({
            text: "Save",
            onClick: async () => {
                await this.settingsManager.saveSettings() ? this.close() : this.dialogManager.showAlert({
                    title: "Settings could not be saved.",
                    text: "An error occurred while saving the settings. Are third party cookies disabled?"
                })
            }
        })
    }
}
const Ea = [{
        id: "scout",
        uiName: "Scout",
        weaponConfigWhenRunning: {
            posOffset: new w(-.3, -.1, -1.1),
            rotOffset: new w(-.6, 0, -1.3),
            posFovMultiplierX: .65,
            posFovMultiplierY: 1,
            minFov: 0,
            maxFov: 90
        },
        weaponConfigWhenLoading: {
            posOffset: new w(0, 0, -1.1),
            rotOffset: new w(0, 0, -.2),
            posFovMultiplierX: .65,
            valuesSmoothing: .4,
            minFov: 0,
            maxFov: 90
        },
        weaponConfigAfterLoad: {
            posOffset: new w(0, 0, -1.1),
            rotOffset: new w(0, 0, -.2),
            posFovMultiplierX: .65,
            minFov: 0,
            maxFov: 90
        },
        bowId: "smallBow",
        bowMorphOpts: {
            stringPullAmountTop: .12,
            stringPullAmountMiddle: .26,
            stringPullAmountBottom: .17
        },
        bowHandleShopCategories: ["smallBowHandle"],
        bowTipShopCategories: ["smallBowTip"],
        bowHandleShopCamPosition: "smallBowHandle",
        bowTipShopCamPosition: "smallBowTip",
        trailVisualOffset: new w(0, 0, .25),
        thirdPersonArmRotLookMultiplierMaleL: .3,
        thirdPersonArmRotLookMultiplierMaleR: .6,
        thirdPersonArmRotLookMultiplierFemaleL: .3,
        thirdPersonArmRotLookMultiplierFemaleR: .6,
        shootCooldownFromFireDownMs: 200,
        shootCooldownFromFireUpMs: 300,
        shootChargeDurationMs: 300,
        minAccuracy: 100,
        maxAccuracy: 100,
        walkSpeedMultiplier: 1,
        walkSpeedWhenLoadingMultiplier: .5,
        arrowDamageMultiplier: .6,
        arrowTravelDistanceMultiplier: .4,
        minShootCount: 1,
        maxShootCount: 3,
        pullSfxMinPitch: 1.3,
        pullSfxMaxPitch: 1.5,
        shootSfxMinPitch: 1,
        shootSfxMaxPitch: 1.1
    }, {
        id: "assault",
        uiName: "Assault",
        weaponConfigWhenRunning: {
            posOffset: new w(-.3, -.1, -1.1),
            rotOffset: new w(-.6, 0, -1.3),
            posFovMultiplierX: .55,
            posFovMultiplierY: 1,
            minFov: 0,
            maxFov: 90
        },
        weaponConfigWhenLoading: {
            posOffset: new w(0, 0, -1.1),
            rotOffset: new w(0, 0, -.2),
            posFovMultiplierX: .55,
            valuesSmoothing: .4,
            minFov: 0,
            maxFov: 90
        },
        weaponConfigAfterLoad: {
            posOffset: new w(0, 0, -1.1),
            rotOffset: new w(0, 0, -.2),
            posFovMultiplierX: .55,
            minFov: 0,
            maxFov: 90
        },
        bowId: "mediumBow",
        bowMorphOpts: {
            bendAmount: .2,
            stringDistFar: .7,
            stringPullAmountTop: .045,
            stringPullAmountMiddle: .53,
            stringPullAmountBottom: .135
        },
        bowHandleShopCategories: ["mediumBowHandle"],
        bowTipShopCategories: ["mediumBowTip"],
        bowHandleShopCamPosition: "mediumBowHandle",
        bowTipShopCamPosition: "mediumBowTip",
        trailVisualOffset: new w(0, 0, .25),
        thirdPersonArmRotLookMultiplierMaleL: 0,
        thirdPersonArmRotLookMultiplierMaleR: .6,
        thirdPersonArmRotLookMultiplierFemaleL: 0,
        thirdPersonArmRotLookMultiplierFemaleR: .6,
        shootCooldownFromFireDownMs: 10,
        shootChargeDurationMs: 10,
        minAccuracy: 0,
        maxAccuracy: 0,
        walkSpeedMultiplier: 1,
        walkSpeedWhenLoadingMultiplier: .3,
        jumpForceWhenLoadingMultiplier: .8,
        arrowDamageMultiplier: 10,
        arrowTravelDistanceMultiplier: 1,
        pullSfxMinPitch: .7,
        pullSfxMaxPitch: 1,
        shootSfxMinPitch: .9,
        shootSfxMaxPitch: 1
    }, {
        id: "sharpshooter",
        uiName: "Sharpshooter",
        weaponConfigWhenRunning: {
            posOffset: new w(-.3, -.1, -1.1),
            rotOffset: new w(-.6, 0, -1.3),
            walkBobMultiplier: .3,
            valuesSmoothing: .1,
            posFovMultiplierX: .55,
            posFovMultiplierY: 1,
            minFov: 20,
            maxFov: 90
        },
        weaponConfigWhenLoading: {
            posOffset: new w(0, 0, -1.1),
            rotOffset: new w(0, 0, -.2),
            walkBobMultiplier: .3,
            valuesSmoothing: .1,
            posFovMultiplierX: .55,
            minFov: 20,
            maxFov: 90
        },
        weaponConfigAfterLoad: {
            posOffset: new w(0, 0, -1.1),
            rotOffset: new w(0, 0, -.2),
            walkBobMultiplier: .3,
            valuesSmoothing: .1,
            posFovMultiplierX: .55,
            minFov: 20,
            maxFov: 90
        },
        bowId: "largeBow",
        bowMorphOpts: {
            stringPullAmountTop: .24,
            stringPullAmountMiddle: .53,
            stringPullAmountBottom: .25
        },
        bowHandleShopCategories: ["largeBowHandle"],
        bowTipShopCategories: ["largeBowTip"],
        bowHandleShopCamPosition: "largeBowHandle",
        bowTipShopCamPosition: "largeBowTip",
        trailVisualOffset: new w(0, 0, .25),
        trailThicknessMultiplier: 3,
        trailDurationMultiplier: 5,
        thirdPersonArmRotLookMultiplierMaleL: -.3,
        thirdPersonArmRotLookMultiplierMaleR: .6,
        thirdPersonArmRotLookMultiplierFemaleL: -.3,
        thirdPersonArmRotLookMultiplierFemaleR: .6,
        shootCooldownFromFireDownMs: 1200,
        shootChargeDurationMs: 1200,
        minAccuracy: 0,
        maxAccuracy: 10,
        walkSpeedMultiplier: .6,
        walkSpeedWhenLoadingMultiplier: .1,
        jumpForceWhenLoadingMultiplier: .8,
        arrowDamageMultiplier: 2,
        arrowTravelDistanceMultiplier: 3,
        useAbsoluteFov: !0,
        absoluteFovMinStat: 40,
        absoluteFovMaxStat: 10,
        pullSfx: "weapon/bow/pullHeavy",
        pullSfxMinPitch: .9,
        pullSfxMaxPitch: 1.1,
        shootSfx: "weapon/largeBow/shoot",
        shootSfxMinPitch: .9,
        shootSfxMaxPitch: 1.1
    }, {
        id: "runner",
        uiName: "Runner",
        weaponConfigWhenRunning: {
            posOffset: new w(-.3, .1, -1.1),
            rotOffset: new w(-.5, Math.PI / 2, 0),
            posFovMultiplierX: .2,
            posFovMultiplierY: 1,
            minFov: 0,
            maxFov: 90
        },
        weaponConfigWhenLoading: {
            posOffset: new w(0, -.4, -1.1),
            rotOffset: new w(0, 0, .2),
            posFovMultiplierX: .4,
            valuesSmoothing: .4,
            minFov: 0,
            maxFov: 90
        },
        weaponConfigAfterLoad: {
            posOffset: new w(0, -.4, -1.1),
            rotOffset: new w(0, 0, .2),
            posFovMultiplierX: .4,
            minFov: 0,
            maxFov: 90
        },
        bowId: "smallCrossbow",
        bowMorphOpts: {
            stringDistNear: .02,
            stringDistFar: .2,
            stringPullAmountTop: 0,
            stringPullAmountMiddle: .09,
            stringPullAmountBottom: 0
        },
        bowHandleShopCategories: ["smallCrossbowHandle"],
        bowTipShopCategories: ["smallCrossbowTip"],
        bowHandleShopCamPosition: "smallCrossbowHandle",
        bowTipShopCamPosition: "smallCrossbowTip",
        trailVisualOffset: new w(0, -.12, .15),
        thirdPersonArmRotLookMultiplierMaleL: 0,
        thirdPersonArmRotLookMultiplierMaleR: .6,
        thirdPersonArmRotLookMultiplierFemaleL: 0,
        thirdPersonArmRotLookMultiplierFemaleR: .6,
        shootCooldownFromFireDownMs: 300,
        shootChargeDurationMs: 100,
        minAccuracy: 10,
        maxAccuracy: 40,
        walkSpeedMultiplier: 1.1,
        walkSpeedWhenLoadingMultiplier: .5,
        arrowDamageMultiplier: 1 / 3,
        arrowTravelDistanceMultiplier: .3,
        usePreloadWeaponSystem: !0,
        preloadAutoCompleteAmount01: 0,
        pullSfxMinPitch: 2,
        pullSfxMaxPitch: 3,
        shootSfx: "weapon/smallCrossbow/shoot",
        shootSfxMinPitch: .9,
        shootSfxMaxPitch: 1.1
    }, {
        id: "defender",
        uiName: "Defender",
        weaponConfigWhenRunning: {
            posOffset: new w(0, .2, -.7),
            rotOffset: new w(-.5, .4, 0),
            valuesSmoothing: .25,
            pitchHeightMultiplier: .1,
            posFovMultiplierX: .4,
            posFovMultiplierY: 1,
            minFov: 60,
            maxFov: 110
        },
        weaponConfigWhenLoading: {
            posOffset: new w(0, .3, -1),
            rotOffset: new w(-.5, .5, .3),
            valuesSmoothing: .25,
            pitchHeightMultiplier: .1,
            posFovMultiplierX: .1,
            posFovMultiplierY: 1,
            minFov: 60,
            maxFov: 110
        },
        weaponConfigAfterLoad: {
            posOffset: new w(0, -.1, -.5),
            rotOffset: new w(0, 0, 0),
            walkBobMultiplier: .1,
            valuesSmoothing: .25,
            pitchHeightMultiplier: .02,
            posFovMultiplierX: .1,
            posFovMultiplierY: .2,
            minFov: 70,
            maxFov: 90
        },
        bowId: "largeCrossbow",
        bowMorphOpts: {
            stringDistFar: .7,
            stringPullAmountTop: .12,
            stringPullAmountMiddle: .26,
            stringPullAmountBottom: .12
        },
        bowHandleShopCategories: ["largeCrossbowHandle"],
        bowTipShopCategories: ["largeCrossbowTip"],
        bowHandleShopCamPosition: "largeCrossbowHandle",
        bowTipShopCamPosition: "largeCrossbowTip",
        trailVisualOffset: new w(0, -.12, .05),
        thirdPersonArmRotLookMultiplierMaleL: 1.3,
        thirdPersonArmRotLookMultiplierMaleR: .6,
        thirdPersonArmRotLookMultiplierFemaleL: 1.3,
        thirdPersonArmRotLookMultiplierFemaleR: .6,
        shootCooldownFromFireDownMs: 500,
        shootChargeDurationMs: 800,
        minAccuracy: 0,
        maxAccuracy: 30,
        walkSpeedMultiplier: .8,
        walkSpeedWhenLoadingMultiplier: .05,
        jumpForceWhenLoadingMultiplier: 0,
        arrowDamageMultiplier: 2,
        arrowTravelDistanceMultiplier: 1,
        usePreloadWeaponSystem: !0,
        pullSfx: "weapon/bow/pullHeavy",
        pullSfxMinPitch: 1.3,
        pullSfxMaxPitch: 1.5,
        shootSfx: "weapon/largeCrossbow/shoot",
        shootSfxMinPitch: .9,
        shootSfxMaxPitch: 1.1
    }],
    Pa = new Map;
for (const t of Ea) Pa.set(t.id, t);

function Ta(t) {
    const e = Pa.get(t);
    if (!e) throw new Error(`No weapon config for class ${t}`);
    return e
}
class Aa {
    constructor(t) {
        this.isDownloading = !1, this.loaded = !1, this.url = t, this.arrayBuffer = null, this.fileLocations = [], this.onLoadCbs = [], this.onProgressCbs = [], this.lastProgressValue = 0, this.textureCache = {}
    }
    async startDownloading() {
        if (this.loaded) return;
        if (this.isDownloading) return await this.waitForLoad();
        this.isDownloading = !0;
        const t = await (e = this.url, i = t => {
            for (const e of this.onProgressCbs) e(t);
            this.lastProgressValue = t
        }, new Promise(((t, n) => {
            const s = new XMLHttpRequest;
            s.responseType = "blob", s.addEventListener("progress", (t => {
                if (i) {
                    let e = 0;
                    t.lengthComputable && (e = t.loaded / t.total), i(e)
                }
            })), s.onload = e => {
                200 == s.status || 0 == s.status ? t(s.response) : n()
            }, s.onerror = t => {
                n()
            }, s.open("GET", e, !0), s.send()
        })));
        var e, i;
        this.arrayBuffer = await new Response(t).arrayBuffer(), this.parseFilePositions(this.arrayBuffer), this.loaded = !0;
        for (const t of this.onLoadCbs) t();
        this.onLoadCbs = [], this.onProgressCbs = [], this.isDownloading = !1
    }
    parseFilePositions(t) {
        let e = 0;
        for (; e < t.byteLength;) {
            let i = new Uint32Array(t, e, 1)[0];
            const n = new Uint8Array(t, e + 4, i),
                s = new TextDecoder("utf-8").decode(n);
            i % 4 != 0 && (i = 4 * Math.ceil(i / 4));
            let r = new Uint32Array(t, e + 4 + i, 1)[0];
            this.fileLocations.push({
                path: s,
                start: e + 4 + i + 4,
                length: r
            }), r % 4 != 0 && (r = 4 * Math.ceil(r / 4)), e += 4 + i + 4 + r
        }
    }
    onLoad(t) {
        this.loaded ? t() : this.onLoadCbs.push(t)
    }
    onProgress(t) {
        this.loaded ? t(1) : this.onProgressCbs.push(t)
    }
    async waitForLoad() {
        if (this.loaded) return;
        const t = new Promise(((t, e) => {
            this.onLoad((() => {
                t()
            }))
        }));
        await t
    }
    async hasFile(t) {
        return this.loaded || await this.waitForLoad(), this.fileLocations.some((e => e.path == t))
    }
    async getFileAsBuffer(t) {
        if (this.loaded || await this.waitForLoad(), !this.arrayBuffer) throw new Error("Assertion failed, arrayBuffer not loaded");
        for (const e of this.fileLocations)
            if (e.path == t) return this.arrayBuffer.slice(e.start, e.start + e.length);
        throw new Error(`Trying to load asset at ${t} but it doesn't exist!`)
    }
    async getAsObjectUrl(t, e) {
        const i = await this.getFileAsBuffer(t);
        if (!i) return null;
        const n = new Blob([new Uint8Array(i)], {
            type: e
        });
        return URL.createObjectURL(n)
    }
    async getAsSvg(t) {
        return await this.getAsObjectUrl(t, "image/svg+xml")
    }
    async getAsText(t) {
        const e = await this.getFileAsBuffer(t),
            i = new Uint8Array(e);
        return new TextDecoder("utf-8").decode(i)
    }
    async getAsJSON(t) {
        const e = await this.getAsText(t);
        return JSON.parse(e)
    }
    async blobToArrayBuffer(t) {
        return await new Response(t).arrayBuffer()
    }
}
class La {
    constructor() {
        const t = ["main"];
        this.onPackageAddCbs = [], this.packages = {};
        for (const e of t) this.addPackage(e);
        this.worker = new Worker("assetLoaderWorker.js?v=" + VERSION_TIMESTAMP, {
            type: "module"
        }), this.worker.addEventListener("message", (t => {
            if (t.data.requestId > 0) {
                if (t.data.dataIsError) {
                    let e;
                    e = t.data.data.isAggregateError ? new AggregateError(t.data.data.errors, t.data.data.message) : t.data.data;
                    const i = this.onWorkerErrorCbs.get(t.data.requestId);
                    if (i)
                        for (const t of i) t(e)
                } else {
                    const e = this.onWorkerMessageCbs.get(t.data.requestId);
                    if (e)
                        for (const {
                            cb: i,
                            endOnly: n
                        }
                            of e) n && !t.data.end || i(t.data.data)
                }
                t.data.end && this.onWorkerMessageCbs.delete(t.data.requestId)
            } else {
                const e = t.data;
                if ("mapCached" == e.type) {
                    const {
                        mapHash: t
                    } = e.data;
                    uc().mapLoader.markMapAsCached(t)
                }
            }
        })), this.worker.addEventListener("error", (t => {
            throw console.error("error occurred while initializing asset loader worker"), t
        })), this.lastWorkerRequestId = 0, this.onWorkerMessageCbs = new Map, this.onWorkerErrorCbs = new Map;
        let e = location.pathname;
        if (!e.endsWith("/")) {
            const t = e.lastIndexOf("/");
            e = e.substring(0, t + 1)
        }
        this.sendWorkerRequest("basePath", {
            basePath: location.origin + e
        })
    }
    addPackage(t, {
        waitForOtherPackages: e = null,
        expectedOtherPackageCount: i = 1,
        manualDownload: n = !1
    } = {}) {
        let s = null;
        if (t in this.packages) s = this.packages[t];
        else {
            s = new Aa("packages/" + t + ".bin?v=" + VERSION_TIMESTAMP), this.packages[t] = s;
            for (const t of this.onPackageAddCbs) t();
            this.onPackageAddCbs = []
        }
        return n || this.waitAndDownloadPack(s, e, i), s
    }
    async waitAndDownloadPack(t, e, i) {
        if (e)
            for (;;) {
                const n = [];
                for (const [i, s] of Object.entries(this.packages))
                    for (const r of e) i.startsWith(r) && s != t && n.push(s);
                if (!(n.length < i)) {
                    for (const t of n) await t.waitForLoad();
                    break
                }
                await this.waitForPackageAdd()
            }
        t.startDownloading()
    }
    async waitForPackageAdd() {
        const t = new Promise((t => this.onPackageAddCbs.push(t)));
        await t
    }
    getPackage(t) {
        return this.packages[t]
    }
    async getPackageAsync(t) {
        for (;;) {
            const e = this.packages[t];
            if (e) return e;
            await this.waitForPackageAdd()
        }
    }
    async sendWorkerRequest(t, e, {
        responseCb: i = null,
        signal: n = null
    } = {}) {
        const s = this.lastWorkerRequestId++;
        if (n) {
            if (n.aborted) throw new DOMException("Worker request has been aborted", "AbortError");
            n.addEventListener("abort", (() => {
                this.worker.postMessage({
                    type: "abortRequest",
                    data: {
                        requestId: s
                    },
                    requestId: -1
                })
            }))
        }
        i && this.onWorkerMessage(s, i);
        const r = !!n,
            o = new Promise(((t, e) => {
                this.onWorkerMessage(s, t, !0), this.onWorkerError(s, (t => {
                    e(t)
                }))
            }));
        return this.worker.postMessage({
            type: t,
            data: e,
            requestId: s,
            hasAbortSignal: r
        }), await o
    }
    onWorkerMessage(t, e, i = !1) {
        let n = this.onWorkerMessageCbs.get(t);
        n || (n = new Set, this.onWorkerMessageCbs.set(t, n)), n.add({
            cb: e,
            endOnly: i
        })
    }
    onWorkerError(t, e) {
        let i = this.onWorkerErrorCbs.get(t);
        i || (i = new Set, this.onWorkerErrorCbs.set(t, i)), i.add(e)
    }
    static deserializeThreeObject(t) {
        if (!t) return null;
        const e = [];
        for (const i of t.geometries) {
            const t = new ae;
            for (const e of i.attributes) t.setAttribute(e.name, new Xt(e.array, e.itemSize, e.normalized));
            i.index && t.setIndex(new Xt(i.index.array, 1));
            for (const {
                start: e,
                count: n,
                materialIndex: s
            }
                of i.groups) t.addGroup(e, n, s);
            e.push(t)
        }
        const i = this.deserializeThreeObjectRecursive(t.object, e);
        return i.updateWorldMatrix(!1, !0), i
    }
    static deserializeThreeObjectRecursive(t, e) {
        let i = null;
        const n = uc().materials;
        if (null != t.geo && t.geo >= 0) {
            let s = null;
            if (Array.isArray(t.material)) {
                s = [];
                for (const e of t.material) {
                    const t = n.getMaterialByName(e);
                    t && s.push(t)
                }
            } else t.material && (s = uc().materials.getMaterialByName(t.material) || null);
            s && (i = new _e(e[t.geo], s))
        }
        i || (i = new xt), i.name = t.name;
        const s = (new $).fromArray(t.matrix);
        i.applyMatrix4(s);
        for (const n of t.children) {
            const t = this.deserializeThreeObjectRecursive(n, e);
            i.add(t)
        }
        return i
    }
    async loadGlbViaWorker(t, {
        packageName: e = "main",
        teamId: i = 0,
        keepCustomProperties: n = [],
        merge: s = !0,
        signal: r = null
    } = {}) {
        const o = await uc().assets.getPackage(e).getFileAsBuffer(t),
            a = await uc().assets.sendWorkerRequest("loadGlbAsset", {
                glbBuffer: o,
                teamId: i,
                keepCustomProperties: n,
                merge: s
            }, {
                signal: r
            });
        return La.deserializeThreeObject(a)
    }
}
const ka = [{
    name: "torso"
}, {
    name: "head"
}, {
    name: "quiver"
}, {
    name: "lowerArm",
    needsFlip: !0
}, {
    name: "upperArm",
    needsFlip: !0
}, {
    name: "handArm",
    needsFlip: !0
}, {
    name: "upperLeg",
    needsFlip: !0
}, {
    name: "lowerLeg",
    needsFlip: !0
}, {
    name: "footLeg",
    needsFlip: !0
}];
ka.map((t => t.name)), ka.filter((t => t.needsFlip)).map((t => t.name));
const Ia = [];
for (const t of ka) t.needsFlip ? (Ia.push(t.name + "L"), Ia.push(t.name + "R")) : Ia.push(t.name);
const Ra = ["base", "baseClothes", "baseEyes"],
    Da = ["male", "female"],
    Oa = [{
        cssColor: "#fff6ed",
        skinColor: [1, 1, 1]
    }, {
        cssColor: "#c05f18",
        skinColor: [.45, .15, 0]
    }, {
        cssColor: "#362c29",
        skinColor: [.04, .03, .025]
    }, {
        cssColor: "#794b32",
        skinColor: [.15, .08, .05]
    }, {
        cssColor: "#feed9a",
        skinColor: [.95, .83, .4]
    }];

function Fa(t) {
    let e;
    try {
        e = JSON.parse(t)
    } catch {
        e = {}
    }
    return Na(e)
}

function Na(t = null) {
    if ("object" != typeof t || Array.isArray(t) || null == t) return {
        equippedSkinIds: [],
        hairColorMultiplier: [1, 1, 1],
        eyebrowColorMultiplier: [1, 1, 1],
        beardColorMultiplier: [1, 1, 1]
    };
    t.equippedSkinIds && Array.isArray(t.equippedSkinIds) || (t.equippedSkinIds = []);
    for (const [e, i] of t.equippedSkinIds.entries()) "string" != typeof i && (t.equippedSkinIds[e] = "");
    return t.equippedSkinIds = t.equippedSkinIds.filter((t => "" != t)), t.hairColorMultiplier && (t.hairColorMultiplier = Ba(t.hairColorMultiplier)), t.eyebrowColorMultiplier && (t.eyebrowColorMultiplier = Ba(t.eyebrowColorMultiplier)), t.beardColorMultiplier && (t.beardColorMultiplier = Ba(t.beardColorMultiplier)), t
}

function Ba(t) {
    if (!Array.isArray(t)) return [1, 1, 1];
    if (3 != t.length) return [1, 1, 1];
    for (const e of t.keys()) "number" != typeof t[e] && (t[e] = 1), t[e] = ua(t[e]), isNaN(t[e]) && (t[e] = 1);
    return t
}
class Va {
    constructor() {
        this.purchasableItems = new Map, this.defaultSkinPresets = [], this.skinPresets = [], this.classSkins = {}, this.onSkinConfigChangeCbs = new Set
    }
    init() {
        this.initBaseSkins(), uc().config.shopConfig.onConfigChange((async t => {
            for (const e of t.purchasableItems)
                if (this.purchasableItems.set(e.id, e), !e.slots || !Array.isArray(e.slots)) {
                    if (e.slots = [], e.maleSkin) {
                        if (e.maleSkin.additions)
                            for (const t of Object.keys(e.maleSkin.additions)) e.slots.push(t);
                        if (e.maleSkin.removals)
                            for (const t of Object.keys(e.maleSkin.removals)) e.slots.push(t)
                    }
                    if (e.femaleSkin) {
                        if (e.femaleSkin.additions)
                            for (const t of Object.keys(e.femaleSkin.additions)) e.slots.push(t);
                        if (e.femaleSkin.removals)
                            for (const t of Object.keys(e.femaleSkin.removals)) e.slots.push(t)
                    }
                } this.defaultSkinPresets = t.skinPresets || [];
            const e = await this.loadSkinPreference("skinPresets");
            e && (this.skinPresets = e);
            const i = await this.loadSkinPreference("classSkins");
            i && (this.classSkins = i), 0 == this.skinPresets.length && this.addPreset({
                fireConfigChanged: !1
            }), this.fireConfigChanged()
        }))
    }
    async loadSkinPreference(t) {
        let e = null;
        try {
            e = await uc().indexedDb.get(t)
        } catch (t) {
            console.error("Unable to load skin preference from indexDB:", t)
        }
        return e
    }
    async loadSkinIdsPreference(t) {
        const e = await this.loadSkinPreference(t);
        let i = new Set;
        if (e && "string" == typeof e) {
            const t = e.split(",");
            i = new Set(t)
        }
        return i
    }
    async initBaseSkins() {
        const t = [],
            e = [];
        for (const t of Da)
            for (const i of Ra) e.push(`baseSkins/${t}/${i}.glb`);
        for (const {
            bowId: t
        }
            of Ea) e.push(`bows/${t}.glb`);
        const i = {};
        for (const n of e) {
            const e = (async () => {
                i[n] = await uc().assets.getPackage("main").getFileAsBuffer(n)
            })();
            t.push(e)
        }
        await Promise.all(t), await uc().assets.sendWorkerRequest("baseSkinAssetBuffers", {
            skinBuffers: i
        })
    }
    skinObjectOptsToCacheKey(t) {
        const e = [];
        e.push(t.teamId), t.teamColor ? (e.push(t.teamColor.r), e.push(t.teamColor.g), e.push(t.teamColor.b)) : e.push("teamColorEmpty"), e.push("skinstart");
        const i = t.skin.equippedSkinIds || [];
        e.push(i.join("|")), e.push("skinend"), e.push(t.skin.gender || "male");
        const n = t.skin.hairColorMultiplier || [1, 1, 1];
        e.push("hairColor" + n.join(","));
        const s = t.skin.eyebrowColorMultiplier || [1, 1, 1];
        e.push("eyebrowColor" + s.join(","));
        const r = t.skin.beardColorMultiplier || [1, 1, 1];
        return e.push("beardColor" + r.join(",")), e.join("-")
    }
    async getSkinObject(t, e) {
        let i, n = !1;
        t.rawSkin ? (i = t.rawSkin, n = !0) : i = this.skinNetworkDataToSkinConfig(t.skin);
        let s = null;
        const r = [];
        try {
            s = await uc().assets.sendWorkerRequest("buildSkin", {
                skin: i,
                teamId: t.teamId,
                teamColor: t.teamColor,
                allowNetworkErrors: n
            }, {
                signal: e
            })
        } catch (t) {
            if (t instanceof DOMException && "AbortError" == t.name) throw t;
            r.push(t)
        }
        if (e.aborted) throw new DOMException("Request aborted by signal.", "AbortError");
        if (!s && !n) {
            const i = this.skinNetworkDataToSkinConfig({
                gender: t.skin.gender
            });
            try {
                s = await uc().assets.sendWorkerRequest("buildSkin", {
                    skin: i,
                    teamId: t.teamId,
                    teamColor: t.teamColor,
                    allowNetworkErrors: !1
                }, {
                    signal: e
                })
            } catch (t) {
                if (t instanceof DOMException && "AbortError" == t.name) throw t;
                throw r.push(t), new AggregateError(r)
            }
        }
        if (!s) return null;
        return La.deserializeThreeObject(s)
    }
    async getBowObject(t, e) {
        const i = await uc().assets.sendWorkerRequest("buildBow", t, {
                signal: e
            }),
            {
                bow: n,
                arrowPointIdleMatrix: s,
                arrowPointLoadedMatrix: r
            } = i;
        return {
            bow: La.deserializeThreeObject(n),
            arrowPointIdleMatrix: (new $).fromArray(s),
            arrowPointLoadedMatrix: (new $).fromArray(r)
        }
    }
    addShopItemToSkinData(t, e) {
        const i = new Set(e.equippedSkinIds),
            n = this.addItemAndRemoveDuplicateSlots(i, t);
        return e.equippedSkinIds = Array.from(i), n
    }
    removeShopItemFromSkinData(t, e) {
        const i = new Set(e.equippedSkinIds);
        i.delete(t), e.equippedSkinIds = Array.from(i)
    }
    addPreset({
                  fireConfigChanged: t = !0
              } = {}) {
        let e = fa(this.defaultSkinPresets);
        e || (e = {});
        const i = e.equippedSkinIds || [],
            n = {
                gender: e.gender || "male",
                equippedSkinIds: [...i]
            };
        e.hairColorMultiplier && (n.hairColorMultiplier = [...e.hairColorMultiplier]), e.eyebrowColorMultiplier && (n.eyebrowColorMultiplier = [...e.eyebrowColorMultiplier]), e.beardColorMultiplier && (n.beardColorMultiplier = [...e.beardColorMultiplier]), this.skinPresets.push(n), this.savePresets(), t && this.fireConfigChanged()
    }
    deletePreset(t) {
        if (t < 0 || t >= this.skinPresets.length) throw new Error("Invalid preset index");
        this.skinPresets.splice(t, 1);
        for (const e of Object.values(this.classSkins)) null != e.presetId && (e.presetId == t ? delete e.presetId : e.presetId > t && e.presetId--);
        this.savePresets(), this.saveClassSkins(), this.fireConfigChanged()
    }
    getPreset(t) {
        const e = this.skinPresets[t];
        if (!e) throw new Error(`Preset ${t} does not exist`);
        return e
    }
    addShopItemToPreset(t, e) {
        const i = this.getPreset(e),
            n = this.addShopItemToSkinData(t, i);
        return this.savePresets(), this.fireConfigChanged(), n
    }
    removeShopItemFromPreset(t, e) {
        const i = this.getPreset(e);
        if (!i) throw new Error(`Preset with id ${e} does not exist`);
        this.removeShopItemFromSkinData(t, i), this.savePresets(), this.fireConfigChanged()
    }
    setPresetGender(t, e) {
        this.getPreset(t).gender = e, this.savePresets(), this.fireConfigChanged()
    }
    setPresetSkinItemColor(t, e, i) {
        const n = this.getPreset(t);
        "hair" == e ? n.hairColorMultiplier = i : "eyebrows" == e ? n.eyebrowColorMultiplier = i : "beard" == e && (n.beardColorMultiplier = i), this.savePresets(), this.fireConfigChanged()
    }
    savePresets() {
        uc().indexedDb.set("skinPresets", this.skinPresets)
    }
    getClassSkinData(t, e) {
        let i = this.classSkins[t];
        return i || (i = {}, this.skinPresets.length > 0 && (i.presetId = 0), e && (this.classSkins[t] = i)), i
    }
    getClassSkinDataWithAppliedPreset(t) {
        const e = this.getClassSkinData(t, !1);
        let i;
        i = null != e.presetId ? this.getPreset(e.presetId) : {};
        const n = new Set(i.equippedSkinIds);
        if (e.equippedSkinIds)
            for (const t of e.equippedSkinIds) this.addItemAndRemoveDuplicateSlots(n, t);
        if (e.unequippedSkinIds)
            for (const t of e.unequippedSkinIds) n.delete(t);
        return {
            gender: e.gender || i.gender,
            equippedSkinIds: Array.from(n),
            hairColorMultiplier: e.hairColorMultiplier || i.hairColorMultiplier,
            eyebrowColorMultiplier: e.eyebrowColorMultiplier || i.eyebrowColorMultiplier,
            beardColorMultiplier: e.beardColorMultiplier || i.beardColorMultiplier
        }
    }
    setClassPreset(t, e) {
        const i = this.getClassSkinData(t, !0);
        delete i.equippedSkinIds, delete i.unequippedSkinIds, delete i.gender, delete i.hairColorMultiplier, delete i.eyebrowColorMultiplier, delete i.beardColorMultiplier, null == e ? delete i.presetId : i.presetId = e, this.saveClassSkins(), this.fireConfigChanged()
    }
    addShopItemToClass(t, e) {
        const i = this.getClassSkinData(e, !0),
            n = new Set(i.unequippedSkinIds);
        n.delete(t), 0 == n.size ? delete i.unequippedSkinIds : i.unequippedSkinIds = Array.from(n);
        let s = !1;
        if (null != i.presetId) {
            const e = this.getPreset(i.presetId);
            e.equippedSkinIds && e.equippedSkinIds.includes(t) && (s = !0)
        }
        this.addShopItemToSkinData(t, i), s && this.removeShopItemFromSkinData(t, i), this.saveClassSkins(), this.fireConfigChanged()
    }
    removeShopItemFromClass(t, e) {
        const i = this.getClassSkinData(e, !0);
        let n = !1;
        if (null != i.presetId) {
            const e = this.getPreset(i.presetId);
            e.equippedSkinIds && e.equippedSkinIds.includes(t) && (n = !0)
        }
        if (this.removeShopItemFromSkinData(t, i), n) {
            const e = new Set(i.unequippedSkinIds);
            e.add(t), i.unequippedSkinIds = Array.from(e)
        }
        this.saveClassSkins(), this.fireConfigChanged()
    }
    setClassGender(t, e) {
        const i = this.getClassSkinData(t, !0);
        let n = "male";
        if (null != i.presetId) {
            n = this.getPreset(i.presetId).gender || "male"
        }
        e == n ? delete i.gender : i.gender = e, this.saveClassSkins(), this.fireConfigChanged()
    }
    setClassSkinItemColor(t, e, i) {
        const n = this.getClassSkinData(t, !0);
        let s = null;
        null != n.presetId && (s = this.getPreset(n.presetId));
        const r = s;

        function o(t) {
            n[t] = i;
            let e = [1, 1, 1];
            if (r) {
                const i = r[t];
                i && (e = i)
            }
            Math.abs(i[0] - e[0]) < .01 && Math.abs(i[1] - e[1]) < .01 && Math.abs(i[2] - e[2]) < .01 && delete n[t]
        }
        "hair" == e ? o("hairColorMultiplier") : "eyebrows" == e ? o("eyebrowColorMultiplier") : "beard" == e && o("beardColorMultiplier"), this.saveClassSkins(), this.fireConfigChanged()
    }
    saveClassSkins() {
        uc().indexedDb.set("classSkins", this.classSkins)
    }
    fireConfigChanged() {
        for (const t of this.onSkinConfigChangeCbs) t()
    }
    addItemAndRemoveDuplicateSlots(t, e) {
        const i = new Set,
            n = this.purchasableItems.get(e);
        if (n && (e && t.add(e), n.slots))
            for (const s of n.slots)
                for (const n of t) {
                    if (n == e) continue;
                    const r = this.purchasableItems.get(n);
                    r && r.slots && r.slots.includes(s) && (t.delete(n), i.add(n))
                }
        return i
    }
    getStatClassValuesFromShopSkinIds(t) {
        const e = new Map;
        for (const i of t) {
            const t = this.purchasableItems.get(i);
            if (t && t.statClasses)
                for (const [i, n] of Object.entries(t.statClasses)) {
                    let t = e.get(i);
                    t || (t = 0), t += n, e.set(i, t)
                }
        }
        return e
    }
    skinNetworkDataToSkinConfig(t) {
        const e = t.gender || "male",
            i = new Map;
        for (const t of Ia) {
            let n = i.get(t);
            n || (n = new Set, i.set(t, n));
            for (const t of Ra) n.add(`${e}/${t}`)
        }
        const n = [];
        if (t.equippedSkinIds) {
            for (const s of t.equippedSkinIds) {
                const r = this.purchasableItems.get(s);
                if (!r) continue;
                const o = this.getSkinFromShopItem(r, e);
                if (o && o.additions)
                    for (const [e, s] of Object.entries(o.additions)) {
                        const o = e;
                        if (s && Array.isArray(s)) {
                            let e = i.get(o);
                            e || (e = new Set, i.set(o, e));
                            for (const i of s)
                                if (e.add(i), r.colorizableCategory) {
                                    let e;
                                    "hair" == r.colorizableCategory ? e = t.hairColorMultiplier : "eyebrows" == r.colorizableCategory ? e = t.eyebrowColorMultiplier : "beard" == r.colorizableCategory && (e = t.beardColorMultiplier), e && n.push({
                                        assetName: i,
                                        colorMultiplier: e,
                                        joints: [o]
                                    })
                                }
                        }
                    }
            }
            for (const n of t.equippedSkinIds) {
                const t = this.purchasableItems.get(n);
                if (!t) continue;
                const s = this.getSkinFromShopItem(t, e);
                if (s && s.removals)
                    for (const [t, n] of Object.entries(s.removals)) {
                        const s = t;
                        if (n && Array.isArray(n)) {
                            const t = i.get(s);
                            if (t)
                                for (const i of n) Ra.includes(i) ? t.delete(`${e}/${i}`) : t.delete(i)
                        }
                    }
            }
            for (const n of t.equippedSkinIds) {
                const t = this.purchasableItems.get(n);
                if (!t) continue;
                const s = this.getSkinFromShopItem(t, e);
                if (s && s.replaceAssets)
                    for (const t of s.replaceAssets)
                        for (const n of i.values()) {
                            const i = [t.asset, `${e}/${t.asset}`];
                            for (const e of i) n.has(e) && (n.delete(e), n.add(t.replaceWith))
                        }
            }
        }
        const s = {};
        for (const [t, e] of i) {
            const i = Array.from(e);
            i.length > 0 && (s[t] = i)
        }
        return {
            equippedItems: s,
            colorizedItems: n
        }
    }
    skinNetworkDataToBowAssetNames(t, e) {
        const i = new Set;
        if (e.equippedSkinIds)
            for (const n of e.equippedSkinIds) {
                const e = this.purchasableItems.get(n);
                if (e && e.bowSkin) {
                    if (t && e.bowSkin.bowId != t) continue;
                    for (const t of e.bowSkin.skins) i.add(t)
                }
            }
        return Array.from(i)
    }
    getSkinFromShopItem(t, e) {
        let i;
        return "male" == e ? i = t.maleSkin : "female" == e && (i = t.femaleSkin), i || null
    }
    getConfigForPreviewShopItemId(t, {
        itemId: e,
        colorCategory: i,
        colorMultiplier: n
    }) {
        const s = new Set(t.equippedSkinIds);
        e && this.addItemAndRemoveDuplicateSlots(s, e);
        const r = {
            gender: t.gender,
            equippedSkinIds: Array.from(s),
            beardColorMultiplier: t.beardColorMultiplier,
            hairColorMultiplier: t.hairColorMultiplier,
            eyebrowColorMultiplier: t.eyebrowColorMultiplier
        };
        return i && n && ("hair" == i ? r.hairColorMultiplier = n : "eyebrows" == i ? r.eyebrowColorMultiplier = n : "beard" == i && (r.beardColorMultiplier = n)), r
    }
    onSkinConfigChange(t) {
        this.onSkinConfigChangeCbs.add(t)
    }
    removeOnSkinConfigChange(t) {
        this.onSkinConfigChangeCbs.delete(t)
    }
}
class Ua {
    constructor({
                    extraClasses: t = []
                } = {}) {
        this.el = document.createElement("div"), this.el.classList.add("paged-view-container", ...t), this.createdPageEls = [], this.rootStructure = null
    }
    setActiveStructure(t) {
        this.rootStructure = t, this.createAndPushPage(t)
    }
    createAndPushPage(t) {
        const e = document.createElement("div");
        if (e.classList.add("paged-view-page"), t.headerVisible || void 0 === t.headerVisible) {
            const i = document.createElement("div");
            i.classList.add("paged-view-page-header", "blueNight"), e.appendChild(i);
            const n = document.createElement("div");
            n.classList.add("paged-view-page-header-line", "wrinkledLine"), e.appendChild(n);
            const s = t == this.rootStructure;
            if (!s || t.onBackButtonClick) {
                const e = new Sa({
                    ariaLabel: "Back",
                    isIconButton: !0,
                    icon: "img/arrow.svg",
                    extraClasses: ["header-button", "header-back-button"],
                    onClick: () => {
                        t.onBackButtonClick && t.onBackButtonClick(), s || this.popPage()
                    }
                });
                i.appendChild(e.el)
            }
            const r = document.createElement("h2");
            if (r.classList.add("paged-view-page-header-title"), r.textContent = t.header || t.itemName || "", i.appendChild(r), t.rightCorner) {
                const e = document.createElement("div");
                e.classList.add("paged-view-page-header-corner"), i.appendChild(e), t.rightCorner(e)
            }
        }
        if (t.subPages && t.customSubPage) throw new Error("Structures cannot have both subPages and customSubPage");
        if (t.customSubPageDestroyed && !t.customSubPage) throw new Error("customSubPageDestroyed is only supported when customSubPage is also provided");
        let i = null;
        const n = [];
        if (t.subPages) {
            const i = document.createElement("div");
            i.classList.add("paged-view-page-items-list"), e.appendChild(i);
            for (const e of t.subPages || []) {
                const t = new Sa({
                    icon: e.buttonIcon,
                    iconSize: e.buttonIconSize
                });
                t.setText(e.itemName || ""), t.onClick((() => {
                    this.createAndPushPage(e)
                })), i.appendChild(t.el), n.push({
                    button: t,
                    structure: e
                })
            }
        } else t.customSubPage && (i = document.createElement("div"), i.classList.add("paged-view-page-custom-subpage"), e.appendChild(i), t.customSubPage(i));
        this.el.appendChild(e), this.createdPageEls.push({
            el: e,
            structure: t,
            visible: !1,
            customSubPageEl: i,
            createdButtons: n
        }), e.classList.add("hiddenright", "hidden"), e.style.transition = "none", e.offsetWidth, e.style.transition = "", this.updatePageVisibilities(), this.updateButtonVisibilies()
    }
    popPage() {
        const t = this.createdPageEls.pop();
        t && (t.el.classList.add("hiddenright"), t.el.classList.add("hidden"), setTimeout((() => {
            this.el.removeChild(t.el);
            const e = t.structure;
            t.customSubPageEl && e.customSubPageDestroyed && e.customSubPageDestroyed(t.customSubPageEl)
        }), 1e3)), this.updatePageVisibilities()
    }
    updateButtonVisibilies() {
        const t = this.createdPageEls[this.createdPageEls.length - 1];
        if (t)
            for (const {
                button: e,
                structure: i
            }
                of t.createdButtons) {
                let t = !0;
                i.buttonVisible && !i.buttonVisible() && (t = !1), e.el.style.display = t ? "" : "none"
            }
    }
    jumpToSubPage(t) {
        if (!this.rootStructure) throw new Error("Failed to jump to subpage, no root structure set");
        const e = function t(e, i) {
            if (e === i) return [i];
            if (!i.subPages) return null;
            for (const n of i.subPages) {
                const s = t(e, n);
                if (s) return [i, ...s]
            }
            return null
        }(t, this.rootStructure);
        if (!e) throw new Error("Failed to jump to subpage, structure not found in the current root structure");
        const i = e.slice(1);
        for (; this.createdPageEls.length > 1;) this.popPage();
        for (const t of i) this.createAndPushPage(t)
    }
    updatePageVisibilities() {
        for (let t = 0; t < this.createdPageEls.length; t++) {
            const e = this.createdPageEls[t],
                i = e.visible,
                n = t >= this.createdPageEls.length - 1,
                s = e.el;
            if (s.classList.toggle("hiddenleft", !n), s.classList.toggle("hidden", !n), s.inert = !n, s.classList.remove("hiddenright"), i != n) {
                const t = e.structure;
                n && t.onBecomeVisible && t.onBecomeVisible()
            }
        }
    }
}
class za {
    constructor(t, e) {
        this.skeletonPath = t, this.skeletonObject = null, this.onSkeletonLoadCbs = new Set, this.onObjectLinksBuilt = new Set, this._currentGender = e, this.weight = 1, this.currentlyLoadingPoseAbortController = null, this.objectLinksBuilt = !1, this.objectLinks = [], this.reloadPose()
    }
    setGender(t) {
        this._currentGender = t, this.reloadPose()
    }
    async reloadPose() {
        if (this.currentlyLoadingPoseAbortController) {
            this.currentlyLoadingPoseAbortController.abort(), this.currentlyLoadingPoseAbortController = null;
            const t = new DOMException("Request aborted by signal.", "AbortError");
            for (const {
                reject: e
            }
                of this.onSkeletonLoadCbs) e(t);
            this.onSkeletonLoadCbs.clear()
        }
        this.objectLinksBuilt = !1, this.skeletonObject = null;
        const t = `${this._currentGender}/${this.skeletonPath}`,
            e = new AbortController;
        this.currentlyLoadingPoseAbortController = e;
        try {
            this.skeletonObject = await uc().skeletons.getSkeleton(t, {
                signal: this.currentlyLoadingPoseAbortController.signal
            })
        } catch (t) {
            t instanceof DOMException && t.name
        }
        if (!e.signal.aborted) {
            for (const {
                resolve: t
            }
                of this.onSkeletonLoadCbs) t();
            this.onSkeletonLoadCbs.clear()
        }
    }
    async waitForLoad() {
        if (this.skeletonObject) return;
        const t = new Promise(((t, e) => this.onSkeletonLoadCbs.add({
            resolve: t,
            reject: e
        })));
        await t
    }
    buildObjectLinks(t) {
        if (this.objectLinks = [], !this.skeletonObject) throw new Error("Cannot build object links before the skeleton object is loaded");
        for (const e of oa(this.skeletonObject)) {
            const i = t.getObjectByName(e.name);
            i && this.objectLinks.push([i, e])
        }
        this.objectLinksBuilt = !0, this.onObjectLinksBuilt.forEach((t => t())), this.onObjectLinksBuilt.clear()
    }
    async waitForObjectLinks() {
        if (this.objectLinksBuilt) return;
        const t = new Promise((t => this.onObjectLinksBuilt.add(t)));
        await t
    }
    apply() {
        if (0 != this.weight)
            if (1 == this.weight)
                for (const [t, e] of this.objectLinks) t.position.copy(e.position), t.quaternion.copy(e.quaternion), t.scale.copy(e.scale);
            else
                for (const [t, e] of this.objectLinks) t.position.lerp(e.position, this.weight), t.quaternion.slerp(e.quaternion, this.weight), t.scale.lerp(e.scale, this.weight)
    }
}
class Ha {
    constructor({
                    player: t = null,
                    init: e = !0,
                    gender: i = "male"
                } = {}) {
        this.player = t, this.isInit = !1, this.onInitCbs = new Set, this.onAllLinkLayerObjectsBuiltCbs = new Set, this._currentGender = i, this.poseLayers = [], this.shootingPose = null, this.shootingLoadedPose = null, this.currentWeaponPoseId = 0, this.armRotLookMultiplierL = .3, this.armRotLookMultiplierR = .6, this.skeletonMatrixObjects = [], this.baseSkeletonObject = null, this.headObj = null, this.bodyObj = null, this.armLObj = null, this.armRObj = null, this.legLObj = null, this.legRObj = null, this.initCalled = !1, e && this.init()
    }
    async init() {
        if (this.initCalled) return await this.waitForLoad();
        this.initCalled = !0, this.baseSkeletonObject = await uc().skeletons.getSkeleton("male/baseRig", {
            clone: !0
        }), this.addPoseLayer("baseRig");
        for (const [t, e] of Ia.entries()) {
            const i = this.baseSkeletonObject.getObjectByName(e);
            if (!i) throw new Error(`Assertion failed, skeleton does not have object with name ${e}`);
            this.skeletonMatrixObjects[t] = i
        }
        this.weaponObject = this.baseSkeletonObject.getObjectByName("bowHoldingPos"), this.headObj = this.baseSkeletonObject.getObjectByName("head"), this.bodyObj = this.baseSkeletonObject.getObjectByName("torso"), this.armLObj = this.baseSkeletonObject.getObjectByName("upperArmL"), this.armRObj = this.baseSkeletonObject.getObjectByName("upperArmR"), this.legLObj = this.baseSkeletonObject.getObjectByName("upperLegL"), this.legRObj = this.baseSkeletonObject.getObjectByName("upperLegR"), this.isInit = !0, this.updateWeaponPoses();
        for (const t of this.onInitCbs) t();
        this.onInitCbs.clear()
    }
    async waitForLoad() {
        if (this.isInit) return;
        const t = new Promise((t => this.onInitCbs.add(t)));
        await t
    }
    assertInit() {
        if (!this.isInit) throw new Error("PlayerSkeleton not initialized")
    }
    addPoseLayer(t, e = !0) {
        const i = new za(t, this._currentGender);
        return e && this.poseLayers.push(i), this.linkLayerObjects(i), i
    }
    removePoseLayer(t) {
        const e = this.poseLayers.indexOf(t);
        e >= 0 && this.poseLayers.splice(e, 1)
    }
    get gender() {
        return this._currentGender
    }
    setGender(t) {
        if (this._currentGender != t) {
            this._currentGender = t;
            for (const e of this.poseLayers) e.setGender(t), this.linkLayerObjects(e)
        }
    }
    async linkLayerObjects(t) {
        await this.waitForLoad();
        try {
            await t.waitForLoad()
        } catch (t) {
            if (t instanceof DOMException && "AbortError" == t.name) return
        }
        if (!this.baseSkeletonObject) throw new Error("Assertion failed, baseSkeletonObject not set");
        t.buildObjectLinks(this.baseSkeletonObject), this.allObjectLinksBuilt && (this.onAllLinkLayerObjectsBuiltCbs.forEach((t => t())), this.onAllLinkLayerObjectsBuiltCbs.clear())
    }
    get allObjectLinksBuilt() {
        for (const t of this.poseLayers)
            if (!t.objectLinksBuilt) return !1;
        return !0
    }
    async waitForLinkLayerObjects() {
        if (this.allObjectLinksBuilt) return;
        const t = new Promise((t => this.onAllLinkLayerObjectsBuiltCbs.add(t)));
        await t
    }
    replacePoseLayer(t, e) {
        const i = this.addPoseLayer(e, !1);
        return this.poseLayers[t] = i, i
    }
    async updateWeaponPoses() {
        if (!this.isInit) return;
        let t = 0;
        this.player && this.player.weapon && (t = this.player.weapon.weaponId);
        const e = Ea[t];
        if (!e) return;
        const i = e.bowId;
        "male" == this.gender ? (this.armRotLookMultiplierL = e.thirdPersonArmRotLookMultiplierMaleL, this.armRotLookMultiplierR = e.thirdPersonArmRotLookMultiplierMaleR) : "female" == this.gender && (this.armRotLookMultiplierL = e.thirdPersonArmRotLookMultiplierFemaleL, this.armRotLookMultiplierR = e.thirdPersonArmRotLookMultiplierFemaleR);
        const n = this.replacePoseLayer(1, i + "/running");
        this.shootingPose = this.replacePoseLayer(2, i + "/shooting"), this.shootingPose.weight = 0, this.shootingLoadedPose = this.replacePoseLayer(3, i + "/shootingLoaded"), this.shootingLoadedPose.weight = 0, await n.waitForObjectLinks(), await this.shootingPose.waitForObjectLinks(), await this.shootingLoadedPose.waitForObjectLinks()
    }
    loop(t, e) {
        this.assertInit();
        let i = 0;
        this.player && this.player.weapon && (i = this.player.weapon.fireAmount01);
        const n = i > 0;
        this.shootingPose && (n ? this.shootingPose.weight += .01 * e : this.shootingPose.weight -= .01 * e, this.shootingPose.weight = ua(this.shootingPose.weight)), this.shootingLoadedPose && (this.shootingLoadedPose.weight = i), this.applyLayers(), this.player && this.setLookRotY(-this.player.lookRot.y), this.player && (this.legLObj && (this.legLObj.rotation.x = .5 * Math.cos(this.player.legsMoveTForCos) * this.player.legsMoveAmount), this.legRObj && (this.legRObj.rotation.x = .5 * -Math.cos(this.player.legsMoveTForCos) * this.player.legsMoveAmount)), this.updateMatrices()
    }
    setLookRotY(t) {
        this.bodyObj && this.applyLookRotation(this.bodyObj, new w(1, 0, 0), .3 * t), this.headObj && this.applyLookRotation(this.headObj, new w(1, 0, 0), .3 * t), this.shootingPose && (this.armLObj && this.applyLookRotation(this.armLObj, new w(1, 0, 0), t * this.armRotLookMultiplierL * this.shootingPose.weight), this.armRObj && this.applyLookRotation(this.armRObj, new w(1, 0, 0), t * this.armRotLookMultiplierR * this.shootingPose.weight))
    }
    applyLookRotation(t, e, i) {
        if (!t) return;
        const n = t.getWorldQuaternion(new v);
        n.invert();
        const s = e;
        s.applyQuaternion(n);
        const r = new v;
        r.setFromAxisAngle(s, i), t.quaternion.multiply(r)
    }
    applyLayers() {
        this.assertInit();
        for (const t of this.poseLayers) t.apply()
    }
    updateMatrices() {
        this.assertInit(), this.baseSkeletonObject && this.baseSkeletonObject.updateWorldMatrix(!1, !0)
    }
    getMatrices() {
        return this.assertInit(), this.skeletonMatrixObjects.map((t => t.matrixWorld))
    }
}

function Ga(t, e) {
    const i = new Date(Date.now());
    return i.getUTCMonth() == e - 1 && (i.getUTCDate() == t && i.getUTCHours() >= 7 || i.getUTCDate() == t + 1 && i.getUTCHours() < 7)
}
class Wa {
    constructor() {
        this.materialsCache = new Map, this.extraMaterials = new Set, this.shadersHavePrecompiled = !1, this.hashes = "\n\t\t\t// Hash without Sine\n\t\t\t// MIT License...\n\t\t\t// Copyright (c)2014 David Hoskins.\n\t\t\tfloat hash13(vec3 p3)\n\t\t\t{\n\t\t\t\tp3  = fract(p3 * .1031);\n\t\t\t\tp3 += dot(p3, p3.yzx + 33.33);\n\t\t\t\treturn fract((p3.x + p3.y) * p3.z);\n\t\t\t}\n\t\t\tfloat hash12(vec2 p)\n\t\t\t{\n\t\t\t\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\t\t\t\tp3 += dot(p3, p3.yzx + 33.33);\n\t\t\t\treturn fract((p3.x + p3.y) * p3.z);\n\t\t\t}\n\t\t\tvec3 hash33(vec3 p3)\n\t\t\t{\n\t\t\t\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\t\t\t    p3 += dot(p3, p3.yxz+33.33);\n\t\t\t    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\t\t\t}\n\t\t", this.saturateColorFn = "\n\t\t\tvec3 saturateColor(vec3 rgb, float adjustment){\n\t\t\t\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\t\t\t\tvec3 intensity = vec3(dot(rgb, W));\n\t\t\t\treturn mix(intensity, rgb, adjustment);\n\t\t\t}\n\t\t", this.gradientNoiseFn = "\n\t\t\t// The MIT License\n\t\t\t// Copyright (c) 2013 Inigo Quilez\n\t\t\tfloat gradientNoise( in vec3 p )\n\t\t\t{\n\t\t\t    vec3 i = floor( p );\n\t\t\t    vec3 f = fract( p );\n\n\t\t\t\tvec3 u = f*f*(3.0-2.0*f);\n\n\t\t\t    return mix( mix( mix( dot( hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n\t\t\t                          dot( hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n\t\t\t                     mix( dot( hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n\t\t\t                          dot( hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n\t\t\t                mix( mix( dot( hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n\t\t\t                          dot( hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n\t\t\t                     mix( dot( hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n\t\t\t                          dot( hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n\t\t\t}\n\t\t"
    }
    init() {
        this.basicUnlitMat = this.createMaterial({
            name: "default"
        }), this.basicUnlitMatDouble = this.createMaterial({
            name: "defaultDouble",
            side: 2
        }), this.skyDomeMat = this.createMaterial({
            name: "skydome",
            fragmentShaderOpts: {
                modifyColFn: "\n\t\t\t\t\tcol = getFogcolor();\n\t\t\t\t"
            },
            fog: !1,
            needsFogColor: !0,
            needsModelPosVarying: !0,
            depthWrite: !1
        }), this.skyDomeMat.side = 1, this.lightsMat = this.createMaterial({
            name: "lights",
            fog: !1,
            applyWorldColor: !1,
            depthWrite: !1,
            depthTest: !0
        }), this.lightsMat.blending = 2, this.screenFlashMat = this.createMaterial({
            name: "screenFlash",
            fog: !1,
            applyWorldColor: !1,
            depthWrite: !1,
            depthTest: !1,
            uniforms: {
                vignetteAmount: {
                    value: 0
                },
                theta: {
                    value: 0
                },
                opacity: {
                    value: 0
                }
            },
            vertexShaderOpts: {
                useMvp: !1,
                needsUv: !0
            },
            fragmentShaderOpts: {
                needsUv: !0,
                extraVariables: "\n\t\t\t\t\tuniform float vignetteAmount;\n\t\t\t\t\tuniform float theta;\n\t\t\t\t\tuniform float opacity;\n\t\t\t\t",
                modifyColFn: "\n\t\t\t\t\tcol = vec3(1.0, 0.05, 0.05);\n\t\t\t\t\tfloat centerDist = length(vUv.xy - vec2(0.5));\n\t\t\t\t\talpha = mix(1.0, centerDist, vignetteAmount);\n\n\t\t\t\t\tvec2 rotatedUv = vUv.xy;\n\t\t\t\t\trotatedUv -= vec2(0.5);\n\t\t\t\t\trotatedUv = vec2(\n\t\t\t\t\t\trotatedUv.x * cos(theta) - rotatedUv.y * sin(theta),\n\t\t\t\t\t\trotatedUv.x * sin(theta) + rotatedUv.y * cos(theta)\n\t\t\t\t\t);\n\t\t\t\t\trotatedUv += vec2(0.5);\n\t\t\t\t\talpha *= rotatedUv.y;\n\t\t\t\t\talpha *= opacity;\n\t\t\t\t"
            }
        }), this.screenFlashMat.transparent = !0, this.snowMat = this.createMaterial({
            name: "snow",
            vertexShaderOpts: {
                modifyColFn: "\n\t\t\t\t\tvec3 deltaPos = cameraPosition - worldPos.xyz;\n\t\t\t\t\t// edge = 1.0 - dot(normal, normalize(deltaPos));\n\t\t\t\t\tcol = vec3(0.6, 0.7, 0.8);\n\n\t\t\t\t\tfloat edge = pow(1.0 - dot(normal, normalize(deltaPos)), 3.0);\n\t\t\t\t\tedge = clamp(edge, 0.0, 1.0);\n\t\t\t\t\tcol = mix(vec3(0.6, 0.7, 0.8), vec3(1.5,1.5,1.5), edge);\n\t\t\t\t"
            }
        });
        const t = {
            vertexShaderOpts: {
                extraVariables: "\n\t\t\t\t\tattribute float bowMorph;\n\t\t\t\t\tuniform float bowMorphAmount;\n\t\t\t\t",
                modifyWorldPosBeforeModelMatrixFn: "\n\t\t\t\t\tpos.z -= bowMorph * bowMorphAmount;\n\t\t\t\t"
            },
            uniforms: {
                bowMorphAmount: {
                    value: 0
                }
            }
        };
        this.bowMorph = this.createMaterial({
            ...t,
            name: "bowMorph"
        }), this.bowMorphDouble = this.createMaterial({
            ...t,
            name: "bowMorphDouble",
            side: 2
        });
        const e = Ga(11, 5);
        this.arrowTrailMat = this.createMaterial({
            name: "arrowTrail",
            vertexShaderOpts: {
                extraVariables: "\n\t\t\t\t\tattribute float arrowT;\n\t\t\t\t\tvarying float vArrowT;\n\t\t\t\t\tattribute vec3 linePoint;\n\t\t\t\t",
                modifyWorldPosFn: "\n\t\t\t\t\tfloat camDist = length(cameraPosition - pos.xyz);\n\t\t\t\t\tfloat requiredVectorLength = camDist * 0.001;\n\t\t\t\t\tfloat currentNormalLength = length(normal);\n\t\t\t\t\tfloat desiredNormalLength = max(requiredVectorLength, currentNormalLength);\n\t\t\t\t\tvec3 clampedNormal = normal * (desiredNormalLength / currentNormalLength);\n\t\t\t\t\tpos.xyz += clampedNormal;\n\t\t\t\t\tvArrowT = arrowT;\n\t\t\t\t"
            },
            fragmentShaderOpts: {
                extraVariables: "\n\t\t\t\t\tuniform float arrowPosT;\n\t\t\t\t\tuniform float arrowShootT;\n\t\t\t\t\tuniform vec3 shootStartPos;\n\t\t\t\t\tuniform float estimatedXLength;\n\t\t\t\t\tvarying float vArrowT;\n\t\t\t\t",
                modifyColFn: `\n\t\t\t\t\tfloat t = arrowPosT - vArrowT;\n\t\t\t\t\tfloat shootT = arrowShootT - vArrowT;\n\t\t\t\t\talpha = 1.0;\n\n\t\t\t\t\t// fade in at start of trail\n\t\t\t\t\talpha = min(alpha, 0.2 * t - 0.5);\n\n\t\t\t\t\t// fade out at end of trail\n\t\t\t\t\talpha = min(alpha, 1.0 - 3.0 * (shootT / estimatedXLength));\n\n\t\t\t\t\talpha = min(alpha, length(shootStartPos - worldPos.xyz));\n\n\t\t\t\t\talpha = min(alpha, length(cameraPosition - worldPos.xyz) - 0.3);\n\n\t\t\t\t\talpha *= 0.4;\n\n\t\t\t\t\t${e?"\n\t\t\t\t\t\tfloat dist = length(cameraPosition - worldPos.xyz);\n\t\t\t\t\t\tfloat rainbowDist = 1.0 - exp(-dist * 0.05);\n\t\t\t\t\t\tvec4 rainbow = .5+.5*cos(6.283185*(rainbowDist +vec4(0,1,-1,0)/3.));\n\t\t\t\t\t\trainbow = min(rainbow,2.-rainbow);\n\t\t\t\t\t\tcol = mix(rainbow.rgb, vec3(1.), 0.0);\n\t\t\t\t\t\talpha *= 3.0;\n\t\t\t\t\t":""}\n\t\t\t\t`
            },
            depthWrite: !1,
            uniforms: {
                arrowPosT: {
                    value: 0
                },
                arrowShootT: {
                    value: 0
                },
                shootStartPos: {
                    value: new w
                },
                estimatedXLength: {
                    value: 1
                }
            }
        }), this.arrowTrailMat.transparent = !0;
        const i = Ia.length,
            n = [];
        for (let t = 0; t < i; t++) n.push(new $);
        const s = [],
            r = [];
        for (let t = 0; t < 5; t++) s.push(0), r.push(new w);
        const o = {
            vertexShaderOpts: {
                extraVariables: `\n\t\t\t\t\tattribute float skinIndex;\n\t\t\t\t\tuniform mat4 skinMatrices[${i}];\n\t\t\t\t\tvarying vec3 vModelPos;\n\t\t\t\t`,
                modifyWorldPosBeforeModelMatrixFn: "\n\t\t\t\t\tpos = skinMatrices[int(skinIndex)] * pos;\n\t\t\t\t\tvModelPos = pos.xyz;\n\t\t\t\t"
            },
            fragmentShaderOpts: {
                extraVariables: "\n\t\t\t\t\tuniform float time;\n\t\t\t\t\tuniform float hitFlashTimes[5];\n\t\t\t\t\tuniform vec3 hitFlashPositions[5];\n\t\t\t\t\tvarying vec3 vModelPos;\n\t\t\t\t",
                modifyColFn: "\n\t\t\t\t\tfloat hitFlashAmount = 0.0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tfloat t = time - hitFlashTimes[i];\n\t\t\t\t\t\tt *= 0.002;\n\t\t\t\t\t\tfloat centerDist = length(vModelPos - hitFlashPositions[i]);\n\t\t\t\t\t\tfloat flash = 1.0 - (centerDist - t * 6.0) * 50.0;\n\t\t\t\t\t\tflash = clamp(flash, 0.0, 1.0);\n\t\t\t\t\t\tflash *= clamp(1.0 - t, 0.0, 1.0);\n\t\t\t\t\t\thitFlashAmount = mix(hitFlashAmount, 1.0, flash);\n\t\t\t\t\t}\n\t\t\t\t\thitFlashAmount = clamp(hitFlashAmount, 0.0, 1.0);\n\t\t\t\t\tcol = mix(col, vec3(1.0, 0.0, 0.0), hitFlashAmount);\n\t\t\t\t"
            },
            uniforms: {
                skinMatrices: {
                    value: n
                },
                time: {
                    value: 0
                },
                hitFlashTimes: {
                    value: s
                },
                hitFlashPositions: {
                    value: r
                }
            }
        };
        this.defaultMatSkinned = this.createMaterial({
            ...o,
            name: "defaultSkinned"
        }), this.defaultDoubleMatSkinned = this.createMaterial({
            ...o,
            name: "defaultDoubleSkinned",
            side: 2
        })
    }
    async precompileShaders() {
        if (this.shadersHavePrecompiled) return;
        const t = new ns,
            e = new Ge;
        e.setAttribute("color", new Xt(new Float32Array(16), 4));
        const i = new _e(e);
        t.add(i);
        const n = uc(),
            s = n.renderer.renderer;
        if (!s) return;
        const r = n.cam.cam;
        for (const e of this.materialsCache.values()) await uc().renderer.waitForFrameRender(), i.material = e, s.compile(t, r);
        this.shadersHavePrecompiled = !0
    }* allMaterials() {
        for (const t of this.materialsCache.values()) yield t;
        for (const t of this.extraMaterials) yield t
    }
    getMaterialByName(t) {
        return this.materialsCache.has(t) ? this.materialsCache.get(t) : this.basicUnlitMat
    }
    addCachedMaterial(t) {
        t.name ? this.materialsCache.set(t.name, t) : console.warn("material doesn't have a name!")
    }
    addExtraMaterial(t) {
        this.extraMaterials.add(t)
    }
    removeExtraMaterial(t) {
        this.extraMaterials.delete(t)
    }
    applyWeatherParams(t) {
        for (const e of this.allMaterials()) e.uniforms.colorMultiplier.value.copy(t.colorMultiplier), e.uniforms.colorAdder.value.copy(t.colorAdder), e.uniforms.saturation.value = t.saturation, e.uniforms.skyLowCol.value.copy(t.skyLowColor), e.uniforms.skyHighCol.value.copy(t.skyHighColor), e.uniforms.skyMidCol.value.copy(t.skyMidColor), e.uniforms.skyPower.value = t.skyPower, e.uniforms.fogAmount.value = t.fogAmount
    }
    buildVertexShader({
                          name: t = "",
                          extraVariables: e = "",
                          modifyWorldPosFn: i = "",
                          modifyWorldPosAfterColorFn: n = "",
                          modifyWorldPosBeforeModelMatrixFn: s = "",
                          modifyColFn: r = "",
                          extraFunctions: o = "",
                          fog: a = !0,
                          needsFogColor: l = !1,
                          applyWorldColor: h = !0,
                          useMvp: c = !0,
                          needsModelPosVarying: d = !1,
                          needsUv: u = !1
                      } = {}) {
        return `\n\t\t\t//vertex shader for ${t}\n\n\t\t\t${a?"#define FOG":""}\n\t\t\t${l?"#define NEEDS_FOG_COLOR":""}\n\t\t\t${h?"#define APPLY_WORLD_COLOR":""}\n\t\t\t${c?"#define USE_MVP":""}\n\t\t\t${d?"#define NEEDS_MODEL_POS_VARYING":""}\n\t\t\t${u?"#define NEEDS_UV":""}\n\n\t\t\t#define PI 3.141592653589793\n\n\t\t\tvarying vec3 vColor;\n\t\t\tvarying vec4 worldPos;\n\t\t\t#ifdef FOG\n\t\t\t\t#define NEEDS_FOG_COLOR\n\t\t\t#endif\n\t\t\t#ifdef NEEDS_FOG_COLOR\n\t\t\t\tvarying float skyColorLerpValue;\n\t\t\t#endif\n\t\t\t#ifdef NEEDS_MODEL_POS_VARYING\n\t\t\t\tvarying vec3 vModelPos;\n\t\t\t#endif\n\t\t\t#ifdef NEEDS_UV\n\t\t\t\tvarying vec2 vUv;\n\t\t\t#endif\n\n\t\t\tuniform float saturation;\n\t\t\tuniform vec3 colorMultiplier;\n\t\t\tuniform vec3 colorAdder;\n\n\t\t\tvarying vec2 vHighPrecisionZW;\n\n\t\t\t${e}\n\n\t\t\t${o}\n\n\t\t\tvec4 modifyWorldPos(vec4 pos){\n\t\t\t\t${i}\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\tvec4 modifyWorldPosAfterColor(vec4 pos){\n\t\t\t\t${n}\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\tvec4 modifyWorldPosBeforeModelMatrix(vec4 pos){\n\t\t\t\t${s}\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\tvec3 modifyCol(vec3 col){\n\t\t\t\t${r}\n\t\t\t\treturn col;\n\t\t\t}\n\n\t\t\t${this.saturateColorFn}\n\n\t\t\tvoid main(){\n\t\t\t\tvec3 modelPosition = vec3(position);\n\t\t\t\tworldPos = vec4(modelPosition, 1.0);\n\t\t\t\t#ifdef USE_INSTANCING\n\t\t\t\t\tworldPos = instanceMatrix * worldPos;\n\t\t\t\t#endif\n\t\t\t\tworldPos = modifyWorldPosBeforeModelMatrix(worldPos);\n\t\t\t\t#ifdef USE_MVP\n\t\t\t\t\tworldPos = modelMatrix * worldPos;\n\t\t\t\t#endif\n\t\t\t\tworldPos = modifyWorldPos(worldPos);\n\t\t\t\t#ifdef NEEDS_UV\n\t\t\t\t\tvUv = uv;\n\t\t\t\t#endif\n\t\t\t\tvec3 col = modifyCol(color.rgb);\n\t\t\t\t#ifdef APPLY_WORLD_COLOR\n\t\t\t\t\tcol = saturateColor(col, saturation);\n\t\t\t\t\tcol *= colorMultiplier;\n\t\t\t\t\tcol += colorAdder;\n\t\t\t\t#endif\n\t\t\t\tvColor = col;\n\n\t\t\t\t#ifdef NEEDS_FOG_COLOR\n\t\t\t\t\tvec3 deltaPos = cameraPosition - vec3(worldPos);\n\t\t\t\t\tfloat angle = dot(vec3(0.0,-1.0,0.0), normalize(deltaPos));\n\t\t\t\t\tangle = clamp(angle, -PI, PI);\n\t\t\t\t\tangle = acos(angle);\n\t\t\t\t\tskyColorLerpValue = 1.0 - angle / 1.57;\n\t\t\t\t#endif\n\t\t\t\t#ifdef NEEDS_MODEL_POS_VARYING\n\t\t\t\t\tvModelPos = position;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FOG\n\t\t\t\t#endif\n\n\t\t\t\tworldPos = modifyWorldPosAfterColor(worldPos);\n\n\t\t\t\t#ifdef USE_MVP\n\t\t\t\t\tvec4 modelViewPosition = viewMatrix * worldPos;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewPosition;\n\t\t\t\t#else\n\t\t\t\t\tgl_Position = worldPos;\n\t\t\t\t#endif\n\t\t\t}\n\t\t`
    }
    buildFragShader({
                        name: t = "",
                        extraVariables: e = "",
                        modifyColFn: i = "",
                        modifyTexColFn: n = "",
                        extraFunctions: s = "",
                        fog: r = !0,
                        needsFogColor: o = !1,
                        needsModelPosVarying: a = !1,
                        needsUv: l = !1
                    } = {}) {
        return `\n\t\t\t//fragment shader for ${t}\n\n\t\t\t${r?"#define FOG":""}\n\t\t\t${o?"#define NEEDS_FOG_COLOR":""}\n\t\t\t${a?"#define NEEDS_MODEL_POS_VARYING":""}\n\t\t\t${l?"#define NEEDS_UV":""}\n\n\t\t\tvarying vec3 vColor;\n\t\t\tvarying vec4 worldPos;\n\n\t\t\tuniform vec3 skyHighCol;\n\t\t\tuniform vec3 skyMidCol;\n\t\t\tuniform vec3 skyLowCol;\n\t\t\tuniform float skyPower;\n\t\t\t#ifdef FOG\n\t\t\t\tuniform float fogAmount;\n\t\t\t\tfloat fogLerpValue;\n\t\t\t\t#define NEEDS_FOG_COLOR\n\t\t\t#endif\n\t\t\t#ifdef NEEDS_FOG_COLOR\n\t\t\t\tvarying float skyColorLerpValue;\n\t\t\t#endif\n\t\t\t#ifdef NEEDS_MODEL_POS_VARYING\n\t\t\t\tvarying vec3 vModelPos;\n\t\t\t#endif\n\t\t\t#ifdef NEEDS_UV\n\t\t\t\tvarying vec2 vUv;\n\t\t\t#endif\n\n\t\t\tfloat alpha = 1.0;\n\n\t\t\t#include <packing>\n\t\t\tvarying vec2 vHighPrecisionZW;\n\n\t\t\t${e}\n\n\t\t\t#ifdef NEEDS_FOG_COLOR\n\t\t\t\tvec3 getFogcolor(){\n\t\t\t\t\tfloat absLerpValue = abs(skyColorLerpValue);\n\t\t\t\t\tfloat lerpValue = pow(max(0.0, absLerpValue), skyPower);\n\t\t\t\t\tif (skyColorLerpValue < 0.0) {\n\t\t\t\t\t\treturn mix(skyMidCol, skyLowCol, lerpValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn mix(skyMidCol, skyHighCol, lerpValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#ifdef FOG\n\t\t\tvec3 applyFog(vec3 col){\n\t\t\t\tcol = mix(col, getFogcolor(), fogLerpValue);\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t${s}\n\n\t\t\tvec3 modifyCol(vec3 col){\n\t\t\t\t${i}\n\t\t\t\treturn col;\n\t\t\t}\n\n\t\t\tvec4 modifyTexCol(vec4 col, vec2 uv){\n\t\t\t\t${n}\n\t\t\t\treturn col;\n\t\t\t}\n\n\t\t\tvoid main(){\n\t\t\t\t#ifdef FOG\n\t\t\t\t\tvec3 deltaPos = cameraPosition - vec3(worldPos);\n\t\t\t\t\tfloat fogDistValue = length(deltaPos);\n\t\t\t\t\tfogLerpValue = 1.0 - exp(-fogDistValue*fogAmount);\n\t\t\t\t#endif\n\t\t\t\tvec3 col = modifyCol(vColor);\n\t\t\t\t#ifdef FOG\n\t\t\t\t\tcol = applyFog(col);\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = LinearTosRGB(vec4(col, alpha));\n\t\t\t}\n\t\t`
    }
    createMaterial({
                       name: t = "",
                       vertexShaderOpts: e = {},
                       fragmentShaderOpts: i = {},
                       exactVertShader: n = null,
                       exactFragShader: s = null,
                       uniforms: r = {},
                       defaultAttributeValues: o = {},
                       fog: a = !0,
                       needsFogColor: l = !1,
                       applyWorldColor: h = !0,
                       needsModelPosVarying: c = !1,
                       needsUv: d = !1,
                       depthWrite: u = !0,
                       depthTest: p = !0,
                       side: m = 0
                   } = {}) {
        const g = {
            fog: a,
            needsFogColor: l,
            needsModelPosVarying: c,
            needsUv: d,
            applyWorldColor: h
        };
        let f, y;
        e = {
            name: t,
            ...g,
            ...e
        }, i = {
            name: t,
            ...g,
            ...i
        }, f = n || this.buildVertexShader(e), y = s || this.buildFragShader(i), r = {
            saturation: {
                value: 1
            },
            colorMultiplier: {
                value: new qt(1, 1, 1)
            },
            colorAdder: {
                value: new qt(0, 0, 0)
            },
            skyHighCol: {
                value: new qt
            },
            skyMidCol: {
                value: new qt
            },
            skyLowCol: {
                value: new qt
            },
            skyPower: {
                value: 1
            },
            fogAmount: {
                value: .002
            },
            ...r
        };
        const v = new ke({
            name: t,
            vertexShader: f,
            fragmentShader: y,
            uniforms: r,
            side: m,
            vertexColors: !0,
            depthWrite: u,
            depthTest: p
        });
        return v.defaultAttributeValues = {
            ...v.defaultAttributeValues,
            ...o
        }, this.addCachedMaterial(v), v
    }
}

function qa(t, {
    skinMatrices: e = null
} = {}) {
    let i = null;
    const n = new w;
    for (const s of oa(t))
        if (s instanceof _e && s.geometry) {
            const t = s.geometry.attributes.position,
                r = s.geometry.attributes.skinIndex;
            for (let s = 0; s < t.count; s++) {
                if (n.fromBufferAttribute(t, s), r && e) {
                    const t = e[r.getX(s)];
                    n.applyMatrix4(t)
                }
                i ? i.expandByPoint(n) : i = new S(n.clone(), n.clone())
            }
        } if (!i) return new z(new w(0, 0, 0), 1);
    const s = i.getCenter(new w);
    let r = 0;
    for (const i of oa(t))
        if (i instanceof _e && i.geometry) {
            const t = i.geometry.attributes.position,
                o = i.geometry.attributes.skinIndex;
            for (let i = 0; i < t.count; i++) {
                if (n.fromBufferAttribute(t, i), o && e) {
                    const t = e[o.getX(i)];
                    n.applyMatrix4(t)
                }
                const a = s.distanceTo(n);
                r = Math.max(r, a)
            }
        } return new z(s, r)
}
class ja {
    constructor({
                    skinObjectOpts: t,
                    init: e = !0
                }) {
        this.skinObjectOpts = t, this.isInit = !1, this.destructed = !1, this.obj = null, this.materials = [], this.lastSetMatrices = null, this.onInitCbs = new Set, this.getSkinAbortController = new AbortController, this.initCalled = !1, e && this.init()
    }
    destructor() {
        this.destructed = !0;
        for (const t of this.materials) t.dispose();
        if (this.materials = [], this.obj) {
            for (const t of oa(this.obj)) t instanceof _e && t.geometry.dispose();
            this.obj = null
        }
        this.getSkinAbortController.abort()
    }
    async init() {
        if (this.initCalled) return await this.waitForInit();
        this.initCalled = !0;
        let t = null;
        try {
            t = await uc().skins.getSkinObject(this.skinObjectOpts, this.getSkinAbortController.signal)
        } catch (t) {
            if (!(this.destructed && t instanceof DOMException && "AbortError" == t.name)) throw t
        }
        if (t && (t.geometry.boundingSphere = new z(new w(0, 1, 0), 1), !this.destructed)) {
            this.obj = t;
            const e = new Map;
            this.obj.traverse((t => {
                if (t instanceof _e)
                    if (Array.isArray(t.material)) {
                        const i = t.material;
                        for (const [n, s] of i.entries()) {
                            let i = e.get(s);
                            i || (i = s.clone(), this.materials.push(i), e.set(s, i)), t.material[n] = i
                        }
                    } else {
                        let i = e.get(t.material);
                        if (!i) {
                            i = t.material.clone(), this.materials.push(i), e.set(t.material, i)
                        }
                        t.material = i
                    }
            }))
        }
        this.isInit = !0;
        for (const t of this.onInitCbs) t();
        this.onInitCbs.clear()
    }
    async waitForInit() {
        if (this.isInit) return;
        const t = new Promise((t => this.onInitCbs.add(t)));
        await t
    }
    applySkeleton(t) {
        this.lastSetMatrices = t.getMatrices();
        for (const t of this.materials) t.uniforms.skinMatrices && (t.uniforms.skinMatrices.value = this.lastSetMatrices)
    }
    setHitFlashMaterialsTime(t) {
        for (const e of this.materials) e.uniforms.time.value = t
    }
    setHitFlashMaterialsValue(t, e, i) {
        if (t < 0 || t >= 5) throw new Error("Invalid index");
        for (const n of this.materials) n.uniforms.hitFlashTimes.value[t] = e, n.uniforms.hitFlashPositions.value[t].copy(i)
    }
    computeApproximateBoundingSphere() {
        if (!this.obj) throw new Error("No model loaded");
        return qa(this.obj, {
            skinMatrices: this.lastSetMatrices
        })
    }
}
const Ya = new Map;
Ya.set("movementSpeed", {
    icon: "img/menuUI/shop/classIcons/movementSpeed.svg"
}), Ya.set("bowAttackStrength", {
    icon: "img/menuUI/shop/classIcons/bowAttackStrength.svg"
}), Ya.set("armorStrength", {
    icon: "img/menuUI/shop/classIcons/armorStrength.svg"
}), Ya.set("shootingFocus", {
    icon: "img/menuUI/shop/classIcons/shootingFocus.svg"
});
class Ja extends Ma {
    constructor(t, {
        renderOptions: e
    }) {
        super({
            title: "Confirm your purchase",
            testLabel: "confirmPurchase"
        }), this.onPurchaseSuccessCbs = new Set, this.shopItem = new $a(t, {
            usage: "confirmPurchase",
            renderOptions: e
        }), this.el.appendChild(this.shopItem.el), this.addButtonsContainer(), this.addButton({
            text: "Cancel",
            testLabel: "cancel",
            onClick: () => {
                this.close()
            }
        });
        const i = {
            testLabel: "purchase",
            onClick: async () => {
                await this.purchaseButtonClick()
            }
        };
        t.price && t.price > 0 ? (i.showCurrency = !0, i.currency = t.price) : (i.text = "Get Item", t.hasRewardedAd && (i.icon = "img/rewardedAdIcon.svg")), this.purchaseButton = this.addButton(i), uc().shopState.isPurchasingItem(t.id) && (this.setButtonEnabled(!1), (async () => {
            await uc().shopState.waitForItemPurchase(t.id), this.setButtonEnabled(!0)
        })())
    }
    destructor() {
        this.shopItem.destructor(), super.destructor()
    }
    setButtonEnabled(t) {
        this.purchaseButton.enabled = t
    }
    async purchaseButtonClick() {
        this.setButtonEnabled(!1);
        const t = uc();
        await t.shopState.purchaseItem(this.shopItem.config, t.poki, t.dialogManager, t.skins) ? (this.onPurchaseSuccessCbs.forEach((t => t())), this.close()) : this.setButtonEnabled(!0)
    }
    onPurchaseSuccess(t) {
        this.onPurchaseSuccessCbs.add(t)
    }
}
class Xa {
    constructor() {
        this.obj = new xt, this.obj.name = "Bow asset loader", this.lastFireAmount01 = 0, this.lastVisibleCount = 0, this.currentBowAsset = null, this.onFirstAssetLoadCbs = new Set, this.currentlyLoadingAbortController = null, this.currentlyLoadedMaterials = [], this.currentArrowObjs = [], this.currentArrowOffsets = [], this.arrowPointIdle = new xt, this.arrowPointIdle.name = "Arrow point idle", this.obj.add(this.arrowPointIdle), this.arrowPointLoaded = new xt, this.arrowPointLoaded.name = "Arrow point loaded", this.obj.add(this.arrowPointLoaded)
    }
    destructor() {
        this.destroyMaterials(), this.destroyBowMeshes()
    }
    async setConfig(t) {
        this.currentlyLoadingAbortController && this.currentlyLoadingAbortController.abort();
        const e = new AbortController;
        this.currentlyLoadingAbortController = e;
        const i = uc();
        let n;
        try {
            n = await i.skins.getBowObject({
                name: t.bowId,
                teamId: t.teamId,
                teamColor: t.teamColor,
                morphOpts: t.morphOpts || {},
                skinAssets: t.skins
            }, this.currentlyLoadingAbortController.signal)
        } catch (t) {
            if (t instanceof DOMException && "AbortError" == t.name) return;
            throw t
        }
        const {
            bow: s,
            arrowPointIdleMatrix: r,
            arrowPointLoadedMatrix: o
        } = n, a = await i.arrowAssetCache.getArrowAssetWithCache(t.teamId);
        if (e.signal.aborted) return;
        if (this.currentBowAsset && this.obj.remove(this.currentBowAsset), this.destroyMaterials(), this.destroyBowMeshes(), this.currentBowAsset = s, this.obj.add(s), !(s instanceof _e)) throw new Error("Assertion failed, bow is not a mesh");
        const l = s.material;
        if (!Array.isArray(l)) throw new Error("Assertion failed, materials is not an array");
        for (let t = 0; t < l.length; t++) {
            const e = l[t].clone();
            l[t] = e, e instanceof ke && this.currentlyLoadedMaterials.push(e)
        }
        for (const t of this.currentArrowObjs) t.parent && t.parent.remove(t);
        this.currentArrowObjs = [];
        for (let e = 0; e < t.arrowCount; e++) {
            const t = a.clone();
            t.position.y = .03 * -e, t.position.z = .6, s.add(t), this.currentArrowObjs.push(t);
            const i = Math.cos(e) * e * .01,
                n = Math.sin(e) * e * .01;
            this.currentArrowOffsets.push(new h(i, n))
        }
        this.arrowPointIdle.position.set(0, 0, 0), this.arrowPointIdle.quaternion.identity(), this.arrowPointIdle.scale.set(1, 1, 1), this.arrowPointIdle.applyMatrix4(r), this.arrowPointLoaded.position.set(0, 0, 0), this.arrowPointLoaded.quaternion.identity(), this.arrowPointLoaded.scale.set(1, 1, 1), this.arrowPointLoaded.applyMatrix4(o), this.updateFireAmount(this.lastFireAmount01, this.lastVisibleCount), this.currentlyLoadingAbortController = null, this.onFirstAssetLoadCbs.forEach((t => t())), this.onFirstAssetLoadCbs.clear()
    }
    destroyMaterials() {
        for (const t of this.currentlyLoadedMaterials) t.dispose();
        this.currentlyLoadedMaterials = []
    }
    destroyBowMeshes() {
        if (this.currentBowAsset)
            for (const t of oa(this.currentBowAsset)) t instanceof _e && t.geometry.dispose()
    }
    async waitForLoad() {
        if (!this.isLoadingAsset) return;
        const t = new Promise((t => this.onFirstAssetLoadCbs.add(t)));
        await t
    }
    get isLoadingAsset() {
        return !this.currentBowAsset || Boolean(this.currentlyLoadingAbortController)
    }
    get assetLoaded() {
        return Boolean(this.currentBowAsset)
    }
    getLoadedArrowPointScale() {
        return this.arrowPointLoaded.scale
    }
    updateFireAmount(t, e) {
        this.lastFireAmount01 = t, this.lastVisibleCount = e;
        for (const [i, n] of this.currentArrowObjs.entries()) {
            n.position.lerpVectors(this.arrowPointIdle.position, this.arrowPointLoaded.position, t);
            const s = this.currentArrowOffsets[i];
            n.position.x += s.x, n.position.y += s.y, n.scale.lerpVectors(this.arrowPointIdle.scale, this.arrowPointLoaded.scale, t), n.quaternion.slerpQuaternions(this.arrowPointIdle.quaternion, this.arrowPointLoaded.quaternion, t), n.visible = e > i
        }
        for (const e of this.currentlyLoadedMaterials) e.uniforms.bowMorphAmount.value = t
    }
}
class $a {
    constructor(t, {
        configIndex: e = 0,
        usage: i = "shop",
        renderOptions: n
    }) {
        if (this.configIndex = e, this.config = t, this.usage = i, this.renderOptions = n, this.destructed = !1, "shop" == i) this.el = document.createElement("button");
        else {
            if ("confirmPurchase" != i) throw new Error(`Unknown usage: ${i}`);
            this.el = document.createElement("div")
        }
        this.el.classList.add("shopItem", "wrinkledPaper", "shopItemUsage-" + i), t.preventUnequip && this.el.classList.add("preventUnequip"), this.el.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, this.onSelectedChangeRequestCbs = new Set, this.onHoveringChangeCbs = new Set, this.selected = !1, this.owned = !1, this.isHovering = !1, this.isLooping = !1, this.shouldStopLooping = !1, this.prevNow = 0, this.boundAnimationLoop = this.animationLoop.bind(this), this.el.addEventListener("mouseenter", (() => {
            this.setIsHovering(!0)
        })), this.el.addEventListener("mouseleave", (() => {
            this.setIsHovering(!1)
        })), this.el.addEventListener("click", (() => {
            "confirmPurchase" != this.usage && (this.owned || this.selected ? this.requestSelectedState(!this.selected) : this.openConfirmPurchaseDialog())
        })), this.onConfirmPurchaseDialogOpenCbs = new Set;
        let s = 100;
        if ("confirmPurchase" == i && (s = 200), this.renderView = uc().renderer.createRenderView({
            width: s,
            height: s
        }), this.el.appendChild(this.renderView.canvas), this.cam = new Re, this.cam.far = 10, this.camTarget = new xt, this.rotY = 0, this.defaultRotY = .2 * Math.PI, this.camTarget.rotation.set(-.1 * Math.PI, this.defaultRotY, 0, "YZX"), this.camTarget.add(this.cam), this.scene = new ns, this.scene.add(this.camTarget), this.renderView.setRenderObjects(this.scene, this.cam, !1), this.skeleton = new Ha({
            init: !1,
            gender: this.renderOptions.gender
        }), this.skeleton.addPoseLayer("shopItem"), this.loadingModelSym = null, this.loadingModel = null, this.visibleModel = null, this.skinObject = null, this.bowAsset = null, this.currencyContainer = null, "shop" == i ? this.setOwned(!this.config.price && !this.config.hasRewardedAd) : this.setOwned(!0), this.lockEl = document.createElement("div"), this.lockEl.classList.add("shopItemLock"), this.lockEl.classList.toggle("rewarded-break-unlockable", this.config.hasRewardedAd || !1), this.el.appendChild(this.lockEl), this.config.statClasses) {
            const t = document.createElement("div");
            t.classList.add("shopItemStatClassesContainer"), this.el.appendChild(t);
            for (const e of Object.keys(this.config.statClasses)) {
                const i = Ya.get(e);
                if (!i) continue;
                const n = i.icon;
                if (!n) continue;
                const s = document.createElement("div");
                s.classList.add("shopItemStatClassIcon"), s.style.backgroundImage = `url("${n}")`, t.appendChild(s)
            }
        }
        this.elementVisible = !1, this.skinObjectDirty = !0, this.intersectionObserver = new IntersectionObserver((t => {
            this.elementVisible = !1;
            for (const e of t) e.target == this.el && e.isIntersecting && (this.elementVisible = !0);
            this.elementVisible && this.reloadSkinObjectNow()
        })), this.intersectionObserver.observe(this.el), this.setSelectedState(this.selected), this.setOwned(this.owned), "confirmPurchase" == this.usage && this.startLooping(), this.updateAriaLabel()
    }
    get id() {
        return this.config.id
    }
    destructor() {
        this.destructed = !0, uc().renderer.removeRenderView(this.renderView), this.loadingModel && this.loadingModel.destructor(), this.visibleModel && this.visibleModel.destructor(), this.bowAsset && this.bowAsset.destructor(), this.stopLooping(), this.intersectionObserver.unobserve(this.el), this.intersectionObserver.disconnect()
    }
    setRenderOptions(t) {
        this.renderOptions = t, this.skinObjectDirty = !0, this.elementVisible && this.reloadSkinObjectNow()
    }
    async reloadSkinObjectNow() {
        if (!this.skinObjectDirty) return;
        const t = Symbol("Loading model");
        let e;
        if (this.loadingModelSym = t, this.loadingModel && (this.loadingModel.destructor(), this.loadingModel = null), this.config.bowSkin) {
            this.bowAsset && this.bowAsset.destructor();
            const i = uc().skins.skinNetworkDataToBowAssetNames(this.config.bowSkin.bowId, {
                equippedSkinIds: [this.config.id]
            });
            if (this.bowAsset = new Xa, this.bowAsset.setConfig({
                bowId: this.config.bowSkin.bowId,
                teamId: 1,
                skins: i,
                arrowCount: 0
            }), this.scene.add(this.bowAsset.obj), await this.bowAsset.waitForLoad(), t != this.loadingModelSym) return;
            e = qa(this.bowAsset.obj)
        } else {
            const i = [],
                n = this.config.colorizableCategory;
            let s = {};
            if ("male" == this.renderOptions.gender && this.config.maleSkin ? s = this.config.maleSkin : "female" == this.renderOptions.gender && this.config.femaleSkin && (s = this.config.femaleSkin), n && s.additions)
                for (const [t, e] of Object.entries(s.additions)) {
                    const n = t;
                    for (const t of e) i.push({
                        assetName: t,
                        colorMultiplier: this.renderOptions.colorMultiplier,
                        joints: [n]
                    })
                }
            let r = {};
            if (s.additions && (r = s.additions), this.config.showFullBodyInShopItem) {
                r = uc().skins.skinNetworkDataToSkinConfig({
                    equippedSkinIds: [this.config.id],
                    gender: this.renderOptions.gender
                }).equippedItems
            }
            if (this.loadingModel = new ja({
                init: !1,
                skinObjectOpts: {
                    teamId: 1,
                    skin: {},
                    rawSkin: {
                        colorizedItems: i,
                        equippedItems: r
                    }
                }
            }), await this.loadingModel.init(), await this.skeleton.init(), await this.skeleton.waitForLinkLayerObjects(), !this.loadingModel.obj) return;
            if (t != this.loadingModelSym) return;
            this.skinObject && this.scene.remove(this.skinObject), this.skinObject = this.loadingModel.obj, this.visibleModel && this.visibleModel.destructor(), this.visibleModel = this.loadingModel, this.loadingModel = null, this.skeleton.applyLayers(), this.skeleton.updateMatrices(), this.visibleModel.applySkeleton(this.skeleton), e = this.visibleModel.computeApproximateBoundingSphere(), this.scene.add(this.skinObject)
        }
        this.camTarget.position.copy(e.center), this.cam.position.z = 3 * Math.max(e.radius, .05), this.renderView.markDirty(), this.skinObjectDirty = !1
    }
    get shouldBeVisible() {
        const t = this.config.shopVisibility;
        if ("visible" == t || !t) return !0;
        if ("seasonal" == t) {
            if (null != this.config.price && this.config.price > 0 && this.owned) return !0;
            if (this.config.seasonalRange) {
                const t = this.config.seasonalRange;
                if (t.startDay && t.endDay && t.startMonth && t.endMonth) {
                    const e = new Date,
                        i = new Date(e.getFullYear(), t.startMonth - 1, t.startDay),
                        n = new Date(e.getFullYear(), t.endMonth - 1, t.endDay),
                        s = new Date(e.getFullYear(), e.getMonth(), e.getDate());
                    if (s >= i && s <= n) return !0
                }
            }
        }
        return !1
    }
    onSelectedChangeRequest(t) {
        this.onSelectedChangeRequestCbs.add(t)
    }
    setOwned(t) {
        this.owned = t, this.el.classList.toggle("shopItemOwned", t), this.el.classList.toggle("shopItemLocked", !t), t || !this.config.price ? this.currencyContainer && (this.el.removeChild(this.currencyContainer.el), this.currencyContainer = null) : this.currencyContainer || (this.currencyContainer = new xa({
            amount: this.config.price
        }), this.el.appendChild(this.currencyContainer.el))
    }
    setIsHovering(t) {
        if (t != this.isHovering) {
            this.isHovering = t, t && this.owned && this.startLooping();
            for (const e of this.onHoveringChangeCbs) e(t)
        }
    }
    startLooping() {
        this.isLooping || (this.isLooping = !0, this.renderView.alwaysDirty = !0, this.animationLoop())
    }
    stopLooping() {
        this.shouldStopLooping = !0
    }
    animationLoop() {
        const t = performance.now();
        this.prevNow || (this.prevNow = t);
        const e = t - this.prevNow;
        if (this.prevNow = t, this.isHovering && this.owned || "confirmPurchase" == this.usage ? (this.rotY -= .001 * e, this.rotY = aa(this.rotY + Math.PI, 2 * Math.PI) - Math.PI) : (this.rotY = la(this.rotY, 0, .1), Math.abs(this.rotY) < .001 && this.stopLooping()), this.camTarget.rotation.y = this.rotY + this.defaultRotY, this.shouldStopLooping) return this.isLooping = !1, this.shouldStopLooping = !1, this.prevNow = 0, void(this.renderView && (this.renderView.alwaysDirty = !1));
        window.requestAnimationFrame(this.boundAnimationLoop)
    }
    onHoveringChange(t) {
        this.onHoveringChangeCbs.add(t)
    }
    setSelectedState(t) {
        this.selected = t, this.el.classList.toggle("selected", this.selected), this.updateAriaLabel()
    }
    updateAriaLabel() {
        let t = "";
        if ("shop" == this.usage) {
            let e = "";
            e = this.selected ? "equipped" : this.owned ? "not equipped" : this.config.hasRewardedAd ? "locked, click to watch rewarded ad and unlock" : this.config.price ? `locked, unlock for ${this.config.price} coins` : "locked", t = `Shop item, ${this.config.id}, ${e}`
        } else "confirmPurchase" == this.usage && (t = "Shop item preview");
        this.el.setAttribute("aria-label", t)
    }* getSkinSlots() {
        this.config.slots && (yield* this.config.slots)
    }
    highlight() {
        this.el.classList.add("highlight"), this.el.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: "center"
        })
    }
    openConfirmPurchaseDialog() {
        const t = new Ja(this.config, {
            renderOptions: this.renderOptions
        });
        uc().dialogManager.addDialog(t), t.onPurchaseSuccess((() => {
            this.requestSelectedState(!0)
        })), this.onConfirmPurchaseDialogOpenCbs.forEach((e => e(t)))
    }
    requestSelectedState(t) {
        this.config.preventUnequip && !t || this.onSelectedChangeRequestCbs.forEach((e => e(t)))
    }
    onConfirmPurchaseDialogOpen(t) {
        this.onConfirmPurchaseDialogOpenCbs.add(t)
    }
}
class Za {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("shop-items-grid-view"), this.shopItems = new Map, this.activeConfirmPurchaseDialogs = new Set, this.currentHoveringItem = null, this.onHoveringItemChangeCbs = new Set, this.onSelectedItemChangeRequestCbs = new Set
    }
    destructor() {
        this.destructShopItems()
    }
    addShopItem(t, e) {
        const i = new $a(t, e);
        i.shouldBeVisible && (this.el.appendChild(i.el), i.onHoveringChange((t => {
            const e = this.currentHoveringItem;
            if (t ? this.currentHoveringItem = i : this.currentHoveringItem == i && (this.currentHoveringItem = null), this.currentHoveringItem != e)
                for (const t of this.onHoveringItemChangeCbs) t(this.currentHoveringItem)
        })), i.onConfirmPurchaseDialogOpen((t => {
            this.activeConfirmPurchaseDialogs.add(t), t.addOnCloseCb((() => {
                this.activeConfirmPurchaseDialogs.delete(t)
            }))
        })), i.onSelectedChangeRequest((t => {
            this.onSelectedItemChangeRequestCbs.forEach((e => e(i.id, t)))
        })), this.shopItems.set(i.id, i))
    }
    closeCreatedConfirmPurchaseDialogs() {
        for (const t of this.activeConfirmPurchaseDialogs) t.close()
    }
    destructShopItems() {
        for (const t of this.shopItems.values()) t.destructor();
        for (this.shopItems.clear(); this.el.lastChild;) this.el.removeChild(this.el.lastChild)
    }
    loadShopItems(t, e) {
        this.destructShopItems();
        for (const [i, n] of t.entries()) this.addShopItem(n, {
            configIndex: i,
            ...e
        });
        this.sortShopItems()
    }
    setRenderOptions(t) {
        for (const e of this.shopItems.values()) e.setRenderOptions(t)
    }
    setSelectedItems(t) {
        for (const e of this.shopItems.values()) e.setSelectedState(t.has(e.id))
    }
    setSelectedItemState(t, e) {
        const i = this.shopItems.get(t);
        i && i.setSelectedState(e)
    }
    onSelectedItemChangeRequest(t) {
        this.onSelectedItemChangeRequestCbs.add(t)
    }
    setPurchasedItems(t) {
        for (const e of this.shopItems.values())(e.config.price && e.config.price > 0 || e.config.hasRewardedAd) && e.setOwned(t.has(e.id));
        this.sortShopItems()
    }
    markItemAsPurchased(t) {
        const e = this.shopItems.get(t);
        e && e.setOwned(!0)
    }
    onHoveringItemChange(t) {
        this.onHoveringItemChangeCbs.add(t)
    }
    sortShopItems() {
        const t = Array.from(this.shopItems.values());
        t.sort(((t, e) => t.owned && !e.owned ? -1 : !t.owned && e.owned ? 1 : t.configIndex - e.configIndex));
        for (const e of t) this.el.appendChild(e.el)
    }
    performHighlightShopItemAction(t, e) {
        const i = this.shopItems.get(t);
        i && (i.highlight(), "highlight" == e || ("highlight-and-equip" == e ? i.requestSelectedState(!0) : "open" == e && i.openConfirmPurchaseDialog()))
    }
}
const Ka = [{
    name: "unset",
    nameCapitalized: "Unset",
    colorTransform: t => {
        t.h += .06, t.s *= .6, t.v *= .4
    },
    cssColor: "#bb6b29",
    cssColorLight: "#ffbc87",
    cssColorDark: "#6c3e19"
}, {
    name: "red",
    nameCapitalized: "Red",
    cssColor: "#e5302c",
    cssColorLight: "#ffd9d1",
    cssColorDark: "#a32321"
}, {
    name: "blue",
    nameCapitalized: "Blue",
    colorTransform: t => {
        t.h += .6
    },
    cssColor: "#24a3dd",
    cssColorLight: "#b0e6ff",
    cssColorDark: "#1d749e"
}];
class Qa extends Ma {
    constructor(t, e, i) {
        super(), this.avatarsManager = t, this.contentEl = document.createElement("div"), this.contentEl.classList.add("skin-downloader-dialog-content"), this.el.appendChild(this.contentEl);
        const n = document.createElement("div");
        n.classList.add("skin-downloader-dialog-controls"), this.contentEl.appendChild(n);
        const s = document.createElement("div");
        s.textContent = "Team color ", n.appendChild(s), this.teamColorInput = document.createElement("input"), this.teamColorInput.type = "color", this.teamColorInput.value = Ka[1].cssColor, this.teamColorInput.addEventListener("change", (() => this.reloadPreview())), s.appendChild(this.teamColorInput);
        const r = document.createElement("div");
        r.textContent = "Background color ", n.appendChild(r), this.backgroundColorInput = document.createElement("input"), this.backgroundColorInput.type = "color", this.backgroundColorInput.value = Ka[2].cssColor, this.backgroundColorInput.addEventListener("change", (() => this.reloadPreview())), r.appendChild(this.backgroundColorInput);
        const o = document.createElement("div");
        o.textContent = "Background opacity ", n.appendChild(o), this.backgroundOpacityInput = document.createElement("input"), this.backgroundOpacityInput.type = "range", this.backgroundOpacityInput.min = "0", this.backgroundOpacityInput.max = "1", this.backgroundOpacityInput.step = "0.01", this.backgroundOpacityInput.value = "1", this.backgroundOpacityInput.addEventListener("change", (() => this.reloadPreview())), o.appendChild(this.backgroundOpacityInput);
        const a = document.createElement("div");
        a.textContent = "Shape ", n.appendChild(a), this.shapeInput = document.createElement("select");
        for (const t of ["none", "circle"]) {
            const e = document.createElement("option");
            e.value = t, e.textContent = t, this.shapeInput.appendChild(e)
        }
        this.shapeInput.value = "circle", this.shapeInput.addEventListener("change", (() => this.reloadPreview())), a.appendChild(this.shapeInput);
        const l = document.createElement("div");
        l.textContent = "Camera ", n.appendChild(l), this.cameraInput = document.createElement("select");
        for (const t of ["face-close", "face", "upper-body", "full-body"]) {
            const e = document.createElement("option");
            e.value = t, e.textContent = t.replaceAll("-", " "), this.cameraInput.appendChild(e)
        }
        this.cameraInput.value = "face-close", this.cameraInput.addEventListener("change", (() => this.reloadPreview())), l.appendChild(this.cameraInput);
        const h = document.createElement("div");
        h.textContent = "Pose ", n.appendChild(h), this.poseInput = document.createElement("select");
        const c = [];
        c.push(["", "None"]);
        for (const {
            uiName: t,
            id: e
        }
            of Ea) c.push([e, t]);
        for (const [t, e] of c) {
            const i = document.createElement("option");
            i.value = t, i.textContent = e, this.poseInput.appendChild(i)
        }
        this.poseInput.value = "", this.poseInput.addEventListener("change", (() => this.reloadPreview())), h.appendChild(this.poseInput);
        const d = document.createElement("div");
        d.textContent = "Size ", n.appendChild(d), this.widthInput = document.createElement("input"), this.widthInput.classList.add("skin-downloader-size-input"), this.widthInput.type = "number", this.widthInput.value = "1024", d.appendChild(this.widthInput), d.appendChild(document.createTextNode(" x ")), this.heightInput = document.createElement("input"), this.heightInput.classList.add("skin-downloader-size-input"), this.heightInput.type = "number", this.heightInput.value = "1024", d.appendChild(this.heightInput);
        const u = document.createElement("div");
        u.classList.add("skin-downloader-download-container"), n.appendChild(u);
        const p = new Sa({
            text: "Download",
            onClick: () => this.downloadCurrentAvatar()
        });
        u.appendChild(p.el), this.imageEl = document.createElement("div"), this.imageEl.classList.add("downloadable-skin-preview"), this.contentEl.appendChild(this.imageEl), this.currentBlobReference = null, this.createdDownloadBlobReferences = [], this.skinConfig = i, this.reloadPreview()
    }
    destructor() {
        super.destructor(), this.currentBlobReference && (this.currentBlobReference.destructor(), this.currentBlobReference = null);
        for (const t of this.createdDownloadBlobReferences) t.destructor();
        this.createdDownloadBlobReferences = []
    }
    getCurrentAvatarConfig(t, e) {
        const i = this.shapeInput.value ?? "none",
            n = this.cameraInput.value ?? "face-close",
            s = this.teamColorInput.value,
            r = {
                r: parseInt(s.substring(1, 3), 16) / 255,
                g: parseInt(s.substring(3, 5), 16) / 255,
                b: parseInt(s.substring(5, 7), 16) / 255
            };
        let o = null,
            a = null;
        if (this.poseInput.value) {
            const t = Ta(this.poseInput.value);
            o = [t.bowId + "/shopClassItem"], a = {
                teamId: 1,
                teamColor: r,
                bowId: t.bowId,
                arrowCount: 1,
                skins: uc().skins.skinNetworkDataToBowAssetNames(t.bowId, this.skinConfig)
            }
        }
        const l = {
            backgroundColor: this.backgroundColorInput.value,
            backgroundAlpha: Number(this.backgroundOpacityInput.value),
            width: t,
            height: e,
            cameraType: n,
            clipPathType: i,
            bow: a,
            skinObjectOpts: {
                teamColor: r,
                skin: this.skinConfig
            }
        };
        return o && (l.skeletonPoseLayers = o), l
    }
    reloadPreview() {
        if (!this.skinConfig) return;
        const t = 250 * globalThis.devicePixelRatio,
            e = this.getCurrentAvatarConfig(t, t),
            i = this.avatarsManager.getAvatar(e).getBlobUrlReference();
        this.currentBlobReference && this.currentBlobReference.destructor(), this.currentBlobReference = i, (async () => {
            if (i != this.currentBlobReference) return void i.destructor();
            const t = await i.getBlobUrl();
            this.imageEl.style.backgroundImage = `url("${t}")`
        })()
    }
    downloadCurrentAvatar() {
        if (!this.skinConfig) return;
        const t = Number(this.widthInput.value),
            e = Number(this.heightInput.value),
            i = this.getCurrentAvatarConfig(t, e),
            n = this.avatarsManager.getAvatar(i).getBlobUrlReference();
        this.createdDownloadBlobReferences.push(n), (async () => {
            const t = await n.getBlobUrl(),
                e = document.createElement("a");
            e.href = t, e.download = "skin.png", e.click()
        })()
    }
}
class tl {
    constructor() {
        this.destructed = !1, this.el = document.createElement("div"), this.el.classList.add("shopSkinPreview", "wrinkledPaper", "wrinkled-paper-mask"), this.currentlyLoadedSkinData = null, this.currentTeamId = 1, this.el.addEventListener("click", (() => {
            this.currentTeamId++, this.currentTeamId > 2 && (this.currentTeamId = 0), this.updateBackgroundColor(), this.updateSkinModel()
        })), this.renderView = uc().renderer.createRenderView({
            width: 200,
            height: 300
        }), this.renderView.canvas.classList.add("shop-skin-preview-canvas"), this.el.appendChild(this.renderView.canvas), this.downloadButton = document.createElement("div"), this.downloadButton.classList.add("shop-skin-preview-download-button"), this.downloadButton.addEventListener("click", (() => {
            if (this.currentlyLoadedSkinData) {
                const t = new Qa(uc().avatars, uc().skins, this.currentlyLoadedSkinData);
                uc().dialogManager.addDialog(t)
            }
        })), this.el.appendChild(this.downloadButton), this.cam = new Re(45, 200 / 300, .1, 5), this.cam.far = 10, this.camTarget = new xt, this.rotY = 0, this.currentMouseYMultiplier = 1, this.camTarget.add(this.cam), this.scene = new ns, this.scene.add(this.camTarget), this.modelRotationContainer = new xt, this.scene.add(this.modelRotationContainer), this.bowParentObj = new xt, this.modelRotationContainer.add(this.bowParentObj), this.bowParentObj.matrixAutoUpdate = !1, this.smoothCamPosOffset = new w, this.smoothCamTargetRot = 0, this.activeCamFollowingTarget = null, this.activeSlotPositionId = null, this.camPositions = new Map, this.camPositions.set("full", {
            pos: new w(0, 1, 2.8)
        }), this.camPositions.set("head", {
            pos: new w(0, 1.8, 1.3),
            mouseYMultiplier: .2
        }), this.camPositions.set("torso", {
            pos: new w(0, 1.1, 1.7)
        }), this.camPositions.set("arms", {
            pos: new w(0, 1.3, 1.5),
            rot: .3,
            mouseYMultiplier: .5
        }), this.camPositions.set("legs", {
            pos: new w(0, .35, 1.3)
        }), this.camPositions.set("quiver", {
            pos: new w(0, 1.1, 2),
            rot: -2.5
        }), this.camPositions.set("face", {
            pos: new w(0, 1.75, .6),
            rot: .2,
            mouseYMultiplier: .1
        }), this.camPositions.set("smallBowHandle", {
            pos: new w(0, 0, 1.1),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("smallBowTip", {
            pos: new w(-.1, .4, .8),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("mediumBowHandle", {
            pos: new w(-.1, 0, 1.5),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("mediumBowTip", {
            pos: new w(-.2, .5, 1),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("largeBowHandle", {
            pos: new w(-.1, 0, 1.8),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("largeBowTip", {
            pos: new w(-.3, .9, 1.2),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("smallCrossbowHandle", {
            pos: new w(.1, 0, 1.2),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("smallCrossbowTip", {
            pos: new w(0, 0, 1.7),
            activeFollowingTarget: this.bowParentObj,
            rot: .3
        }), this.camPositions.set("largeCrossbowHandle", {
            pos: new w(0, 0, 2.5),
            activeFollowingTarget: this.bowParentObj,
            rot: -.5 * Math.PI
        }), this.camPositions.set("largeCrossbowTip", {
            pos: new w(-.1, 0, 2.2),
            activeFollowingTarget: this.bowParentObj,
            rot: .7
        }), this.setActiveSlotPosition("full", !0), this.renderView.setRenderObjects(this.scene, this.cam), this.boundOnMouseMove = this.onMouseMove.bind(this), window.addEventListener("mousemove", this.boundOnMouseMove), this.lastMouseX = 0, this.lastMouseY = 0, this.skeleton = new Ha, this.activeExtraPoseLayer = null, this.bowAssetLoader = new Xa, this.hoveringBowAssetLoader = new Xa, this.bowParentObj.add(this.bowAssetLoader.obj), this.bowParentObj.add(this.hoveringBowAssetLoader.obj), this.bowSkeletonObj = null, this.currentVisibleBowId = null, this.currentEquippedSkinIds = [], this.hoveringBowVisible = !1, this.activeModel = null, this.loadingModel = null, this.hoveringModel = null, this.hoveringModelVisible = !1, this.lastHoveringModelCacheKey = "", this.initSkeleton(), this.updateSkinModel(), this.updateBackgroundColor()
    }
    destructor() {
        this.destructed = !0, this.bowAssetLoader.destructor(), this.hoveringBowAssetLoader.destructor(), uc().renderer.removeRenderView(this.renderView), this.removeModel(this.activeModel), this.activeModel = null, this.removeModel(this.loadingModel), this.loadingModel = null, this.removeModel(this.hoveringModel), this.hoveringModel = null, window.removeEventListener("mousemove", this.boundOnMouseMove)
    }
    async initSkeleton() {
        await this.skeleton.waitForLoad();
        const t = this.skeleton.addPoseLayer("shopPreview");
        if (await t.waitForObjectLinks(), this.skeleton.applyLayers(), this.skeleton.updateMatrices(), this.updateModelRotation(), !this.skeleton.baseSkeletonObject) throw new Error("Assertion failed, skeleton is not initialized");
        const e = this.skeleton.baseSkeletonObject.getObjectByName("bowHoldingPos");
        if (!e) throw new Error("Assertion failed, bow holding pos object not found");
        this.bowSkeletonObj = e
    }
    async addModel(t) {
        t && (await t.waitForInit(), t.obj && this.modelRotationContainer.add(t.obj))
    }
    removeModel(t) {
        t && (t.obj && this.modelRotationContainer.remove(t.obj), t.destructor())
    }
    loop(t, e) {
        let i = !1;
        this.cam.position.distanceTo(this.smoothCamPosOffset) > .01 && (i = !0), this.cam.position.lerp(this.smoothCamPosOffset, .1);
        let n = new w;
        this.activeCamFollowingTarget && (n = this.activeCamFollowingTarget.getWorldPosition(new w));
        this.camTarget.position.distanceTo(n) > .01 && (i = !0), this.camTarget.position.lerp(n, .1);
        Math.abs(this.camTarget.rotation.y - this.smoothCamTargetRot) > .01 && (i = !0), this.camTarget.rotation.y = la(this.camTarget.rotation.y, this.smoothCamTargetRot, .1), i && this.renderView.markDirty()
    }
    setHoveringModel(t) {
        if (this.hoveringModelVisible = !1, t) {
            this.hoveringModelVisible = !0;
            const e = uc().skins.skinObjectOptsToCacheKey(t);
            this.lastHoveringModelCacheKey != e && (this.lastHoveringModelCacheKey = e, this.removeModel(this.hoveringModel), this.hoveringModel = null, t && (this.hoveringModel = new ja({
                skinObjectOpts: t
            }), this.addModel(this.hoveringModel), this.updateVisibleModelAfterHoveringInit()))
        }
        if (this.updateVisibleModel(), t && this.currentVisibleBowId) {
            const e = uc().skins.skinNetworkDataToBowAssetNames(this.currentVisibleBowId, t.skin);
            e.length > 0 && (this.hoveringBowAssetLoader.setConfig({
                bowId: this.currentVisibleBowId,
                arrowCount: 1,
                skins: e,
                teamId: this.currentTeamId
            }), this.updateVisibleBowAfterLoad()), this.hoveringBowVisible = !0
        } else this.hoveringBowVisible = !1;
        this.updateVisibleBow()
    }
    setHoveringShopItemId(t) {
        if (!this.currentlyLoadedSkinData) return;
        const e = {
            teamId: this.currentTeamId,
            skin: uc().skins.getConfigForPreviewShopItemId(this.currentlyLoadedSkinData, {
                itemId: t
            })
        };
        this.setHoveringModel(e)
    }
    setTemporaryColorCategory(t, e) {
        this.currentlyLoadedSkinData && this.setHoveringModel({
            teamId: this.currentTeamId,
            skin: uc().skins.getConfigForPreviewShopItemId(this.currentlyLoadedSkinData, {
                colorCategory: t,
                colorMultiplier: e
            })
        })
    }
    resetHoveringModel() {
        this.setHoveringModel(null)
    }
    async updateVisibleModelAfterHoveringInit() {
        this.hoveringModel && await this.hoveringModel.waitForInit(), this.updateVisibleModel()
    }
    async updateVisibleBowAfterLoad() {
        await this.hoveringBowAssetLoader.waitForLoad(), this.updateVisibleBow()
    }
    updateSkinModel() {
        this.currentlyLoadedSkinData && this.setCurrentSkinConfig(this.currentlyLoadedSkinData)
    }
    setCurrentSkinConfig(t) {
        this.currentlyLoadedSkinData = t, this.removeModel(this.loadingModel), this.loadingModel = new ja({
            skinObjectOpts: {
                teamId: this.currentTeamId,
                skin: t
            }
        }), this.addModel(this.loadingModel), this.replaceLoadingModel(), this.currentEquippedSkinIds = t.equippedSkinIds || [], this.updateBowConfig()
    }
    updateBackgroundColor() {
        const t = (this.currentTeamId + 1) % Ka.length,
            e = Ka[t];
        this.el.style.background = e.cssColor
    }
    async replaceLoadingModel() {
        this.loadingModel && (await this.loadingModel.waitForInit(), this.loadingModel && (this.removeModel(this.activeModel), this.activeModel = this.loadingModel, this.loadingModel = null, this.removeModel(this.hoveringModel), this.hoveringModel = null, this.updateVisibleModel()))
    }
    onMouseMove(t) {
        const e = t.clientX / window.innerWidth * 2 - 1,
            i = t.clientY / window.innerHeight * 2 - 1;
        this.lastMouseX = e, this.lastMouseY = i * this.currentMouseYMultiplier, this.updateModelRotation()
    }
    getVisibleModel() {
        return this.hoveringModel && this.hoveringModel.obj ? this.hoveringModel : this.activeModel && this.activeModel.obj ? this.activeModel : null
    }
    updateVisibleModel() {
        let t = !1;
        this.hoveringModel && this.hoveringModel.obj && (this.hoveringModel.obj.visible = this.hoveringModelVisible, t = this.hoveringModelVisible), this.activeModel && this.activeModel.obj && (this.activeModel.obj.visible = !t), this.updateSkeletonGender(), this.updateModelRotation()
    }
    updateVisibleBow() {
        const t = Boolean(this.currentVisibleBowId),
            e = this.hoveringBowVisible && !this.hoveringBowAssetLoader.isLoadingAsset;
        this.bowAssetLoader.obj.visible = t && !e, this.hoveringBowAssetLoader.obj.visible = t && e
    }
    async updateSkeletonGender() {
        const t = this.getVisibleModel();
        if (t) {
            const e = t.skinObjectOpts.skin.gender || "male";
            this.skeleton.gender != e && (this.skeleton.setGender(e), await this.skeleton.waitForLinkLayerObjects(), this.updateModelRotation())
        }
    }
    updateModelRotation() {
        const t = this.getVisibleModel();
        t && t.obj && (this.modelRotationContainer.rotation.y = this.lastMouseX, this.skeleton.isInit && this.skeleton.allObjectLinksBuilt && (this.skeleton.applyLayers(), this.skeleton.setLookRotY(this.lastMouseY), this.skeleton.updateMatrices(), t.applySkeleton(this.skeleton), this.bowSkeletonObj && this.bowParentObj.matrix.copy(this.bowSkeletonObj.matrixWorld), this.renderView.markDirty()))
    }
    setActiveSlotPosition(t, e = !1) {
        this.activeSlotPositionId = t, this.activeCamFollowingTarget = null;
        const i = this.camPositions.get(t);
        i && (i.activeFollowingTarget && (this.activeCamFollowingTarget = i.activeFollowingTarget), i.pos && (this.smoothCamPosOffset.copy(i.pos), e && this.cam.position.copy(i.pos)), this.smoothCamTargetRot = i.rot || 0, void 0 !== i.mouseYMultiplier ? this.currentMouseYMultiplier = i.mouseYMultiplier : this.currentMouseYMultiplier = 1)
    }
    async setSkeletonPose(t) {
        let e = !1;
        if (this.activeExtraPoseLayer && (this.skeleton.removePoseLayer(this.activeExtraPoseLayer), e = !0), t) {
            const i = this.skeleton.addPoseLayer(t);
            if (this.activeExtraPoseLayer = i, await this.activeExtraPoseLayer.waitForObjectLinks(), this.activeExtraPoseLayer != i) return;
            e = !0
        }
        e && (await this.skeleton.waitForLoad(), this.skeleton.applyLayers(), this.skeleton.updateMatrices(), this.updateModelRotation())
    }
    async setBow(t) {
        this.currentVisibleBowId = t, this.updateBowConfig(), this.updateVisibleBow()
    }
    updateBowConfig() {
        if (this.currentVisibleBowId) {
            const t = uc().skins.skinNetworkDataToBowAssetNames(this.currentVisibleBowId, {
                equippedSkinIds: this.currentEquippedSkinIds
            });
            this.bowAssetLoader.setConfig({
                bowId: this.currentVisibleBowId,
                arrowCount: 1,
                skins: t,
                teamId: this.currentTeamId
            })
        }
    }
}
class el {
    constructor(t, {
        id: e,
        rootHeader: i
    }) {
        let n;
        if (this.el = document.createElement("div"), this.el.classList.add("shopDialogContent"), this.skinManager = t, this.customizationId = e, this.onBackButtonClickCbs = new Set, this.pagedView = new Ua({
            extraClasses: ["shop-paged-view-container"]
        }), this.el.appendChild(this.pagedView.el), this.createdGrids = new Map, this.skinPreview = new tl, this.el.appendChild(this.skinPreview.el), this.updateSkinPreviewConfig(), this.filterSubPages = new Map, "class" == e.type) {
            const t = Ta(e.classId);
            n = {
                itemName: "Bow",
                buttonIcon: "img/menuUI/shop/categoryIcons/bow.svg",
                buttonIconSize: 2.2,
                subPages: [this.createGridViewSubPage({
                    itemName: "Handle",
                    buttonIcon: "img/menuUI/shop/categoryIcons/bowHandle.svg",
                    buttonIconSize: 2.2,
                    ...this.createBowGridViewConfig(t, "handle")
                }), this.createGridViewSubPage({
                    itemName: "Tip",
                    buttonIcon: "img/menuUI/shop/categoryIcons/bowTip.svg",
                    buttonIconSize: 2.2,
                    ...this.createBowGridViewConfig(t, "tip")
                })]
            }
        } else {
            const t = [];
            for (const e of Ea) t.push({
                itemName: e.uiName,
                subPages: [this.createGridViewSubPage({
                    itemName: "Handle",
                    buttonIcon: "img/menuUI/shop/categoryIcons/bowHandle.svg",
                    buttonIconSize: 2.2,
                    ...this.createBowGridViewConfig(e, "handle")
                }), this.createGridViewSubPage({
                    itemName: "Tip",
                    buttonIcon: "img/menuUI/shop/categoryIcons/bowTip.svg",
                    buttonIconSize: 2.2,
                    ...this.createBowGridViewConfig(e, "tip")
                })]
            });
            n = {
                itemName: "Bow",
                buttonIcon: "img/menuUI/shop/categoryIcons/bow.svg",
                buttonIconSize: 2.2,
                subPages: t,
                onBecomeVisible: () => {
                    this.resetSkinPreview()
                }
            }
        }
        this.pagedView.setActiveStructure({
            header: i,
            onBecomeVisible: () => {
                this.resetSkinPreview()
            },
            onBackButtonClick: () => {
                this.onBackButtonClickCbs.forEach((t => t()))
            },
            rightCorner: i => {
                if ("class" == e.type) {
                    const n = e.classId,
                        s = this.skinManager.getClassSkinData(n, !1),
                        r = document.createElement("div");
                    r.classList.add("dialog-select-wrapper", "wrinkledPaper"), i.appendChild(r);
                    const o = document.createElement("select");
                    o.classList.add("dialog-select-input", "blueNight"), r.appendChild(o);
                    const a = document.createElement("option");
                    a.value = "none", a.textContent = "None", o.appendChild(a);
                    for (const e of t.skinPresets.keys()) {
                        const t = document.createElement("option");
                        t.value = String(e), t.textContent = `Preset ${e+1}`, o.appendChild(t)
                    }
                    null == s.presetId ? o.value = "none" : o.value = String(s.presetId), o.addEventListener("change", (() => {
                        let t;
                        t = "none" == o.value ? null : Number(o.value), this.skinManager.setClassPreset(n, t), this.updateSkinPreviewConfig()
                    }))
                }
            },
            subPages: [{
                itemName: "Looks",
                buttonIcon: "img/menuUI/shop/categoryIcons/face.svg",
                buttonIconSize: 2.2,
                onBecomeVisible: () => {
                    this.resetSkinPreview({
                        camPosition: "face"
                    })
                },
                rightCorner: t => {
                    const i = document.createElement("div");
                    i.classList.add("shop-gender-toggle-container"), t.appendChild(i);
                    const n = document.createElement("div");
                    n.classList.add("gender-icon", "male"), i.appendChild(n);
                    const s = document.createElement("input");
                    s.type = "checkbox", s.classList.add("dialog-toggle-input", "wrinkledPaper"), s.ariaLabel = "Gender";
                    let r = "male";
                    if ("preset" == e.type) {
                        const t = e.presetId;
                        r = this.skinManager.getPreset(t).gender || "male"
                    } else if ("class" == e.type) {
                        const t = e.classId,
                            i = this.skinManager.getClassSkinData(t, !1);
                        let n;
                        if (null != i.presetId) {
                            n = this.skinManager.getPreset(i.presetId).gender
                        }
                        r = i.gender || n || "male"
                    }
                    s.checked = "female" == r, s.addEventListener("change", (() => {
                        const t = s.checked ? "female" : "male";
                        "preset" == e.type ? this.skinManager.setPresetGender(e.presetId, t) : "class" == e.type && this.skinManager.setClassGender(e.classId, t), this.updateSkinPreviewConfig(), this.pagedView.updateButtonVisibilies()
                    })), i.appendChild(s);
                    const o = document.createElement("div");
                    o.classList.add("gender-icon", "female"), i.appendChild(o)
                },
                subPages: [this.createGridViewSubPage({
                    itemName: "Skin color",
                    buttonIcon: "img/menuUI/shop/categoryIcons/skinTone.svg",
                    buttonIconSize: 1.2,
                    shopCategoriesFilter: ["skinTone"]
                }), this.createGridViewSubPage({
                    itemName: "Hair",
                    buttonIcon: "img/menuUI/shop/categoryIcons/hair.svg",
                    buttonIconSize: 1.2,
                    shopCategoriesFilter: ["faceHair"],
                    colorButtonsCategory: "hair"
                }), this.createGridViewSubPage({
                    itemName: "Eyebrows",
                    buttonIcon: "img/menuUI/shop/categoryIcons/eyebrows.svg",
                    buttonIconSize: 1.4,
                    shopCategoriesFilter: ["faceEyebrows"],
                    colorButtonsCategory: "eyebrows"
                }), this.createGridViewSubPage({
                    itemName: "Eyes",
                    buttonIcon: "img/menuUI/shop/categoryIcons/eyes.svg",
                    buttonIconSize: 1.4,
                    shopCategoriesFilter: ["faceEyes"]
                }), this.createGridViewSubPage({
                    itemName: "Beard",
                    buttonIcon: "img/menuUI/shop/categoryIcons/face.svg",
                    buttonIconSize: 2.2,
                    shopCategoriesFilter: ["faceMustache", "faceBeard"],
                    colorButtonsCategory: "beard"
                }), this.createGridViewSubPage({
                    itemName: "Miscellaneous",
                    buttonIcon: "img/menuUI/shop/categoryIcons/misc.svg",
                    buttonIconSize: 1.4,
                    shopCategoriesFilter: ["faceMisc"]
                })]
            }, {
                itemName: "Gear",
                buttonIcon: "img/menuUI/shopChest.svg",
                buttonIconSize: 2,
                onBecomeVisible: () => {
                    this.resetSkinPreview()
                },
                subPages: [this.createGridViewSubPage({
                    itemName: "Head",
                    buttonIcon: "img/menuUI/shop/categoryIcons/head.svg",
                    buttonIconSize: 1.7,
                    shopCategoriesFilter: ["head"],
                    skinPreviewCamPosition: "head"
                }), this.createGridViewSubPage({
                    itemName: "Torso",
                    buttonIcon: "img/menuUI/shop/categoryIcons/torso.svg",
                    buttonIconSize: 1.7,
                    shopCategoriesFilter: ["torso"],
                    skinPreviewCamPosition: "torso"
                }), this.createGridViewSubPage({
                    itemName: "Arms",
                    buttonIcon: "img/menuUI/shop/categoryIcons/arms.svg",
                    buttonIconSize: 1.7,
                    shopCategoriesFilter: ["arms", "hands"],
                    skinPreviewCamPosition: "arms"
                }), this.createGridViewSubPage({
                    itemName: "Legs",
                    buttonIcon: "img/menuUI/shop/categoryIcons/legs.svg",
                    buttonIconSize: 1.7,
                    shopCategoriesFilter: ["legs", "feet"],
                    skinPreviewCamPosition: "legs"
                }), this.createGridViewSubPage({
                    itemName: "Quiver",
                    buttonIcon: "img/menuUI/shop/categoryIcons/quiver.svg",
                    buttonIconSize: 1.2,
                    shopCategoriesFilter: ["quiver"],
                    skinPreviewCamPosition: "quiver"
                })]
            }, n, this.createGridViewSubPage({
                itemName: "Uncategorized",
                shopCategoriesFilter: [],
                uncategorizedFilter: !0
            })]
        })
    }
    destructor() {
        this.closeCreatedDialogs();
        for (const {
            grid: t
        }
            of this.createdGrids.values()) t.destructor();
        this.createdGrids.clear(), this.skinPreview.destructor()
    }
    onBackButtonClick(t) {
        this.onBackButtonClickCbs.add(t)
    }
    closeCreatedDialogs() {
        for (const {
            grid: t
        }
            of this.createdGrids.values()) t.closeCreatedConfirmPurchaseDialogs()
    }
    loop(t, e) {
        this.skinPreview.loop(t, e)
    }
    updateShopState(t) {
        for (const {
            grid: e
        }
            of this.createdGrids.values()) e.setPurchasedItems(t)
    }
    highlightOrOpenShopItem(t, e, i) {
        let n, s;
        for (const e of t) {
            n = this.filterSubPages.get(e);
            break
        }
        if (!n) throw new Error(`No subpage structure found for shop item "${e}"`);
        this.pagedView.jumpToSubPage(n);
        for (const {
            grid: t,
            pagedViewStructure: e
        }
            of this.createdGrids.values())
            if (e === n) {
                s = t;
                break
            } if (!s) throw new Error("Assertion failed, no grid was created for the subpage");
        s.performHighlightShopItemAction(e, i)
    }
    resetSkinPreview({
                         camPosition: t = "full"
                     } = {}) {
        this.skinPreview.setActiveSlotPosition(t), this.skinPreview.setSkeletonPose(null), this.skinPreview.setBow(null)
    }
    createBowGridViewConfig(t, e) {
        let i = "full",
            n = [];
        return "handle" == e ? (i = t.bowHandleShopCamPosition, n = t.bowHandleShopCategories) : "tip" == e && (i = t.bowTipShopCamPosition, n = t.bowTipShopCategories), {
            shopCategoriesFilter: n,
            skinPreviewCamPosition: i,
            skeletonPose: `${t.bowId}/shootingLoaded`,
            bowId: t.bowId
        }
    }
    createGridViewSubPage({
                              itemName: t,
                              buttonIcon: e,
                              buttonIconSize: i,
                              shopCategoriesFilter: n,
                              uncategorizedFilter: s = !1,
                              skinPreviewCamPosition: r = null,
                              skeletonPose: o = null,
                              bowId: a = null,
                              colorButtonsCategory: l = "none"
                          }) {
        const h = {
            itemName: t,
            buttonIcon: e,
            buttonIconSize: i,
            buttonVisible: () => {
                const t = uc().config.shopConfig.loadedConfigData;
                if (!t) return !0;
                const e = this.getCurrentSkinData().gender || "male";
                return this.filterPurchasableItems(t.purchasableItems, {
                    shopCategoriesFilter: n,
                    uncategorizedFilter: s,
                    gender: e
                }).length > 0
            },
            onBecomeVisible: () => {
                r && this.skinPreview.setActiveSlotPosition(r), this.skinPreview.setSkeletonPose(o), this.skinPreview.setBow(a)
            },
            customSubPage: t => {
                this.createShopItemsGrid(t, {
                    shopCategoriesFilter: n,
                    uncategorizedFilter: s,
                    pagedViewStructure: h,
                    colorButtonsCategory: l
                })
            },
            customSubPageDestroyed: t => {
                this.destroyShopItemsGrid(t)
            }
        };
        if ("none" != l && (h.rightCorner = t => {
            t.classList.add("shop-color-buttons-corner");
            for (const {
                cssColor: e,
                skinColor: i
            }
                of Oa) {
                const n = document.createElement("button");
                n.classList.add("shop-color-button"), n.style.backgroundColor = e, t.appendChild(n), n.addEventListener("click", (() => {
                    const t = uc().skins;
                    "preset" == this.customizationId.type ? t.setPresetSkinItemColor(this.customizationId.presetId, l, i) : "class" == this.customizationId.type && t.setClassSkinItemColor(this.customizationId.classId, l, i), this.updateSkinPreviewConfig();
                    const e = this.getShopItemRenderOptions(l);
                    for (const t of this.createdGrids.values()) t.grid.setRenderOptions(e)
                })), n.addEventListener("mouseenter", (() => {
                    this.skinPreview.setTemporaryColorCategory(l, i)
                })), n.addEventListener("mouseleave", (() => {
                    this.skinPreview.resetHoveringModel()
                }))
            }
        }), n)
            for (const t of n) this.filterSubPages.set(t, h);
        return h
    }
    filterPurchasableItems(t, {
        shopCategoriesFilter: e,
        uncategorizedFilter: i,
        gender: n
    }) {
        return i ? t.filter((t => !t.categories)) : t.filter((t => {
            if (!t.showFullBodyInShopItem && !t.bowSkin) {
                if ("male" == n && !t.maleSkin) return !1;
                if ("female" == n && !t.femaleSkin) return !1
            }
            if (t.categories)
                for (const i of t.categories)
                    if (e.includes(i)) return !0;
            return !1
        }))
    }
    getShopItemRenderOptions(t) {
        const e = this.getCurrentSkinData(),
            i = e.gender || "male";
        let n = [1, 1, 1];
        "hair" == t && e.hairColorMultiplier ? n = e.hairColorMultiplier : "eyebrows" == t && e.eyebrowColorMultiplier ? n = e.eyebrowColorMultiplier : "beard" == t && e.beardColorMultiplier && (n = e.beardColorMultiplier);
        return {
            colorMultiplier: n,
            gender: i
        }
    }
    createShopItemsGrid(t, {
        shopCategoriesFilter: e,
        uncategorizedFilter: i,
        pagedViewStructure: n,
        colorButtonsCategory: s
    }) {
        const r = new Za;
        t.appendChild(r.el);
        const o = t => {
                const n = this.getShopItemRenderOptions(s),
                    o = this.filterPurchasableItems(t.purchasableItems, {
                        shopCategoriesFilter: e,
                        uncategorizedFilter: i,
                        gender: n.gender
                    });
                r.loadShopItems(o, {
                    renderOptions: n
                })
            },
            a = uc();
        if (a.config.shopConfig.onConfigChange(o), r.onHoveringItemChange((t => {
            let e = null;
            t && t.selected || (t && t.config && t.config.id && (e = t.config.id), e ? this.skinPreview.setHoveringShopItemId(e) : this.skinPreview.resetHoveringModel())
        })), r.setPurchasedItems(a.shopState.purchasedItems), "preset" == this.customizationId.type) {
            const t = this.customizationId.presetId,
                e = this.skinManager.getPreset(t),
                i = new Set(e.equippedSkinIds);
            r.setSelectedItems(i), r.onSelectedItemChangeRequest(((e, i) => {
                if (i) {
                    const i = this.skinManager.addShopItemToPreset(e, t);
                    for (const t of i) r.setSelectedItemState(t, !1)
                } else this.skinManager.removeShopItemFromPreset(e, t);
                r.setSelectedItemState(e, i), this.updateSkinPreviewConfig()
            }))
        } else if ("class" == this.customizationId.type) {
            const t = this.customizationId.classId;
            this.updateSelectedItemsForClass(t, r), r.onSelectedItemChangeRequest(((e, i) => {
                i ? this.skinManager.addShopItemToClass(e, t) : this.skinManager.removeShopItemFromClass(e, t), this.updateSelectedItemsForClass(t, r), this.updateSkinPreviewConfig()
            }))
        }
        this.createdGrids.set(t, {
            grid: r,
            onConfigChangeCb: o,
            pagedViewStructure: n
        })
    }
    updateSelectedItemsForClass(t, e) {
        const i = this.skinManager.getClassSkinData(t, !1);
        let n = [];
        if (null != i.presetId) {
            const t = this.skinManager.getPreset(i.presetId);
            t.equippedSkinIds && (n = t.equippedSkinIds)
        }
        const s = new Set(n);
        if (i.equippedSkinIds)
            for (const t of i.equippedSkinIds) this.skinManager.addItemAndRemoveDuplicateSlots(s, t);
        if (i.unequippedSkinIds)
            for (const t of i.unequippedSkinIds) s.delete(t);
        e.setSelectedItems(s)
    }
    getCurrentSkinData() {
        if ("preset" == this.customizationId.type) return this.skinManager.getPreset(this.customizationId.presetId);
        if ("class" == this.customizationId.type) return this.skinManager.getClassSkinDataWithAppliedPreset(this.customizationId.classId);
        throw new Error("Assertion failed, unknown customization type.")
    }
    updateSkinPreviewConfig() {
        const t = this.getCurrentSkinData();
        this.skinPreview.setCurrentSkinConfig(t)
    }
    destroyShopItemsGrid(t) {
        const e = this.createdGrids.get(t);
        if (!e) return;
        const {
            grid: i,
            onConfigChangeCb: n
        } = e;
        i.destructor(), this.createdGrids.delete(t), uc().config.shopConfig.removeOnConfigChange(n)
    }
}
class il {
    constructor(t, {
        extraClasses: e = []
    } = {}) {
        this.el = document.createElement("div"), this.el.classList.add("class-selection-image-container", "wrinkledPaper", "wrinkled-paper-mask", ...e), this.backgroundEl = document.createElement("div"), this.backgroundEl.classList.add("class-selection-image-background", "wrinkledPaper"), this.el.appendChild(this.backgroundEl), this.imageEl = document.createElement("div"), this.imageEl.classList.add("class-selection-image"), this.el.appendChild(this.imageEl), this.seed = pa(0, 99999);
        const i = `\n\t\t\t--wrinkled-paper-seed: ${this.seed};\n\t\t`;
        this.el.style.cssText = i, this.backgroundEl.style.cssText = i, this.classId = t;
        const n = uc().classSelectionImageManager;
        this.updateReference = n.createUpdateReference(t), this.updateReference.onBlobUrlChange((t => {
            this.imageEl.style.backgroundImage = `url("${t}")`
        })), this.updateReference.needsUpdates = !0
    }
    destructor() {
        this.updateReference.destructor()
    }
    set needsUpdates(t) {
        this.updateReference.needsUpdates = t
    }
    setTeamId(t) {
        const e = Ka[t];
        this.backgroundEl.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${this.seed};\n\t\t\t--wrinkled-paper-color: ${e.cssColor};\n\t\t\t--wrinkled-paper-border-color: ${e.cssColorDark};\n\t\t`
    }
}
class nl {
    constructor(t) {
        this.el = document.createElement("div"), this.el.classList.add("shop-skin-selection-item", "shop-class-selection-item");
        const e = document.createElement("h3");
        e.classList.add("dialogTitle", "blueNight"), e.textContent = t.uiName, this.el.appendChild(e), this.onClickCbs = new Set, this.classSelectionImage = new il(t.id), this.classSelectionImage.setTeamId(2), this.el.appendChild(this.classSelectionImage.el);
        const i = new Sa({
            text: "Edit",
            onClick: () => {
                this.onClickCbs.forEach((t => t()))
            },
            extraClasses: ["shop-skin-selection-edit-button"]
        });
        this.el.appendChild(i.el)
    }
    set needsAvatarUpdates(t) {
        this.classSelectionImage.needsUpdates = t
    }
    destructor() {
        this.classSelectionImage.destructor()
    }
    onClick(t) {
        this.onClickCbs.add(t)
    }
}
class sl {
    constructor({
                    preset: t,
                    onEditButtonClick: e,
                    showDeleteButton: i,
                    onDeleteButtonClick: n
                }) {
        this.el = document.createElement("div"), this.el.classList.add("shop-skin-selection-item");
        const s = document.createElement("div");
        s.classList.add("shop-skin-selection-image", "wrinkledPaper", "wrinkled-paper-mask"), s.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, this.el.appendChild(s);
        const r = new Sa({
            text: "Edit",
            onClick: e,
            extraClasses: ["shop-skin-selection-edit-button"]
        });
        this.el.appendChild(r.el);
        const o = uc().avatars.getAvatar({
            skinObjectOpts: {
                skin: t,
                teamId: 1
            },
            width: 200,
            height: 300,
            clipPathType: "none",
            cameraType: "full-body",
            backgroundColor: Ka[2].cssColor
        });
        if (this.avatarBlobUrlReference = o.getBlobUrlReference(), (async () => {
            const t = await this.avatarBlobUrlReference.getBlobUrl();
            s.style.backgroundImage = `url("${t}")`
        })(), i) {
            const t = new Sa({
                text: "x",
                extraClasses: ["corner-delete-button"],
                onClick: n
            });
            t.el.ariaLabel = "Delete preset", this.el.appendChild(t.el)
        }
    }
    destructor() {
        this.avatarBlobUrlReference.destructor()
    }
}
class rl {
    constructor(t) {
        this.skinManager = t, this.onPresetOpenClickCbs = new Set, this.onBackButtonClickCbs = new Set, this.el = document.createElement("div");
        const e = document.createElement("div");
        e.classList.add("dialog-title-header-container"), this.el.appendChild(e);
        const i = new Sa({
            isIconButton: !0,
            ariaLabel: "Back",
            icon: "img/arrow.svg",
            extraClasses: ["header-button", "header-back-button"],
            onClick: () => {
                this.onBackButtonClickCbs.forEach((t => t()))
            }
        });
        e.appendChild(i.el);
        const n = document.createElement("h2");
        n.textContent = "Presets", n.classList.add("dialogTitle", "blueNight", "shop-presets-title"), e.appendChild(n), this.presetsList = document.createElement("div"), this.presetsList.classList.add("shop-skin-selection-list"), this.el.appendChild(this.presetsList), this.createdPresetItems = [], this.addPresetButton = new Sa({
            text: "+",
            extraClasses: ["shop-skin-selection-list-add-button"],
            onClick: () => {
                t.addPreset(), this.updatePresetList(), this.presetsList.scroll(this.presetsList.scrollWidth, 0)
            }
        }), this.updatePresetList()
    }
    destructor() {
        for (const t of this.createdPresetItems) t.destructor()
    }
    updatePresetList() {
        for (; this.presetsList.firstChild;) this.presetsList.removeChild(this.presetsList.firstChild);
        const t = this.createdPresetItems;
        this.createdPresetItems = [];
        for (const [t, e] of this.skinManager.skinPresets.entries()) {
            const i = new sl({
                preset: e,
                onEditButtonClick: () => {
                    this.onPresetOpenClickCbs.forEach((e => e(t)))
                },
                showDeleteButton: this.skinManager.skinPresets.length > 1,
                onDeleteButtonClick: async () => {
                    uc().dialogManager.showAlert({
                        text: "Are you sure you want to delete this preset?",
                        buttons: [{
                            text: "Yes",
                            onClick: () => {
                                this.skinManager.deletePreset(t), this.updatePresetList()
                            }
                        }, {
                            text: "No"
                        }]
                    })
                }
            });
            this.presetsList.appendChild(i.el), this.createdPresetItems.push(i)
        }
        this.presetsList.appendChild(this.addPresetButton.el);
        for (const e of t) e.destructor()
    }
    onPresetOpenClick(t) {
        this.onPresetOpenClickCbs.add(t)
    }
    onBackButtonClick(t) {
        this.onBackButtonClickCbs.add(t)
    }
}
class ol extends Ma {
    constructor() {
        super({
            testLabel: "shop"
        }), this.currentCustomizationView = null, this.currentPresetsView = null, this.mainViewVisible = !0, this.ownedCoinsContainer = document.createElement("div"), this.ownedCoinsContainer.classList.add("ownedCoinsContainer", "wrinkledPaper", "allow-select"), this.el.appendChild(this.ownedCoinsContainer), this.currencyContainer = new xa;
        document.createElement("div").classList.add("currency-container"), this.ownedCoinsContainer.appendChild(this.currencyContainer.el), this.classSelectionContainer = document.createElement("div"), this.classSelectionContainer.classList.add("shop-class-selection-container"), this.el.appendChild(this.classSelectionContainer), this.presetsButton = new Sa({
            text: "Presets",
            onClick: () => {
                this.showPresetsView()
            }
        }), this.classSelectionContainer.appendChild(this.presetsButton.el), this.classSelectionListEl = document.createElement("div"), this.classSelectionListEl.classList.add("shop-skin-selection-list", "shop-class-selection-list"), this.classSelectionContainer.appendChild(this.classSelectionListEl), this.createdClassSelectionItems = [];
        for (const t of Ea) {
            const e = new nl(t);
            this.classSelectionListEl.appendChild(e.el), e.onClick((() => {
                this.showCustomizationView({
                    id: {
                        type: "class",
                        classId: t.id
                    },
                    rootHeader: t.uiName
                })
            })), this.createdClassSelectionItems.push(e)
        }
        this.boundUpdateShopState = this.updateShopState.bind(this), uc().shopState.onStateChanged(this.boundUpdateShopState), uc().shopState.fetchCurrentData(), this.updateShopState()
    }
    destructor() {
        uc().shopState.removeOnStateChanged(this.boundUpdateShopState), this.hideCustomizationView(), this.hidePresetsView(), super.destructor();
        for (const t of this.createdClassSelectionItems) t.destructor();
        this.createdClassSelectionItems = [], this.hidePresetsView()
    }
    onClose() {
        this.currentCustomizationView && this.currentCustomizationView.closeCreatedDialogs()
    }
    loop(t, e) {
        this.currentCustomizationView && this.currentCustomizationView.loop(t, e)
    }
    updateShopState() {
        this.currencyContainer.setAmount(uc().shopState.ownedCoins), this.currentCustomizationView && this.currentCustomizationView.updateShopState(uc().shopState.purchasedItems)
    }
    updateMainViewVisibility() {
        const t = null == this.currentCustomizationView && null == this.currentPresetsView;
        if (t != this.mainViewVisible) {
            this.mainViewVisible = t, this.classSelectionContainer.style.display = t ? "" : "none";
            for (const e of this.createdClassSelectionItems) e.needsAvatarUpdates = t
        }
    }
    showPresetCustomizationView(t) {
        this.showCustomizationView({
            id: {
                type: "preset",
                presetId: t
            },
            rootHeader: "Preset " + (t + 1)
        })
    }
    showCustomizationView(t) {
        if (this.currentCustomizationView) return;
        const e = uc().skins;
        this.currentCustomizationView = new el(e, t), this.el.appendChild(this.currentCustomizationView.el), this.currentCustomizationView.onBackButtonClick((() => {
            this.hideCustomizationView(), "preset" == t.id.type && this.showPresetsView(), this.updateMainViewVisibility()
        })), this.hidePresetsView(), this.updateMainViewVisibility()
    }
    hideCustomizationView() {
        this.currentCustomizationView && (this.el.contains(this.currentCustomizationView.el) && this.el.removeChild(this.currentCustomizationView.el), this.currentCustomizationView.destructor(), this.currentCustomizationView = null)
    }
    showPresetsView() {
        this.currentPresetsView || (this.currentPresetsView = new rl(uc().skins), this.currentPresetsView.onPresetOpenClick((t => {
            this.showPresetCustomizationView(t)
        })), this.currentPresetsView.onBackButtonClick((() => {
            this.hidePresetsView(), this.updateMainViewVisibility()
        })), this.el.appendChild(this.currentPresetsView.el), this.updateMainViewVisibility())
    }
    hidePresetsView() {
        this.currentPresetsView && (this.el.contains(this.currentPresetsView.el) && this.el.removeChild(this.currentPresetsView.el), this.currentPresetsView.destructor(), this.currentPresetsView = null)
    }
    openShopItemSubPage(t, e) {
        const i = uc(),
            n = i.skins,
            s = i.config.shopConfig.loadedConfigData;
        if (!s) throw new Error("Assertion failed, the shop config hasn't been loaded");
        const r = new Map;
        for (const t of Object.values(n.classSkins))
            if (null != t.presetId) {
                const e = r.get(t.presetId) || 0;
                r.set(t.presetId, e + 1)
            } let o = 0,
            a = 0;
        for (const [t, e] of r) e > a && (o = t, a = e);
        if (this.showPresetCustomizationView(o), !this.currentCustomizationView) throw new Error("Assertion failed, customization view not visible");
        const l = s.purchasableItems.find((e => e.id == t));
        if (!l) throw new Error(`The item "${t}" doesn't exist in the currently loaded shop config.`);
        if (l.categories) return this.currentCustomizationView.highlightOrOpenShopItem(l.categories, t, e);
        throw new Error("Uncategorized shop items are not supported yet")
    }
    highlightShopItem(t, e = !1) {
        this.openShopItemSubPage(t, "highlight-and-equip")
    }
    openShopItem(t) {
        this.openShopItemSubPage(t, "open")
    }
}
class al extends Ma {
    constructor() {
        super(), this.userNameText = document.createElement("input"), this.userNameText.placeholder = "Username", this.userNameText.maxLength = 20, this.userNameText.addEventListener("change", (async () => {
            await uc().profileState.setUsername(this.userNameText.value) || (this.userNameText.value = uc().profileState.username)
        })), this.el.appendChild(this.userNameText), this.addButtonsContainer(), this.linkAccountButton = this.addButton({
            text: "Link account",
            onClick: async () => {
                const t = await uc().auth.showLoginDialog("linknew");
                if (t.success) uc().dialogManager.showAlert({
                    title: "Account linked",
                    text: "You can now use this account for logging in as well."
                });
                else if ("account-already-exists" == t.error && t.usedIdToken && t.usedNonce) {
                    const {
                        usedIdToken: e,
                        usedNonce: i
                    } = t;
                    uc().dialogManager.showAlert({
                        title: "Account already exists",
                        text: "Would you like to merge the existing account with this one?",
                        buttons: [{
                            text: "Cancel"
                        }, {
                            text: "Merge Accounts",
                            onClick: async () => {
                                await uc().auth.mergeAccountToCurrent(e, i) ? uc().dialogManager.showAlert({
                                    title: "Accounts merged",
                                    text: "The accounts have been merged."
                                }) : uc().dialogManager.showAlert({
                                    title: "Merge error",
                                    text: "An error occurred while merging the accounts."
                                })
                            }
                        }]
                    })
                } else {
                    let e = "An error occurred while trying to link your account.";
                    "already-linked" == t.error ? e = "This account is already linked to you." : console.error("Account link error: " + t.error), uc().dialogManager.showAlert({
                        title: "Account linking failed",
                        text: e
                    })
                }
            }
        }), this.linkAccountButton.visible = !1, this.logoutButton = this.addButton({
            text: "Logout",
            onClick: async () => {
                await uc().auth.logout() ? this.close() : uc().dialogManager.showAlert({
                    title: "Error logging out",
                    text: "An error occurred while logging out everywhere."
                })
            }
        }), this.logoutButton.visible = !1, this.logoutEverywhereButton = this.addButton({
            text: "Logout everywhere",
            onClick: async () => {
                await uc().auth.logoutEverywhere() ? this.close() : uc().dialogManager.showAlert({
                    title: "Error logging out",
                    text: "An error occurred while logging out everywhere."
                })
            }
        }), this.logoutEverywhereButton.visible = !1, this.init()
    }
    async init() {
        await uc().auth.loginIfNotLoggedIn(!0) ? (this.linkAccountButton.visible = !0, this.logoutButton.visible = !0, this.logoutEverywhereButton.visible = !0) : this.close(), this.boundUpdateProfileState = this.updateProfileState.bind(this), uc().profileState.onStateChanged(this.boundUpdateProfileState), uc().profileState.fetchCurrentData(), this.updateProfileState()
    }
    updateProfileState() {
        this.userNameText.value = uc().profileState.username
    }
}
class ll {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("main-menu-corner-profile"), this.usernameEl = document.createElement("div"), this.usernameEl.classList.add("main-menu-username", "blueNight", "whiteBigText"), this.usernameEl.textContent = "Guest", this.el.appendChild(this.usernameEl), this.ownedCoins = new xa({
            testLabel: "cornerProfile"
        }), this.el.appendChild(this.ownedCoins.el)
    }
    init() {
        uc().shopState.onStateChanged((() => {
            this.ownedCoins.setAmount(uc().shopState.ownedCoins)
        })), uc().profileState.onStateChanged((() => {
            this.setUsername(uc().profileState.username)
        }))
    }
    setUsername(t) {
        t || (t = "Guest"), this.usernameEl.textContent = t, this.usernameEl.classList.toggle("blueNight", function(t, e = !0) {
            e && (t = t.toLowerCase());
            for (const e of t)
                if (!" !%*+,-.:;=?0123456789abcdefghijklmnopqrstuvwxyz".includes(e)) return !1;
            return !0
        }(t))
    }
}
class hl {
    constructor(t, e, i, n, s, r, o, a) {
        this.configManager = t, this.mainMenu = e, this.gameManager = i, this.shopStateManager = n, this.pokiManager = s, this.dialogManager = r, this.skinManager = o, this.indexedDb = a, this.promoViewData = new Map, this.activePromo = null, this.activePromos = [], this.el = document.createElement("div"), this.el.classList.add("main-menu-promo-banner-container", "hidden"), this.bannerEl = document.createElement("div"), this.bannerEl.classList.add("main-menu-promo-banner", "wrinkledPaper", "wrinkled-paper-mask"), this.bannerEl.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, this.el.appendChild(this.bannerEl), this.bannerEl.addEventListener("click", (() => {
            this.onPromoClick()
        })), this.button = new Sa({
            text: "",
            extraClasses: ["main-menu-promo-button"],
            onClick: () => {
                this.onPromoClick()
            }
        }), this.el.appendChild(this.button.el)
    }
    async init() {
        await this.loadPromoViewData(), this.configManager.promosConfig.onConfigChange((t => {
            this.activePromos = t.activePromos, this.loadNewBestPromo()
        })), this.shopStateManager.onStateChanged((() => {
            const t = this.activePromo?.actionShopItem;
            t && this.shopStateManager.itemIsPurchased(t) && this.loadNewBestPromo()
        })), this.mainMenu.onVisibilityChange((() => {
            this.updateVisibility()
        })), this.gameManager.onIsInGamesLoopChange((() => {
            this.updateVisibility()
        }))
    }
    loadNewBestPromo() {
        const t = new Set(this.promoViewData.keys());
        let e = null,
            i = 1 / 0,
            n = this.activePromos;
        for (const s of n) {
            if (!s || !s.id || !s.image) continue;
            if (s.actionShopItem && this.shopStateManager.itemIsPurchased(s.actionShopItem)) continue;
            if (s.seasonalRange) {
                const t = s.seasonalRange;
                if (t.startDay && t.endDay && t.startMonth && t.endMonth) {
                    const e = new Date,
                        i = new Date(e.getFullYear(), t.startMonth - 1, t.startDay),
                        n = new Date(e.getFullYear(), t.endMonth - 1, t.endDay),
                        s = new Date(e.getFullYear(), e.getMonth(), e.getDate());
                    if (s < i || s > n) continue
                }
            }
            t.delete(s.id);
            const n = this.getPromoViewData(s.id),
                r = s.maxViewCount || 5; - 1 != r && n.viewCount >= r || n.viewCount < i && (e = s, i = n.viewCount)
        }
        for (const e of t) this.promoViewData.delete(e);
        this.setActivePromo(e)
    }
    async loadPromoViewData() {
        let t = await this.indexedDb.get("promoViewData");
        t || (t = []), this.promoViewData = new Map;
        for (const e of t) e && e.id && this.promoViewData.set(e.id, e)
    }
    async savePromoViewData() {
        const t = [];
        for (const e of this.promoViewData.values()) t.push(e);
        await this.indexedDb.set("promoViewData", t)
    }
    setActivePromo(t) {
        if (this.el.classList.add("hidden"), !t || !t.id || !t.image) return;
        this.activePromo = t;
        const e = `url("${this.configManager.basePath}promos/${t.image}")`;
        this.bannerEl.style.backgroundImage = `${e}`, this.bannerEl.style.backgroundImage = `${e} !important`, t.buttonText && this.button.setText(t.buttonText), t.buttonIcon ? this.button.setIcon(`img/${t.buttonIcon}`) : this.button.setIcon(null), this.button.visible = !!t.buttonText, this.updateVisibility(), this.updatePromoViewdata(t.id, (t => {
            t.viewCount++
        }))
    }
    async onPromoClick() {
        if (!this.activePromo) return;
        let t = "highlightShopItem";
        if (this.activePromo.action && (t = this.activePromo.action), "highlightShopItem" == t) {
            if (this.activePromo.actionShopItem) {
                this.mainMenu.openShopDialog().highlightShopItem(this.activePromo.actionShopItem)
            }
        } else if ("openShopItem" == t) {
            if (this.activePromo.actionShopItem) {
                this.mainMenu.openShopDialog().openShopItem(this.activePromo.actionShopItem)
            }
        } else if ("purchaseRewardedShopItem" == t) {
            const t = this.activePromo.actionShopItem;
            if (t) {
                const e = this.configManager.shopConfig.getPurchaseableItem(t);
                if (e && !e.price && e.hasRewardedAd) {
                    const i = this.mainMenu.openShopDialog(),
                        n = await this.shopStateManager.purchaseItem(e, this.pokiManager, this.dialogManager, this.skinManager);
                    i.highlightShopItem(t, n)
                }
            }
        } else if ("openShop" == t) this.mainMenu.openShopDialog();
        else if ("openUrl" == t) {
            const t = this.activePromo.actionOpenUrl;
            t && window.open(t, "_blank", "noopener,noreferrer")
        }
    }
    updateVisibility() {
        let t = !!this.activePromo;
        this.gameManager.isInGamesLoop && (t = !1), this.el.classList.toggle("hidden", !t)
    }
    getPromoViewData(t) {
        const e = this.promoViewData.get(t);
        return e || {
            id: t,
            viewCount: 0
        }
    }
    updatePromoViewdata(t, e) {
        let i = this.getPromoViewData(t);
        const n = e(i);
        n && (i = n), this.promoViewData.set(t, i), this.savePromoViewData()
    }
}
class cl {
    constructor({
                    value: t = "",
                    placeholder: e = "",
                    extraClasses: i = [],
                    onInput: n = null,
                    spellCheck: s = !1,
                    maxLength: r = null
                } = {}) {
        this.el = document.createElement("input"), this.el.value = t, this.el.placeholder = e, this.el.classList.add("dialog-text-input", "blueNight", "wrinkledPaper", ...i), s || (this.el.autocomplete = "off", this.el.setAttribute("autocorrect", "off"), this.el.autocapitalize = "off", this.el.spellcheck = !1), null != r && (this.el.maxLength = r), n && this.el.addEventListener("input", n)
    }
    get value() {
        return this.el.value
    }
    set value(t) {
        this.el.value = t
    }
}
class dl extends Error {
    constructor() {
        super("Unable to connect to matchmake server")
    }
}
class ul extends Ma {
    constructor(t) {
        super(), this.squadManager = t, this.settings = new Map, this.settings.set("privateSquad", new Ca({
            text: "Private squad",
            type: "toggle",
            min: 0,
            max: 100
        })), this.leaderOnlyMessage = document.createElement("div"), this.leaderOnlyMessage.classList.add("squad-settings-leader-only-message"), this.leaderOnlyMessage.textContent = "Only the squad leader can change these settings.", this.el.appendChild(this.leaderOnlyMessage);
        for (const [e, i] of this.settings) t.currentSquadSettings && i.setValue(t.currentSquadSettings[e]), this.el.appendChild(i.el), i.onValueChange((i => {
            t.setSquadSetting(e, i)
        }));
        t.onSquadSettingChange(((t, e) => {
            const i = this.settings.get(t);
            i && i.setValue(e)
        })), t.onMySquadLeaderStateChange((() => {
            this.updateLeaderState()
        })), this.updateLeaderState()
    }
    updateLeaderState() {
        const t = this.squadManager.myClientIsSquadLeader;
        this.leaderOnlyMessage.style.display = t ? "none" : "";
        for (const e of this.settings.values()) e.setDisabled(!t)
    }
}
class pl extends Ma {
    constructor(t, e, i, n, s) {
        super(), this.networkManager = t, this.squadManager = e, this.gameManager = i, this.avatarsManager = n, this.skinManager = s;
        const r = document.createElement("div");
        r.classList.add("squad-split-container"), this.el.appendChild(r);
        const o = document.createElement("div");
        o.classList.add("squad-split-section"), r.appendChild(o);
        const a = document.createElement("h3");
        a.classList.add("dialogTitle", "blueNight"), a.textContent = "Invite someone", o.appendChild(a);
        const l = document.createElement("div");
        l.classList.add("squad-id-block"), o.appendChild(l);
        const h = document.createElement("div");
        h.textContent = "Invite Code:", l.appendChild(h);
        const c = document.createElement("div");
        c.classList.add("squad-id-container"), l.appendChild(c), this.currentSquadId = null, this.squadIdText = document.createElement("div"), this.squadIdText.classList.add("allow-select", "squad-id"), c.appendChild(this.squadIdText), this.copyUrlButton = document.createElement("div"), this.copyUrlButton.classList.add("squad-id-button", "icon-button", "copy-squad-url-button"), c.appendChild(this.copyUrlButton);
        const d = document.createElement("div");
        d.classList.add("squad-id-copied-text"), d.textContent = "Copied!", this.copyUrlButton.appendChild(d), this.copyUrlButton.addEventListener("click", (async () => {
            null != this.currentSquadId && (await navigator.clipboard.writeText(this.currentSquadId), d.classList.remove("animating"), d.offsetHeight, d.classList.add("animating"))
        })), this.clipboardPermissionGranted = !1, this.updateCopyUrlButtonVisibility(), this.queryClipboardPermission();
        const u = document.createElement("div");
        u.classList.add("squad-split-divider"), r.appendChild(u);
        const p = document.createElement("div");
        p.classList.add("squad-split-divider-line", "wrinkledLine"), p.style.cssText = "--wrinkled-line-seed: 18", u.appendChild(p);
        const m = document.createElement("span");
        m.textContent = "or", u.appendChild(m);
        const g = document.createElement("div");
        g.classList.add("squad-split-divider-line", "wrinkledLine"), g.style.cssText = "--wrinkled-line-seed: 12", u.appendChild(g);
        const f = document.createElement("div");
        f.classList.add("squad-split-section"), r.appendChild(f);
        const y = document.createElement("h3");
        y.classList.add("dialogTitle", "blueNight"), y.textContent = "Join existing squad", f.appendChild(y);
        const v = document.createElement("form");
        v.classList.add("text-with-submit-form"), f.appendChild(v), v.addEventListener("submit", (async t => {
            if (t.preventDefault(), this.networkManager.hasGameServerConnection) {
                const t = uc().dialogManager.showAlert({
                    title: "Are you sure?",
                    text: "If you join this squad, you'll leave the current match.",
                    buttons: [{
                        text: "Yes"
                    }, {
                        text: "No"
                    }]
                });
                if (0 != await t.waitForButton()) return
            }
            e.joinExistingSquad(this.joinSquadIdInput.value)
        })), this.joinSquadIdInput = new cl({
            placeholder: "Enter a code",
            extraClasses: ["join-squad-input"],
            maxLength: 8,
            onInput: () => {
                this.updateJoinButtonVisibility()
            }
        }), v.appendChild(this.joinSquadIdInput.el), this.joinSquadIdButton = new Sa({
            text: "Join"
        }), v.appendChild(this.joinSquadIdButton.el), this.updateJoinButtonVisibility();
        const w = document.createElement("div");
        w.classList.add("in-squad-content"), this.el.appendChild(w);
        const b = document.createElement("div");
        b.classList.add("squad-players-list", "wrinkledPaper", "wrinkled-paper-mask"), b.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, w.appendChild(b);
        const x = document.createElement("table");
        x.classList.add("itemsTable"), b.appendChild(x), this.membersTbody = document.createElement("tbody"), x.appendChild(this.membersTbody), this.inSquadButtonsContainer = document.createElement("div"), this.inSquadButtonsContainer.classList.add("in-squad-buttons"), w.appendChild(this.inSquadButtonsContainer);
        const S = new Sa({
            text: "Ready",
            onClick: () => {
                i.joinGameWithoutAd()
            }
        });
        this.inSquadButtonsContainer.appendChild(S.el), S.enabled = i.readyToJoin, this.boundOnReadyToJoinChange = t => {
            S.enabled = t
        }, i.onReadyToJoinChange(this.boundOnReadyToJoinChange), this.startButton = new Sa({
            text: "Start",
            onClick: () => {
                e.startSquad()
            }
        }), this.inSquadButtonsContainer.appendChild(this.startButton.el), this.squadSettingsDialog = null;
        const M = document.createElement("div");
        M.classList.add("squad-settings-button", "icon-button"), this.el.appendChild(M), M.addEventListener("click", (() => {
            this.squadSettingsDialog || (this.squadSettingsDialog = new ul(this.squadManager), uc().dialogManager.addDialog(this.squadSettingsDialog), this.squadSettingsDialog.addOnCloseCb((() => {
                this.squadSettingsDialog = null
            })))
        })), this.currentAvatarBlobUrlReferences = new Set, this.boundUpdateSquadId = this.updateSquadId.bind(this), this.boundOnSquadIdChange = this.onSquadIdChanged.bind(this), e.onUserVisibleSquadIdChange(this.boundOnSquadIdChange), e.onIsJoiningSquadChange(this.boundUpdateSquadId), this.boundUpdateMembersUi = this.updateMembersUi.bind(this), e.onSquadMembersChange(this.boundUpdateMembersUi), this.boundUpdateStartButtonEnabled = this.updateStartButtonEnabled.bind(this), e.onServerReadyForStartStateChange(this.boundUpdateStartButtonEnabled), this.boundUpdateStartButtonEnabledFromStartClicked = () => {
            this.updateStartButtonEnabled(!0)
        }, e.onStartClickedChange(this.boundUpdateStartButtonEnabledFromStartClicked), this.boundOnInGameChange = () => {
            this.updateReadyStartButtonVisibility()
        }, i.onCurrentGameChange(this.boundOnInGameChange), this.updateSquadId(), this.updateMembersUi(), this.updateReadyStartButtonVisibility(), this.handleRequestInitialSquadId()
    }
    destructor() {
        super.destructor(), this.squadManager.removeOnUserVisibleSquadIdChange(this.boundOnSquadIdChange), this.squadManager.removeOnIsJoiningSquadChange(this.boundUpdateSquadId), this.squadManager.removeOnSquadMembersChange(this.boundUpdateMembersUi), this.squadManager.removeOnServerReadyForStartStateChange(this.boundUpdateStartButtonEnabled), this.squadManager.removeOnStartClickedChange(this.boundUpdateStartButtonEnabledFromStartClicked), this.gameManager.removeOnReadyToJoinChange(this.boundOnReadyToJoinChange), this.gameManager.removeOnCurrentGameChange(this.boundOnInGameChange), this.squadSettingsDialog && this.squadSettingsDialog.close();
        for (const t of this.currentAvatarBlobUrlReferences) t.destructor();
        this.currentAvatarBlobUrlReferences.clear()
    }
    async handleRequestInitialSquadId() {
        try {
            await this.squadManager.requestInitialSquadId()
        } catch (t) {
            console.error(t);
            let e = "An unknown error occurred while requesting the squad id.";
            t instanceof dl && (e = "Could not connect to the server. Please try again later."), uc().dialogManager.showAlert({
                title: "Error getting squad id",
                text: e
            }), this.close()
        }
    }
    onSquadIdChanged() {
        let t = this.squadManager.userVisibleSquadId;
        t && (t = t.trim().toUpperCase()), this.joinSquadIdInput.value.trim().toUpperCase() == t && (this.joinSquadIdInput.value = ""), this.updateSquadId(), this.updateReadyStartButtonVisibility()
    }
    updateSquadId() {
        let t = "...",
            e = null;
        this.squadManager.userVisibleSquadId && !this.squadManager.isJoiningSquad && (t = this.squadManager.userVisibleSquadId, e = this.squadManager.userVisibleSquadId), this.currentSquadId = e, this.squadIdText.textContent = t, this.updateCopyUrlButtonVisibility()
    }
    async queryClipboardPermission() {
        let t;
        try {
            t = (await navigator.permissions.query({
                name: "clipboard-write"
            })).state
        } catch {
            this.clipboardPermissionGranted = !1
        }
        "granted" == t && (this.clipboardPermissionGranted = !0), this.updateCopyUrlButtonVisibility()
    }
    updateCopyUrlButtonVisibility() {
        const t = this.clipboardPermissionGranted && !!this.currentSquadId;
        this.copyUrlButton.style.display = t ? "" : "none"
    }
    updateMembersUi() {
        for (; this.membersTbody.firstChild;) this.membersTbody.removeChild(this.membersTbody.firstChild);
        const t = Array.from(this.squadManager.getMatchMakeSquadMembers()),
            e = t.every((t => t.ready)),
            i = t.every((t => t.joined)),
            n = Array.from(this.currentAvatarBlobUrlReferences);
        this.currentAvatarBlobUrlReferences.clear();
        for (const n of t) {
            const t = document.createElement("tr");
            this.membersTbody.appendChild(t), t.style.cssText = `\n\t\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t\t`;
            const s = document.createElement("td");
            if (s.classList.add("squad-players-leader-container"), t.appendChild(s), n.leader) {
                const t = document.createElement("div");
                t.classList.add("squad-leader-icon"), s.appendChild(t)
            }
            const r = document.createElement("td");
            r.classList.add("squad-players-avatar-container"), t.appendChild(r);
            const o = document.createElement("div");
            o.classList.add("player-list-avatar"), r.appendChild(o);
            const a = 40 * globalThis.devicePixelRatio,
                l = this.avatarsManager.getAvatar({
                    backgroundColor: Ka[n.teamId].cssColor,
                    width: a,
                    height: a,
                    skinObjectOpts: {
                        teamId: n.teamId,
                        skin: n.skinData
                    }
                }).getBlobUrlReference();
            this.currentAvatarBlobUrlReferences.add(l), (async () => {
                const t = await l.getBlobUrl();
                o.style.backgroundImage = `url("${t}")`
            })();
            const h = document.createElement("td");
            t.appendChild(h), h.textContent = n.name;
            let c = "";
            if (n.joined && !i ? c = "Joined" : n.ready && !e && (c = "Ready"), c) {
                const t = document.createElement("span");
                t.classList.add("players-list-label"), t.textContent = c, h.appendChild(t)
            }
        }
        for (const t of n) t.destructor();
        this.updateStartButtonEnabled()
    }
    updateJoinButtonVisibility() {
        const t = this.joinSquadIdInput.value.trim().length > 0;
        this.joinSquadIdButton.el.style.display = t ? "" : "none"
    }
    updateStartButtonEnabled(t = !1) {
        this.startButton.enabled = this.squadManager.serverReadyForStartState && !this.squadManager.startClicked, this.squadManager.startClicked && t && (this.close(), uc().input.lockPointer())
    }
    updateReadyStartButtonVisibility() {
        let t = !1;
        for (const e of this.squadManager.getMatchMakeSquadMembers()) {
            t = !0;
            break
        }
        const e = !this.gameManager.currentGame && null != this.squadManager.userVisibleSquadId && t;
        this.inSquadButtonsContainer.classList.toggle("hidden", !e)
    }
}
class ml {
    constructor(t, e) {
        this.onJoinClickedCbs = new Set, this.el = document.createElement("div"), this.el.classList.add("map-item"), this.titleEl = document.createElement("h2"), this.titleEl.classList.add("map-item-title", "blueNight"), this.titleEl.textContent = e.name, this.el.appendChild(this.titleEl), this.thumbEl = document.createElement("div"), this.thumbEl.classList.add("map-item-thumb", "wrinkled-paper-mask"), this.el.appendChild(this.thumbEl);
        const i = `url("${t.basePath}mapThumbs/${e.assetName}.webp")`;
        this.thumbEl.style.cssText = `\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, this.thumbEl.style.backgroundImage = `${i}`, this.thumbEl.style.backgroundImage = `${i} !important`;
        const n = new Sa({
            text: "Join",
            extraClasses: ["map-item-join-button"],
            onClick: () => {
                this.onJoinClickedCbs.forEach((t => t()))
            }
        });
        this.el.appendChild(n.el)
    }
    onJoinClicked(t) {
        this.onJoinClickedCbs.add(t)
    }
}
class gl extends Ma {
    constructor(t, e, i) {
        super(), this.configManager = t, this.preferredMapManager = e, this.gameManager = i, this.mapsContainer = document.createElement("div"), this.mapsContainer.classList.add("maps-container"), this.el.appendChild(this.mapsContainer), this.maps = [], this.configManager.mapsConfig.onConfigChange((t => {
            this.updateMaps(t)
        }))
    }
    updateMaps(t) {
        for (this.maps = []; this.mapsContainer.firstChild;) this.mapsContainer.removeChild(this.mapsContainer.firstChild);
        for (const e of t.maps) {
            const t = new ml(this.configManager, e);
            this.maps.push(t), this.mapsContainer.appendChild(t.el), t.onJoinClicked((async () => {
                this.preferredMapManager.forceSoloMap(e.hash);
                await this.gameManager.checkExistingGameAndJoin() ? this.close() : this.preferredMapManager.disableForcedSoloMap()
            }))
        }
    }
}
class fl {
    constructor() {
        if (this.el = document.getElementById("mainMenu"), !this.el) throw new Error("Main menu element not found");
        if (this.loadingImageContainer = document.getElementById("loadingImageContainer"), !this.loadingImageContainer) throw new Error("Loading image container element not found");
        if (this.bottomTextEl = document.getElementById("mainMenuBottomText"), !this.bottomTextEl) throw new Error("Main menu bottom text element not found");
        this.loadingTexts = new Set, this.el.addEventListener("click", (t => {
            t.target == this.el && this.onPointerLockElClick()
        })), this.webglCreationFailed = !1, this.currentJoinState = "loading", this.touchDeviceVisibilityState = !1, this.toggleMenuTouchButton = new Sa({
            isIconButton: !0,
            extraClasses: ["toggle-menu-touch-button"],
            icon: "img/menuUI/hamburger.svg",
            onClick: () => {
                this.touchDeviceVisibilityState = !0, this.updateVisibility()
            }
        }), this.toggleMenuTouchButton.visible = !1, document.body.appendChild(this.toggleMenuTouchButton.el), document.addEventListener("keydown", (t => {
            "Escape" == t.code && (this.touchDeviceVisibilityState = !0, this.updateVisibility())
        })), this.visible = !0, this.onVisibilityChangeCbs = new Set, this.cornerProfile = new ll, this.el.appendChild(this.cornerProfile.el), this.menuButtonsContainer = document.createElement("div"), this.menuButtonsContainer.classList.add("menuButtonsContainer"), this.el.appendChild(this.menuButtonsContainer), this.settingsDialog = null, this.settingsButton = new ba({
            text: "Settings",
            icon: "img/menuUI/settings.svg",
            iconSizeMultiplier: .6,
            testLabel: "settings",
            onClick: () => {
                const t = uc();
                this.settingsDialog = new _a(t.settingsManager, t.dialogManager, t.aprilFools), uc().dialogManager.addDialog(this.settingsDialog)
            }
        }), this.menuButtonsContainer.appendChild(this.settingsButton.containerEl), this.shopDialog = null, this.shopButton = new ba({
            text: "Shop",
            icon: "img/menuUI/shopChest.svg",
            testLabel: "shop",
            onClick: () => {
                this.openShopDialog()
            }
        }), this.menuButtonsContainer.appendChild(this.shopButton.containerEl), this.userProfileDialog = null, this.loginButton = new ba({
            text: "Account",
            icon: "img/menuUI/login.svg",
            testLabel: "account",
            onClick: () => {
                this.userProfileDialog || (this.userProfileDialog = new al, uc().dialogManager.addDialog(this.userProfileDialog), this.userProfileDialog.addOnCloseCb((() => {
                    this.userProfileDialog = null
                })))
            }
        }), this.menuButtonsContainer.appendChild(this.loginButton.containerEl), this.squadDialog = null, this.squadButton = new ba({
            text: "Squad",
            icon: "img/menuUI/squad.svg",
            iconSizeMultiplier: .8,
            testLabel: "squad",
            onClick: () => {
                this.openSquadDialog()
            }
        }), this.menuButtonsContainer.appendChild(this.squadButton.containerEl), this.mapsDialog = null, this.mapsButton = new ba({
            text: "Maps",
            icon: "img/menuUI/maps.svg",
            iconSizeMultiplier: .6,
            testLabel: "maps",
            onClick: () => {
                this.openMapsDialog()
            }
        }), this.menuButtonsContainer.appendChild(this.mapsButton.containerEl), this.promoBanner = null, this.currentMusicSfx = null, this.hideUi = !1
    }
    init() {
        const t = uc();
        t.input.onPointerLockChange((() => {
            this.updateVisibility()
        })), t.input.touch.onTouchSupportedChange((() => {
            this.updateVisibility()
        })), this.boundTestHideLoadingImage = this.testHideLoadingImage.bind(this), t.mapLoader.onMapContentLoaded(this.boundTestHideLoadingImage), t.input.touch.onTouchListenerClick((() => {
            this.onPointerLockElClick()
        })), t.gameManager.onGameEnd((() => {
            this.shopDialog && this.shopDialog.close(), this.settingsDialog && this.settingsDialog.close(), this.mapsDialog && this.mapsDialog.close(), this.updateVisibility()
        })), this.cornerProfile.init(), this.promoBanner = new hl(t.config, this, t.gameManager, t.shopState, t.poki, t.dialogManager, t.skins, t.indexedDb), this.el.appendChild(this.promoBanner.el), this.promoBanner.init(), t.network.squadManager.onSquadMembersChange((() => {
            this.updateSquadButtonText()
        })), t.network.squadManager.onUserVisibleSquadIdChange((() => {
            this.updateSquadButtonText()
        })), t.settingsManager.onValueChange("hideUi", (e => {
            this.hideUi = e;
            const i = t.gameManager.currentGame;
            i && i.updateUiVisible()
        })), t.dialogManager.onCurtainVisibilityChange((t => {
            this.el.inert = t
        }))
    }
    loop(t, e) {
        this.shopDialog && this.shopDialog.loop(t, e)
    }
    testHideLoadingImage() {
        uc().mapLoader.currentMapHasScene && uc().mapLoader.currentMapHasCamPositions && !this.webglCreationFailed && (this.loadingImageContainer.classList.add("hidden"), this.boundTestHideLoadingImage && uc().mapLoader.removeOnMapContentLoaded(this.boundTestHideLoadingImage), this.boundTestHideLoadingImage = null)
    }
    requestLoadingText(...t) {
        const e = new sa(...t);
        return this.loadingTexts.add(e), e.onStateChange((() => {
            this.updateLoadingText()
        })), this.updateLoadingText(), e
    }
    setJoinState(t) {
        this.currentJoinState = t, this.updateLoadingText(), this.updateVisibility(), this.updatePlayingMusic()
    }
    updateLoadingText() {
        let t = !0,
            e = null;
        this.webglCreationFailed && (e = "Failed to create WebGl context.", t = !1);
        const i = Array.from(this.loadingTexts);
        i.sort(((t, e) => t.priority - e.priority));
        for (const n of i) n.isLoading && (t = n.shouldBounce, e = n.getText());
        if (!e) switch (this.currentJoinState) {
            case "loading":
                e = "Loading...";
                break;
            case "joinable":
                e = "Click to join";
                break;
            case "joined":
                e = "Click to play"
        }
        this.bottomTextEl.textContent = e, this.bottomTextEl.classList.toggle("scaleBounce", t)
    }
    notifyWebglCreationFailed() {
        this.webglCreationFailed = !0, this.updateLoadingText()
    }
    updateSquadButtonText() {
        let t = "Squad";
        uc().network.squadManager.isInSquad && (t += ` (${uc().network.squadManager.totalSquadMemberCount})`), this.squadButton.setText(t)
    }
    async onPointerLockElClick() {
        if (this.webglCreationFailed) return;
        const t = uc();
        if ("joined" == this.currentJoinState) t.input.lockPointer();
        else {
            const e = t.network.squadManager;
            if (e.isInSquad || e.isJoiningSquad)
                if (e.isInSquad && 1 == e.totalSquadMemberCount && !e.matchMakeAllReady) {
                    t.gameManager.joinGameWithoutAd();
                    let i = !1;
                    setTimeout((() => {
                        i = !0
                    }), 5e3), await e.waitForServerReadyForStart(), i || e.startSquad()
                } else this.openSquadDialog();
            else t.gameManager.joinGameAfterAd()
        }
        this.touchDeviceVisibilityState && (this.touchDeviceVisibilityState = !1, this.updateVisibility())
    }
    updateVisibility() {
        let t = !0;
        if ("joined" == this.currentJoinState) {
            const e = uc().gameManager.currentGame,
                i = e && e.gameEnded;
            uc().input.pointerLocked || i ? t = !1 : uc().input.touch.touchSupported && (this.touchDeviceVisibilityState || (t = !1))
        }
        if (t != this.visible) {
            this.visible = t, this.setVisible(t);
            for (const e of this.onVisibilityChangeCbs) e(t)
        }
    }
    setVisible(t) {
        this.el.style.display = t ? "" : "none", uc().gameManager.updateSdkGameplayStarted(), this.toggleMenuTouchButton.visible = !t && uc().input.touch.touchSupported
    }
    onVisibilityChange(t) {
        this.onVisibilityChangeCbs.add(t)
    }
    removeOnVisibilityChange(t) {
        this.onVisibilityChangeCbs.delete(t)
    }
    get shouldPlayMusic() {
        return "joined" != this.currentJoinState
    }
    async updatePlayingMusic() {
        if (this.shouldPlayMusic != !!this.currentMusicSfx)
            if (this.shouldPlayMusic) {
                const t = await uc().sfx.playSound("music/mainMenu");
                !t || !this.currentMusicSfx && this.shouldPlayMusic ? this.currentMusicSfx = t || null : t.stop()
            } else this.currentMusicSfx && (this.currentMusicSfx.stop(), this.currentMusicSfx = null)
    }
    openShopDialog() {
        return this.shopDialog || (this.shopDialog = new ol, uc().dialogManager.addDialog(this.shopDialog), this.shopDialog.addOnCloseCb((() => {
            this.shopDialog = null
        }))), this.shopDialog
    }
    openSquadDialog() {
        this.squadDialog || (this.squadDialog = new pl(uc().network, uc().network.squadManager, uc().gameManager, uc().avatars, uc().skins), uc().dialogManager.addDialog(this.squadDialog), this.squadDialog.addOnCloseCb((() => {
            this.squadDialog = null
        })))
    }
    openMapsDialog() {
        if (this.mapsDialog) return;
        const t = uc();
        this.mapsDialog = new gl(t.config, t.preferredMapManager, t.gameManager), uc().dialogManager.addDialog(this.mapsDialog), this.mapsDialog.addOnCloseCb((() => {
            this.mapsDialog = null
        }))
    }
}
class yl {
    constructor() {
        this.visiblePages = new Set, this.desktopBanner = document.createElement("div"), this.desktopBanner.classList.add("gameAd", "desktop", "hidden"), document.body.appendChild(this.desktopBanner), this.mobileBanner = document.createElement("div"), this.mobileBanner.classList.add("gameAd", "mobile", "hidden"), document.body.appendChild(this.mobileBanner)
    }
    init() {
        uc().mainMenu.onVisibilityChange((t => {
            this.setPageVisibility("mainMenu", t && uc().gameManager.joinedOnce)
        })), uc().dialogManager.onCurtainZIndexChange((t => {
            const e = Math.max(100, t + 1);
            this.desktopBanner.style.zIndex = this.mobileBanner.style.zIndex = String(e)
        }))
    }
    setPageVisibility(t, e) {
        e ? this.visiblePages.add(t) : this.visiblePages.delete(t);
        const i = this.visiblePages.size > 0;
        this.desktopBanner.classList.toggle("hidden", !i), this.mobileBanner.classList.toggle("hidden", !i), uc().poki.updateBannerVisibility()
    }
}
class vl extends Ma {
    constructor({
                    title: t = "",
                    text: e = "",
                    buttons: i = [{
                        text: "ok",
                        testLabel: "ok",
                        onClick: void 0
                    }]
                } = {}) {
        super({
            testLabel: "alert"
        }), this.indexPriority = 3, this.titleEl = document.createElement("h2"), this.titleEl.classList.add("dialogTitle", "blueNight"), t && (this.titleEl.textContent = t), this.el.appendChild(this.titleEl), this.textEl = document.createElement("div"), this.textEl.classList.add("dialogText"), e && (this.textEl.textContent = e), this.el.appendChild(this.textEl), this.addButtonsContainer(), this.createdButtons = [];
        for (const t of i) {
            const e = this.addButton({
                text: t.text,
                testLabel: t.testLabel,
                onClick: async () => {
                    this.setButtonsEnabled(!1), t.onClick && await t.onClick(), this.close()
                }
            });
            this.createdButtons.push(e)
        }
    }
    setButtonsEnabled(t) {
        for (const e of this.createdButtons) e.enabled = t
    }
    async waitForButton() {
        return await new Promise((t => {
            for (const [e, i] of this.createdButtons.entries()) i.onClick((() => {
                t(e)
            }))
        }))
    }
}
class wl {
    constructor() {
        this.curtainEl = document.createElement("div"), this.curtainEl.classList.add("dialogCurtain", "fullScreen", "hidden"), document.body.appendChild(this.curtainEl), this._curtainElVisible = !1, this.onCurtainVisibilityChangeCbs = new Set, this.curtainEl.addEventListener("click", (t => {
            this.closeTopMostDialog()
        })), document.body.addEventListener("keydown", (t => {
            "Escape" == t.code && this.closeTopMostDialog()
        })), this.lastDialogAddTime = 0, this.currentDialogStack = [], this.onCurtainZIndexChangeCbs = new Set, this.onAnyDialogVisibilityChangeCbs = new Set, this.onAnyDialogVisibilityChange((() => {
            this.updateZIndices(), this.updateInertDialogs()
        }))
    }
    addDialog(t) {
        this.lastDialogAddTime = performance.now(), this.currentDialogStack.push(t), this.sortStack(), t.addOnVisibilityChangeCb((t => {
            this.fireAnyDialogVisibilityChangeCbs()
        })), t.addOnCloseCb((() => {
            const e = this.currentDialogStack.indexOf(t);
            this.currentDialogStack.splice(e, 1), this.fireAnyDialogVisibilityChangeCbs()
        })), this.fireAnyDialogVisibilityChangeCbs()
    }
    getDialogForEl(t) {
        for (const e of this.currentDialogStack)
            if (e.el == t || e.wrapperEl == t) return e;
        return null
    }
    get frontDialog() {
        if (this.currentDialogStack.length <= 0) return null;
        for (let t = this.currentDialogStack.length - 1; t >= 0; t--) {
            const e = this.currentDialogStack[t];
            if (e.visible) return e
        }
        return null
    }
    get firstClosableDialog() {
        for (let t = this.currentDialogStack.length - 1; t >= 0; t--) {
            const e = this.currentDialogStack[t];
            if (e.visible && e.allowCurtainClose) return e
        }
        return null
    }
    get hasAnyDialogs() {
        return this.currentDialogStack.some((t => t.visible))
    }
    get curtainElVisible() {
        return this._curtainElVisible
    }
    closeTopMostDialog() {
        performance.now() - this.lastDialogAddTime < 300 || this.firstClosableDialog && this.firstClosableDialog.close()
    }
    showAlert(t) {
        const e = new vl(t);
        return this.addDialog(e), e
    }
    onAnyDialogVisibilityChange(t) {
        this.onAnyDialogVisibilityChangeCbs.add(t)
    }
    fireAnyDialogVisibilityChangeCbs() {
        for (const t of this.onAnyDialogVisibilityChangeCbs) t()
    }
    sortStack() {
        this.currentDialogStack.sort(((t, e) => {
            const i = t.indexPriority,
                n = e.indexPriority;
            if (i > n) return 1;
            if (i < n) return -1;
            const s = this.currentDialogStack.indexOf(t),
                r = this.currentDialogStack.indexOf(e);
            return s > r ? 1 : s < r ? -1 : 0
        }))
    }
    updateZIndices() {
        let t = !1,
            e = 0;
        for (const [i, n] of this.currentDialogStack.entries()) {
            const s = 100 + 2 * i;
            n.setZIndex(s), n.visible && n.needsCurtain && (t = !0, e = s - 1)
        }
        t && this.setCurtainZIndex(e), t != this._curtainElVisible && (this._curtainElVisible = t, this.curtainEl.classList.toggle("hidden", !t), this.onCurtainVisibilityChangeCbs.forEach((e => e(t))))
    }
    updateInertDialogs() {
        const t = this.currentDialogStack.filter((t => t.visible));
        let e = null;
        t.length > 0 && (e = t[t.length - 1]);
        for (const t of this.currentDialogStack) t.setInert(t != e)
    }
    setCurtainZIndex(t) {
        this.curtainEl.style.zIndex = String(t);
        for (const e of this.onCurtainZIndexChangeCbs) e(t)
    }
    onCurtainZIndexChange(t) {
        this.onCurtainZIndexChangeCbs.add(t)
    }
    onCurtainVisibilityChange(t) {
        this.onCurtainVisibilityChangeCbs.add(t)
    }
    removeOnCurtainVisibilityChange(t) {
        this.onCurtainVisibilityChangeCbs.delete(t)
    }
}
class bl {
    constructor({
                    keyCodes: t = [],
                    mouseButtons: e = [],
                    gamepadButtons: i = []
                } = {}) {
        this.keyCodes = t, this.mouseButtons = e, this.gamepadButtons = i, this.pressed = !1, this.pressedGamepad = !1, this.onPressedChangeCbs = new Set, this.onPressedDownCbs = new Set, this.onPressedUpCbs = new Set
    }
    setKeyCodePressed(t, e, i) {
        let n = !1,
            s = !1;
        return this.keyCodes.includes(t) && (s = this.setKeyPressed(e, i), n = !0), {
            needsPreventDefault: n,
            preventOthers: s
        }
    }
    setMouseButtonPressed(t, e, i) {
        return !!this.mouseButtons.includes(t) && this.setKeyPressed(e, i)
    }
    setPressedGamepadButtons(t, e) {
        let i = !1;
        for (const e of this.gamepadButtons)
            if (t.includes(e)) {
                i = !0;
                break
            } return this.pressedGamepad != i && (this.pressedGamepad = i, this.setKeyPressed(i, e))
    }
    setKeyPressed(t, e) {
        let i = !1;
        if (t != this.pressed && (this.pressed = t, !e)) {
            for (const e of this.onPressedChangeCbs) {
                e(t) && (i = !0)
            }
            if (t)
                for (const t of this.onPressedDownCbs) {
                    t() && (i = !0)
                } else
                for (const t of this.onPressedUpCbs) {
                    t() && (i = !0)
                }
        }
        return i
    }
    onPressedChange(t) {
        this.onPressedChangeCbs.add(t)
    }
    onPressedDown(t) {
        this.onPressedDownCbs.add(t)
    }
    onPressedUp(t) {
        this.onPressedUpCbs.add(t)
    }
    removeCb(t) {
        const e = t;
        this.onPressedChangeCbs.delete(e), this.onPressedDownCbs.delete(e), this.onPressedUpCbs.delete(e)
    }
}
class xl {
    constructor({
                    responsiveArea: t = null,
                    cancelOthers: e = !0
                } = {}) {
        this.el = document.createElement("div"), document.body.appendChild(this.el), this.visible = !0, this.currentUsingTouchId = null, this.didUpdateTouchLastLoop = !1, this.responsiveArea = t, this.cancelOthers = e
    }
    updateTouch(t) {
        if (this.responsiveArea && (null == this.currentUsingTouchId || this.responsiveArea.cancelWhenLeaving) && !this.responsiveArea.testTouchInResponsiveArea(t)) return {
            didHit: !1
        };
        const e = this.onUpdateTouch(t);
        return e && (this.currentUsingTouchId = t.identifier, this.didUpdateTouchLastLoop = !0), {
            didHit: e,
            cancelOthers: e && this.cancelOthers
        }
    }
    onUpdateTouch(t) {
        return !1
    }
    endTouchLoop() {
        this.didUpdateTouchLastLoop || (this.currentUsingTouchId = null, this.onEndTouch()), this.didUpdateTouchLastLoop = !1
    }
    onEndTouch() {}
    setVisibility(t) {
        this.visible = t, this.el.style.display = t ? null : "none"
    }
}
class Sl {
    constructor(t = !1) {
        this.cancelWhenLeaving = t
    }
    testTouchInResponsiveArea(t) {
        return !1
    }
}
class Ml extends Sl {
    constructor(t, e, i) {
        super(i), this.pos = t || new h, this.radius = e
    }
    testTouchInResponsiveArea(t) {
        return new h(t.pageX, t.pageY).distanceTo(this.pos) < this.radius
    }
}
class Cl extends xl {
    constructor({
                    defaultPos: t = new h(0, 0),
                    hideWhenUsed: e = !0,
                    responsiveArea: i = null,
                    lockPosAtEnd: n = !0
                } = {}) {
        super({
            responsiveArea: i
        }), this.currentValue = new h, this.hideWhenUsed = e, this.el.classList.add("touchInputJoyStickContainer", "touchInputWhiteBorder"), this.stickEl = document.createElement("div"), this.stickEl.classList.add("touchInputJoyStick"), this.el.appendChild(this.stickEl), this.lastIsTouchingValue = !1, this.lastIsTouchingToggleTime = 0, this.doubleTapped = !1, this.setDefaultPos(t)
    }
    onUpdateTouch(t) {
        const e = new h(t.pageX, t.pageY);
        return null == this.currentUsingTouchId ? (this.onIsTouchingChange(!0), this.setPos(e), !0) : this.currentUsingTouchId == t.identifier ? (this.setStickPos(e), this.setOpacity(.1), !0) : void 0
    }
    onEndTouch() {
        this.onIsTouchingChange(!1), this.resetPos(), this.setOpacity(1)
    }
    onIsTouchingChange(t) {
        this.doubleTapped = !1, t != this.lastIsTouchingValue && (this.lastIsTouchingValue = t, uc().now - this.lastIsTouchingToggleTime < 200 && t && (this.doubleTapped = !0), this.lastIsTouchingToggleTime = uc().now)
    }
    setOpacity(t) {
        this.el.style.opacity = t
    }
    setDefaultPos(t) {
        this.defaultPos = t.clone(), this.responsiveArea instanceof Ml && this.responsiveArea.pos.copy(this.defaultPos), this.resetPos()
    }
    resetPos() {
        this.setPos(this.defaultPos), this.setStickPos(this.defaultPos)
    }
    setPos(t) {
        t = t.clone(), this.containerPos = t, this.el.style.transform = `translate(${t.x}px, ${t.y}px) translate(-50%, -50%)`
    }
    setStickPos(t) {
        const e = t.clone();
        e.sub(this.containerPos);
        const i = e.clone();
        e.clampLength(0, 40), this.currentValue = e.clone(), this.currentValue.divideScalar(40);
        const n = i.sub(e),
            s = this.containerPos.clone().add(n);
        s.x = da(s.x, 75, window.innerWidth - 75), s.y = da(s.y, 75, window.innerHeight - 75), this.stickEl.style.transform = `translate(${e.x}px, ${e.y}px) translate(-50%, -50%)`
    }
}
class _l extends xl {
    constructor() {
        super(), this.currentTouchId = null, this.prevTouchPos = new h, this.lastDeltaPos = new h
    }
    onUpdateTouch(t) {
        if (null == this.currentTouchId && (this.currentTouchId = t.identifier), this.currentTouchId != t.identifier) return;
        const e = new h(t.pageX, t.pageY);
        return null == this.currentUsingTouchId && this.prevTouchPos.copy(e), this.lastDeltaPos = e.clone().sub(this.prevTouchPos), this.prevTouchPos.copy(e), !0
    }
    onEndTouch() {
        this.lastDeltaPos = new h, this.currentTouchId = null
    }
}
class El extends xl {
    constructor({
                    left: t = null,
                    right: e = null,
                    top: i = null,
                    bottom: n = null,
                    responsiveArea: s = null,
                    img: r = null
                } = {}) {
        super({
            responsiveArea: s,
            cancelOthers: !1
        }), this.el.classList.add("touchInputButton", "touchInputWhiteBorder"), this.left = t, this.right = e, this.top = i, this.bottom = n, r && (this.el.style.backgroundImage = `url(${r})`), this.updatePosition(), ea.addListener((t => {
            this.updatePosition()
        })), this.linkedInputKeys = new Set, this.pressed = !1
    }
    updatePosition() {
        this.left && (this.el.style.left = this.left + "px"), this.right && (this.el.style.right = this.right + "px"), this.top && (this.el.style.top = this.top + "px"), this.bottom && (this.el.style.bottom = this.bottom + "px"), this.updateResponsiveAreaPos()
    }
    updateResponsiveAreaPos() {
        if (this.responsiveArea instanceof Ml) {
            const t = 35;
            let e = 0,
                i = 0;
            this.left && (e = this.left + t), this.top && (i = this.top + t), this.right && (e = window.innerWidth - this.right - t), this.bottom && (i = window.innerHeight - this.bottom - t), this.responsiveArea.pos.set(e, i)
        }
    }
    onUpdateTouch(t) {
        return this.setPressed(!0), !0
    }
    onEndTouch() {
        this.setPressed(!1)
    }
    setPressed(t) {
        this.pressed = t, this.setPressedClass();
        for (const e of this.linkedInputKeys) e.setKeyPressed(t)
    }
    setPressedClass() {
        this.el.classList.toggle("touching", this.pressed)
    }
    addInputKey(t) {
        this.linkedInputKeys.add(t)
    }
}
class Pl extends Sl {
    constructor(t, e, i, n, s) {
        super(s), this.left = t, this.right = e, this.top = i, this.bottom = n
    }
    testTouchInResponsiveArea(t) {
        const e = t.pageX / window.innerWidth,
            i = t.pageY / window.innerHeight;
        return e > this.left && e < this.right && i > this.top && i < this.bottom
    }
}
class Tl {
    constructor() {
        this.touchListener = document.createElement("div"), this.touchListener.classList.add("touchListener", "fullScreen"), document.body.appendChild(this.touchListener), this.joyStick = null, this.lookInput = null, this.jumpButton = null, this.fireButton = null, this.touchElements = [], this.lastDeltaLook = new h, this.touchSupported = !1, document.body.addEventListener("touchstart", (t => {
            if (!this.touchSupported) {
                this.touchSupported = !0, this.joyStick = new Cl({
                    responsiveArea: new Pl(0, .5, 0, 1)
                }), this.lookInput = new _l, this.jumpButton = new El({
                    right: 170,
                    bottom: 40,
                    responsiveArea: new Ml(null, 50, !1),
                    img: "img/touchUI/jump.svg"
                }), this.fireButton = new El({
                    right: 80,
                    bottom: 130,
                    responsiveArea: new Ml(null, 50, !1),
                    img: "img/touchUI/shoot.svg"
                }), this.jumpButton.addInputKey(uc().input.getKey("jump")), this.fireButton.addInputKey(uc().input.getKey("fire")), this.touchElements.push(this.joyStick, this.jumpButton, this.fireButton, this.lookInput), this.onResize();
                for (const t of this.onTouchSupportedChangeCbs) t()
            }
        })), this.onTouchSupportedChangeCbs = new Set, this.onTouchListenerClickCbs = new Set, this.touchListener.addEventListener("click", (() => {
            for (const t of this.onTouchListenerClickCbs) t()
        })), this.touchListener.addEventListener("touchstart", (t => {
            this.updateTouches(t)
        }), {
            passive: !1
        }), this.touchListener.addEventListener("touchmove", (t => {
            this.updateTouches(t)
        }), {
            passive: !1
        }), this.touchListener.addEventListener("touchend", (t => {
            this.updateTouches(t)
        }), {
            passive: !1
        }), ea.addListener((t => {
            this.onResize()
        })), this.onResize()
    }
    get joyStickValue() {
        return this.joyStick ? this.joyStick.currentValue.clone() : new h
    }
    onResize() {
        if (this.joyStick) {
            const t = new h(100, window.innerHeight - 100);
            this.joyStick.setDefaultPos(t)
        }
        const t = window.innerWidth < 500;
        this.jumpButton && (this.jumpButton.right = t ? 60 : 170, this.jumpButton.updatePosition()), this.fireButton && (this.fireButton.right = t ? 20 : 80, this.fireButton.updatePosition())
    }
    onTouchSupportedChange(t) {
        this.onTouchSupportedChangeCbs.add(t)
    }* visibileTouchElements() {
        for (const t of this.touchElements) t.visible && (yield t)
    }
    updateTouches(t) {
        t.cancelable && t.preventDefault();
        for (const e of t.touches) {
            let t = !1;
            for (const i of this.visibileTouchElements())
                if (i.currentUsingTouchId == e.identifier) {
                    const {
                        didHit: n,
                        cancelOthers: s
                    } = i.updateTouch(e);
                    if (n && (t = !0), s) break
                } if (!t)
                for (const t of this.visibileTouchElements()) {
                    const {
                        cancelOthers: i
                    } = t.updateTouch(e);
                    if (i) break
                }
        }
        for (const t of this.touchElements) t.endTouchLoop();
        this.lookInput && this.lastDeltaLook.add(this.lookInput.lastDeltaPos)
    }
    loop(t, e) {}
    afterLoop() {
        this.lastDeltaLook.set(0, 0)
    }
    onTouchListenerClick(t) {
        this.onTouchListenerClickCbs.add(t)
    }
}
class Al {
    constructor() {
        this.keys = new Map, this.keys.set("left", new bl({
            keyCodes: ["KeyA", "ArrowLeft"]
        })), this.keys.set("right", new bl({
            keyCodes: ["KeyD", "ArrowRight"]
        })), this.keys.set("up", new bl({
            keyCodes: ["KeyW", "ArrowUp"]
        })), this.keys.set("down", new bl({
            keyCodes: ["KeyS", "ArrowDown"]
        })), this.keys.set("flyUp", new bl({
            keyCodes: ["KeyE", "Space"]
        })), this.keys.set("flyDown", new bl({
            keyCodes: ["KeyQ"]
        })), this.keys.set("jump", new bl({
            keyCodes: ["Space"],
            gamepadButtons: [0]
        })), this.keys.set("fire", new bl({
            keyCodes: [],
            gamepadButtons: [7],
            mouseButtons: [0]
        })), this.keys.set("prevWeapon", new bl({
            keyCodes: ["KeyQ"],
            gamepadButtons: [4]
        })), this.keys.set("nextWeapon", new bl({
            keyCodes: ["KeyE"],
            gamepadButtons: [5]
        })), this.keys.set("playerList", new bl({
            keyCodes: ["Tab"],
            gamepadButtons: [8, 9]
        })), window.addEventListener("keydown", (t => {
            this.setKeyCodePressed(t, !0)
        })), window.addEventListener("keyup", (t => {
            this.setKeyCodePressed(t, !1)
        })), window.addEventListener("mousedown", (t => {
            t.target == document.body && this.setMouseButtonPressed(t.button, !0)
        })), window.addEventListener("mouseup", (t => {
            t.target == document.body && this.setMouseButtonPressed(t.button, !1)
        })), window.addEventListener("mousemove", (t => {
            this.pointerLocked && (this.mouseMove.x += t.movementX, this.mouseMove.y += t.movementY)
        })), window.addEventListener("focus", (t => {
            this.unpressAll()
        })), document.addEventListener("pointerlockerror", (t => {
            console.warn("error locking pointer")
        })), this.onPointerLockChangeCbs = new Set, document.addEventListener("pointerlockchange", (t => {
            const e = this.pointerLocked;
            for (const t of this.onPointerLockChangeCbs) t(e)
        })), this.stickDeadZone = .1, this.gamepadLookSensivity = 1.2, this.touch = new Tl, this.mouseMove = new h, this.walkInput = new h, this.lookInput = new h, this.gamepadAxes = []
    }
    loop(t, e) {
        this.touch.loop(t, e), this.lookInput.copy(this.mouseMove), this.lookInput.addScaledVector(this.touch.lastDeltaLook, 3);
        const i = uc(),
            n = i.settingsManager;
        this.lookInput.multiplyScalar(n.getValue("mouseSensitivity")), n.getValue("invertMouseY") && (this.lookInput.y *= -1), i.aprilFools.needsFlip && (this.lookInput.x *= -1), this.mouseMove.set(0, 0), this.updateGamepadStates(t, e), this.touch.touchSupported && this.updateAxisInputs(), this.touch.afterLoop()
    }
    updateGamepadStates(t, e) {
        this.gamepadAxes = [];
        const i = navigator.getGamepads(),
            n = [];
        let s = !1;
        for (const t of i) {
            if (!t) continue;
            if (t.axes) {
                const e = t.axes;
                for (let t = 0; t < e.length - 1; t += 2) {
                    const i = new h(e[t], e[t + 1]),
                        n = ca(this.stickDeadZone, 1, 0, 1, i.length(), !0);
                    i.setLength(n), this.gamepadAxes.push(i)
                }
                s = !0
            }
            const e = t.buttons;
            if (e)
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    i && (i.pressed && n.push(t))
                }
        }
        this.setPressedGamepadButtons(n), s && this.updateAxisInputs(), this.gamepadAxes.length > 1 && this.lookInput.addScaledVector(this.gamepadAxes[1], this.gamepadLookSensivity * e)
    }
    get pointerLocked() {
        return document.pointerLockElement == document.body
    }
    setKeyCodePressed(t, e) {
        if (document.activeElement && "INPUT" == document.activeElement.tagName) return;
        if (uc().mainMenu.visible) return;
        let i = !1,
            n = !1;
        for (const s of this.keys.values()) {
            const {
                preventOthers: r,
                needsPreventDefault: o
            } = s.setKeyCodePressed(t.code, e, i);
            r && (i = !0), o && !n && (t.preventDefault(), n = !0)
        }
        this.updateAxisInputs()
    }
    setMouseButtonPressed(t, e) {
        let i = !1;
        for (const n of this.keys.values()) {
            n.setMouseButtonPressed(t, e, i) && (i = !0)
        }
        this.updateAxisInputs()
    }
    setPressedGamepadButtons(t) {
        let e = !1;
        for (const i of this.keys.values()) {
            i.setPressedGamepadButtons(t, e) && (e = !0)
        }
    }
    unpressAll() {
        for (const t of this.keys.values()) t.setKeyPressed(!1, !1)
    }
    updateAxisInputs() {
        this.walkInput.set(0, 0), this.getKey("left").pressed && (this.walkInput.x = -1), this.getKey("right").pressed && (this.walkInput.x = 1), this.getKey("up").pressed && (this.walkInput.y = -1), this.getKey("down").pressed && (this.walkInput.y = 1), this.gamepadAxes.length > 0 && this.walkInput.add(this.gamepadAxes[0]), this.walkInput.add(this.touch.joyStickValue), this.walkInput.clampLength(0, 1), uc().aprilFools.needsFlip && (this.walkInput.x *= -1)
    }
    getKey(t) {
        const e = this.keys.get(t);
        if (!e) throw new Error(`Key ${t} not found`);
        return e
    }
    onPointerLockChange(t) {
        this.onPointerLockChangeCbs.add(t)
    }
    removeOnPointerLockChange(t) {
        this.onPointerLockChangeCbs.delete(t)
    }
    unlockPointer() {
        this.pointerLocked && document.exitPointerLock && document.exitPointerLock()
    }
    lockPointer() {
        if (this.pointerLocked) return;
        if (!document.hasFocus()) return;
        if (!document.body.requestPointerLock) return;
        const t = !uc().settingsManager.getValue("mouseAcceleration");
        document.body.requestPointerLock({
            unadjustedMovement: t
        })
    }
}
class Ll {
    constructor() {
        this.lastReceivedGlobalVariables = {}, this.lastReceivedRandomVariablesArray = [], this.currentVariablesIndex = -1, this.variablesIndexSeed = 123, this.defaultValues = {
            floorDeathHeight: -16,
            waterSfxVolume: 0,
            waterSfxHeight: 0,
            windSfxVolume: .002,
            windSfxBoostVolume: 0,
            windSfxBoostHeight: 0,
            birdsSfxVolume: .003,
            jungleSfxVolume: 0,
            rainSfxVolume: 0,
            skyHighColor: [0, 0, .609],
            skyMidColor: [.046, .145, .4435],
            skyLowColor: [.046, .145, .4435],
            skyPower: .69,
            fogAmount: .005,
            colorMultiplier: [1.4, 1.4, 1.4],
            colorMultiplierAdjust: 0,
            colorAdder: [0, 0, 0],
            colorAdderAdjust: 0,
            saturation: 1.2
        }, this.onVariablesChangedCbs = new Set, this.currentVariables = {
            ...this.defaultValues
        }
    }
    init() {}
    setVariables(t, e) {
        this.lastReceivedGlobalVariables = t || {}, this.lastReceivedRandomVariablesArray = e, this.updateVariablesIndex(), this.updateVariablesFromArray()
    }
    updateVariablesIndex() {
        0 == this.lastReceivedRandomVariablesArray.length ? this.currentVariablesIndex = -1 : this.currentVariablesIndex = ma(0, this.lastReceivedRandomVariablesArray.length, this.variablesIndexSeed)
    }
    setSeed(t) {
        this.variablesIndexSeed = t, this.updateVariablesIndex(), this.updateVariablesFromArray()
    }
    updateVariablesFromArray() {
        const t = this.lastReceivedRandomVariablesArray[this.currentVariablesIndex];
        this.currentVariables = {
            ...this.defaultValues,
            ...this.lastReceivedGlobalVariables,
            ...t
        }, this.onVariablesChangedCbs.forEach((t => t()))
    }
    onVariablesChanged(t) {
        this.onVariablesChangedCbs.add(t)
    }
    get(t) {
        return this.currentVariables[t]
    }
}
class kl {
    constructor(t, e) {
        this.configManager = t, this.mapsConfig = e, this.currentMapHash = null, this.currentMapLoadSymbol = null, this.currentMapHasScene = !1, this.currentMapHasCamPositions = !1, this.currentMapHasGameplayObjects = !1, this.onCurrentMapConfigChangeCbs = new Set, this.onIsLoadingMapChangeCbs = new Set, this.isLoadingMap = !1, this.mapLoadingText = null, this.environmentIsInit = !1, this.mapScene = null, this.cachedMapHashes = new Set, this.fetchingMapCbs = new Map, this.onOneMapAvailableCbs = new Set, this.firstMapDownloaded = !1, this.onFirstMapDownloadedCbs = new Set, this.onMapCachedCbs = new Set, this.onMapContentLoadedCbs = new Set, this.mapVariablesManager = new Ll, this.mapVariablesManager.onVariablesChanged((() => {
            this.updateWeatherParams()
        })), this.currentGameplayData = null, this.onGameplayDataChangeCbs = new Set, this.cloudsObj = null
    }
    async init() {
        const t = uc();
        if (this.mapLoadingText = t.mainMenu.requestLoadingText("Loading map...", {
            showPercentage: !0,
            priority: 1
        }), this.mapsConfig.onConfigChange((async t => {
            this.cachedMapHashes.clear();
            const e = await this.openCache();
            if (e) {
                const i = [];
                let n = !1;
                for (const s of t.maps) {
                    const t = new URL(this.configManager.basePath + "maps/" + s.assetName + ".glb");
                    t.searchParams.set("hash", s.hash);
                    const r = (async i => {
                        let r = !1;
                        try {
                            await e.match(t.href) && (r = !0)
                        } catch (t) {
                            console.warn("Couldn't get map (" + s.assetName + ".glb) from cache", t)
                        }
                        r && (n = !0, this.markMapAsCached(s.hash, !1))
                    })();
                    i.push(r)
                }
                await Promise.all(i), n && this.fireOnMapCachedCbs()
            }
            this.cacheRemainingMaps(), this.deleteOldMapCaches()
        })), await this.mapsConfig.waitForConfigLoad(), !this.mapsConfig.loadedConfigData) throw new Error("Assertion error, mapsconfig isn't loaded");
        this.mapsConfig.loadedConfigData.mainMenuMapHash && this.loadMap(this.mapsConfig.loadedConfigData.mainMenuMapHash, {
            setLoadText: !1
        }), this.loadClouds(), this.deleteLegacyCaches(), this.mapVariablesManager.init()
    }
    async cacheRemainingMaps() {
        const t = uc();
        if (await this.waitForFirstMapDownload(), await t.assets.getPackage("main").waitForLoad(), !this.mapsConfig.loadedConfigData) throw new Error("Assertion error, mapsconfig isn't loaded");
        try {
            await t.assets.sendWorkerRequest("cacheRemainingMaps", {
                mapsConfig: this.mapsConfig.loadedConfigData,
                knownCachedHashes: Array.from(this.cachedMapHashes)
            })
        } catch (t) {
            if (t instanceof AggregateError)
                for (const e of t.errors) e instanceof Error && console.error(e.message)
        }
    }
    async openCache() {
        if ("undefined" == typeof caches) return null;
        try {
            return await caches.open("maps")
        } catch (t) {
            return null
        }
    }
    markMapAsCached(t, e = !0) {
        this.cachedMapHashes.has(t) || (this.cachedMapHashes.add(t), this.fireFirstMapAvailable(), e && this.fireOnMapCachedCbs())
    }
    hasCachedMap(t) {
        return this.cachedMapHashes.has(t)
    }
    async deleteLegacyCaches() {
        if ("undefined" == typeof caches) return;
        let t = [];
        try {
            t = await caches.keys()
        } catch (t) {
            console.warn("Unable to delete old map caces", t)
        }
        const e = /^mapsV(\d+)$/;
        for (const i of t) {
            i.match(e) && (async () => {
                try {
                    caches.delete(i)
                } catch (t) {
                    console.warn(`Unable to delete old map cache "${i}""`, t)
                }
            })()
        }
    }
    async deleteOldMapCaches() {
        const t = this.mapsConfig.loadedConfigData;
        if (!t) return;
        const e = await this.openCache();
        if (e)
            for (const i of await e.keys()) {
                let n = !1;
                const s = new URL(i.url).searchParams.get("hash");
                if (s)
                    for (const e of t.maps)
                        if (e.hash == s) {
                            n = !0;
                            break
                        } n || await e.delete(i)
            }
    }
    async waitForOneMapAvailable() {
        if (this.cachedMapHashes.size > 0) return;
        const t = new Promise((t => this.onOneMapAvailableCbs.add(t)));
        await t
    }
    fireFirstMapAvailable() {
        for (const t of this.onOneMapAvailableCbs) t();
        this.onOneMapAvailableCbs.clear()
    }
    async waitForFirstMapDownload() {
        if (this.firstMapDownloaded) return;
        const t = new Promise((t => this.onFirstMapDownloadedCbs.add(t)));
        await t
    }
    onGameplayDataChange(t) {
        this.onGameplayDataChangeCbs.add(t)
    }
    removeOnGameplayDataChange(t) {
        this.onGameplayDataChangeCbs.delete(t)
    }
    onMapContentLoaded(t) {
        this.onMapContentLoadedCbs.add(t)
    }
    removeOnMapContentLoaded(t) {
        this.onMapContentLoadedCbs.delete(t)
    }
    onMapCached(t) {
        this.onMapCachedCbs.add(t)
    }
    fireOnMapCachedCbs() {
        this.onMapCachedCbs.forEach((t => t()))
    }
    reloadMap() {
        null != this.currentMapHash && this.loadMap(this.currentMapHash, {
            force: !0
        })
    }
    async loadMap(t, e = {}) {
        const {
            setLoadText: i = !0,
            force: n = !1,
            retryOnFail: s = !1
        } = e;
        if (this.currentMapHash == t && !n) return;
        let r;
        if (r = this.mapsConfig.getListedMapConfigByHash(t), !r) {
            if (s) return await this.reloadMapsConfigAndRetryLoadMap(t, e);
            throw new Error(`Failed to load map, "${t}" is not in the mapsConfig.`)
        }
        i && this.mapLoadingText && this.mapLoadingText.setIsLoading(!0), this.setIsLoadingMap(!0), this.currentMapHash = t;
        const o = r;
        this.onCurrentMapConfigChangeCbs.forEach((t => t(o))), this.currentMapHasScene = !1, this.currentMapHasCamPositions = !1, this.currentMapHasGameplayObjects = !1;
        const a = Symbol("loading map " + r);
        this.currentMapLoadSymbol = a, this.mapLoadingText && this.mapLoadingText.setPercentage(0);
        const l = {
            listedMapConfig: r
        };
        this.initEnvironment();
        const h = uc().assets;
        try {
            await h.sendWorkerRequest("loadMap", l, {
                responseCb: t => {
                    this.loadMapResponseCbReceived(t, a)
                }
            })
        } catch (i) {
            if (this.currentMapHash = null, this.setIsLoadingMap(!1), this.currentMapLoadSymbol = null, i instanceof Error && i.message.includes("Map hash validation failed")) {
                if (s) return await this.reloadMapsConfigAndRetryLoadMap(t, e);
                throw i
            }
            throw i
        }
    }
    async reloadMapsConfigAndRetryLoadMap(t, e) {
        return await this.mapsConfig.load(), await this.loadMap(t, {
            ...e,
            retryOnFail: !1
        })
    }
    async loadMapWithDialogMessage(t) {
        try {
            await this.loadMap(t, {
                retryOnFail: !0
            })
        } catch (t) {
            console.error(t);
            const e = uc(),
                i = e.dialogManager;
            if (t instanceof Error)
                if (t.message.includes("Map hash validation failed")) i.showAlert({
                    title: "Failed to load map",
                    text: "Something went wrong while verifying the map. Please try again."
                });
                else if (t.message.includes("is not in the mapsConfig")) {
                    const t = "The game you tried to join is using a map that is no longer available",
                        n = e.network.squadManager.isInSquad ? "please wait until the squad has started a new game" : "please try joining another game";
                    i.showAlert({
                        title: "Failed to load map",
                        text: `${t}, ${n}.`
                    })
                }
            e.network.closeCurrentConnection(), e.input.unlockPointer()
        }
    }
    loadMapResponseCbReceived(t, e) {
        if (e == this.currentMapLoadSymbol)
            if ("mapDownloadedNotification" == t.dataType) {
                if (!this.firstMapDownloaded) {
                    this.firstMapDownloaded = !0;
                    for (const t of this.onFirstMapDownloadedCbs) t();
                    this.onFirstMapDownloadedCbs.clear()
                }
            } else if ("scene" == t.dataType) {
                if (this.setMapScene(La.deserializeThreeObject(t.scene)), this.currentMapHasScene = !0, t.lobbyCamPositions) {
                    const e = t.lobbyCamPositions.map((t => ({
                        posA: (new w).fromArray(t.posA),
                        rotA: (new v).fromArray(t.rotA),
                        posB: (new w).fromArray(t.posB),
                        rotB: (new v).fromArray(t.rotB)
                    })));
                    uc().cam.setLobbyCamPositions(e)
                }
                this.currentMapHasCamPositions = !0, t.mapConfig ? this.mapVariablesManager.setVariables(t.mapConfig.globalMapVariables || null, t.mapConfig.randomMapVariableSets || []) : this.mapVariablesManager.setVariables(null, []), this.fireFirstMapAvailable(), this.mapLoadingText && this.mapLoadingText.setIsLoading(!1), this.setIsLoadingMap(!1);
                for (const t of this.onMapContentLoadedCbs) t()
            } else if ("gameplayObjects" == t.dataType) {
                const e = t.flags.map((t => ({
                        flagTeamId: t.flagTeamId,
                        pos: (new w).fromArray(t.pos),
                        rot: (new v).fromArray(t.rot)
                    }))),
                    i = t.spawnPositions.map((t => t.map((t => ({
                        pos: (new w).fromArray(t.pos),
                        rot: (new v).fromArray(t.rot)
                    })))));
                uc().physics.removeMapColliders();
                for (const {
                    matrix: e,
                    colliderType: i,
                    ignoreArrows: n,
                    isLadder: s,
                    isLadderAllSides: r,
                    excludeTeamId: o,
                    isDeathTrigger: a,
                    allowJump: l,
                    movePlayerUp: h,
                    slippery: c,
                    slowDownPlayerAmount: d
                }
                    of t.colliders) uc().physics.addMapCollider(i, e, {
                    ignoreArrows: n,
                    isLadder: s,
                    isLadderAllSides: r,
                    excludeTeamId: o,
                    isDeathTrigger: a,
                    allowJump: l,
                    movePlayerUp: h,
                    slippery: c,
                    slowDownPlayerAmount: d
                });
                uc().physics.buildOctree(), this.currentGameplayData = {
                    flags: e,
                    spawnPositions: i
                };
                for (const t of this.onGameplayDataChangeCbs) t(this.currentGameplayData);
                this.currentMapHasGameplayObjects = !0
            } else "progress" == t.dataType && this.mapLoadingText && this.mapLoadingText.setPercentage(t.progress)
    }
    initEnvironment() {
        if (this.environmentIsInit) return;
        uc().materials.precompileShaders(), this.updateWeatherParams();
        const t = new Pr(700, 8, 6),
            e = new _e(t, uc().materials.skyDomeMat);
        e.frustumCulled = !1, e.name = "skydome", e.renderOrder = -1, uc().scene.add(e), this.environmentIsInit = !0
    }
    updateWeatherParams() {
        const t = new qt(...this.mapVariablesManager.get("colorMultiplier"));
        t.addScalar(this.mapVariablesManager.get("colorMultiplierAdjust"));
        const e = new qt(...this.mapVariablesManager.get("colorAdder"));
        e.addScalar(this.mapVariablesManager.get("colorAdderAdjust")), uc().materials.applyWeatherParams({
            colorMultiplier: t,
            colorAdder: e,
            fogAmount: this.mapVariablesManager.get("fogAmount"),
            saturation: this.mapVariablesManager.get("saturation"),
            skyHighColor: new qt(...this.mapVariablesManager.get("skyHighColor")),
            skyMidColor: new qt(...this.mapVariablesManager.get("skyMidColor")),
            skyLowColor: new qt(...this.mapVariablesManager.get("skyLowColor")),
            skyPower: this.mapVariablesManager.get("skyPower")
        })
    }
    setMapScene(t) {
        this.mapScene && (uc().scene.remove(this.mapScene), this.disposeMapGeometries(this.mapScene), this.mapScene = null), t && (t.traverse((t => {
            t.frustumCulled = !1
        })), this.mapScene = t, uc().scene.add(t))
    }
    disposeMapGeometries(t) {
        t.traverse((t => {
            t instanceof _e && t.geometry.dispose()
        }))
    }
    async loadClouds() {
        const t = await uc().assets.getPackage("main").getFileAsBuffer("clouds.glb"),
            e = await uc().assets.sendWorkerRequest("loadClouds", {
                glbBuffer: t
            });
        this.cloudsObj = La.deserializeThreeObject(e), this.cloudsObj && uc().scene.add(this.cloudsObj)
    }
    onCurrentMapIdChange(t) {
        this.onCurrentMapConfigChangeCbs.add(t)
    }
    onIsLoadingMapChange(t) {
        this.onIsLoadingMapChangeCbs.add(t)
    }
    setIsLoadingMap(t) {
        this.isLoadingMap != t && (this.isLoadingMap = t, this.onIsLoadingMapChangeCbs.forEach((e => e(t))))
    }
}
class Il {
    constructor(t, e) {
        this.configManager = t, this.configPath = e, this.onConfigChangeCbs = new Set, this.loadedConfigData = null
    }
    transformData(t) {
        throw new Error("transformData not implemented")
    }
    async load() {
        const t = await fetch(this.configManager.basePath + this.configPath);
        if (t.ok) try {
            this.loadedConfigData = await t.json()
        } catch (t) {
            this.configManager.suppressLogs || console.warn("Failed to load shop config: ", t)
        }
        if (this.loadedConfigData = this.transformData(this.loadedConfigData), this.loadedConfigData)
            for (const t of this.onConfigChangeCbs) t(this.loadedConfigData)
    }
    onConfigChange(t, e = !0) {
        this.loadedConfigData && e && t(this.loadedConfigData), this.onConfigChangeCbs.add(t)
    }
    removeOnConfigChange(t) {
        this.onConfigChangeCbs.delete(t)
    }
    async waitForConfigLoad() {
        this.loadedConfigData || await new Promise((t => this.onConfigChange(t)))
    }
}
class Rl extends Il {
    transformData(t) {
        if (!t) return {
            mainMenuMapHash: "",
            maps: [],
            lastUpdatedTimestamp: 0
        };
        if (t.maps) {
            const e = [],
                i = new Set,
                n = new Set;
            for (const s of t.maps) s.assetName && s.hash && (i.has(s.hash) || n.has(s.assetName) || (e.push(s), i.add(s.hash), n.add(s.assetName)));
            t.maps = e;
            for (const e of t.maps) Number.isFinite(e.size) || (e.size = 0)
        } else t.maps = [];
        return !!t.maps.find((e => e.hash == t.mainMenuMapHash)) || (t.mainMenuMapHash = t.maps.length ? t.maps[0].hash : ""), t.lastUpdatedTimestamp && "number" == typeof t.lastUpdatedTimestamp || (t.lastUpdatedTimestamp = 0), t
    }
    getListedMapConfigByHash(t) {
        return this.loadedConfigData && this.loadedConfigData.maps.find((e => e.hash === t)) || null
    }
    hasListedMapConfigByHash(t) {
        return !!this.loadedConfigData && !!this.loadedConfigData.maps.find((e => e.hash === t))
    }
}
class Dl extends Il {
    transformData(t) {
        return t ? (t.activePromos ? t.activePromos = t.activePromos.filter((t => t.id && t.image)) : t.activePromos = [], t) : {
            activePromos: []
        }
    }
}
class Ol extends Il {
    transformData(t) {
        return t ? (t.purchasableItems ? t.purchasableItems = t.purchasableItems.filter((t => t.id)) : t.purchasableItems = [], t.skinPresets && Array.isArray(t.skinPresets) ? t.skinPresets.map((t => Na(t))) : t.skinPresets = [], t) : {
            purchasableItems: [],
            skinPresets: []
        }
    }
    getPurchaseableItem(t) {
        return this.loadedConfigData && this.loadedConfigData.purchasableItems.find((e => e.id === t)) || null
    }
}
class Fl {
    constructor() {
        this.basePath = null, this.suppressLogs = !1, this.shopConfig = new Ol(this, "shopConfig.json"), this.promosConfig = new Dl(this, "promosConfig.json"), this.mapsConfig = new Rl(this, "mapsConfig.json"), this.allConfigs = [this.shopConfig, this.promosConfig, this.mapsConfig]
    }
    init() {
        const t = va();
        if (t.configBasePath) this.basePath = t.configBasePath;
        else if ("dev" == t.configEnv || "staging" == t.configEnv || t.pokiDebug || "staging.narrow.one" == location.hostname) this.basePath = "https://narrow-one.com/stagingconfig/";
        else if ("live" == t.configEnv) this.basePath = "https://narrow-one.com/config/";
        else if ("test" == t.configEnv) this.basePath = "https://localhost:8080/test/e2e/fixtures/config/";
        else if ("local" == uc().env) {
            const t = "http:" == location.protocol ? 8078 : 8081;
            this.basePath = location.protocol + "//" + location.hostname + ":" + t + "/"
        } else this.basePath = "https://narrow-one.com/config/";
        uc().assets.sendWorkerRequest("configBasePath", {
            basePath: this.basePath
        }), this.loadAllConfigs()
    }
    loadAllConfigs() {
        for (const t of this.allConfigs) t.load()
    }
}
class Nl { //ARROW HACK0
    constructor(t, e) {
        this.player = t, this.weaponObj = null, this.arrowObjs = [], this.holdingHandler = null, this.strengthMultiplier = 1, this.weaponId = e, this.weaponConfig = {
            weaponConfigWhenRunning: {},
            weaponConfigAfterLoad: {},
            weaponConfigWhenLoading: {},
            shootCooldownFromFireDownMs: 10,
            shootCooldownFromFireUpMs: 10,
            shootChargeDurationMs: 10,
            walkSpeedMultiplier: 1,
            walkSpeedWhenLoadingMultiplier: .3,
            jumpForceMultiplier: 1,
            jumpForceWhenLoadingMultiplier: 1,
            minAccuracy: 0,
            maxAccuracy: 30,
            usePreloadWeaponSystem: !1,
            preloadAutoCompleteAmount01: .4,
            minShootCount: 0,
            maxShootCount: 0,
            shootMultipleDelay: 0.1,
            useAbsoluteFov: !1,
            absoluteFovMinStat: 40,
            absoluteFovMaxStat: 40,
            trailThicknessMultiplier: 1,
            trailDurationMultiplier: 0,
            pullSfx: "weapon/bow/pull",
            pullSfxMinPitch: 1,
            pullSfxMaxPitch: 1,
            shootSfx: "weapon/bow/shoot",
            shootSfxMinPitch: 1,
            shootSfxMaxPitch: 1,
            ...Ea[e]
        }, this.fireIsDown = !1, this.fireDownTime = 0, this.lastFireUp = 0, this.lastBowPull = 0, this.lastBowPullWasUsed = !0, this.isPullingBow = !1, this.prevArrowReady = !0, this.prevFullyCharged = !1, this.prevShootCount = 1, this.autoShootEnabled = !1, this.isAutoShooting = !1, this.weaponIsPreLoaded = !1, this.isAutoPreloading = !1, this.currentPullSfx = null, this.firstPersonRunningState = !1, this.accuracyOffset = null, this.destructed = !1, this.bowAssetLoader = new Xa, this.reloadAsset(), this.holdingHandler = this.player.createHoldingHandler({
            holdingObject: this.bowAssetLoader.obj,
            thirdPersonParentName: "bowHoldingPos"
        }), this.updateFirstPersonOffset(!0), this.holdingHandler.firstPersonMoveDown()
    }
    destructor() {
        this.destructed = !0, this.setHasCursorAccuracyOffset(!1), this.holdingHandler && this.holdingHandler.destructor(), this.bowAssetLoader.destructor()
    }
    reloadAsset() {
        const t = uc().skins.skinNetworkDataToBowAssetNames(this.weaponConfig.bowId, this.player.equippedSkinData);
        this.bowAssetLoader.setConfig({
            bowId: this.weaponConfig.bowId,
            teamId: this.player.teamId,
            morphOpts: this.weaponConfig.bowMorphOpts,
            skins: t,
            arrowCount: this.weaponConfig.maxShootCount
        })
    }
    setHasCursorAccuracyOffset(t) {
        const e = uc().gameManager.currentGame;
        e && (t ? this.accuracyOffset || (this.accuracyOffset = e.crosshair.createAccuracyOffset()) : this.accuracyOffset && (e.crosshair.deleteAccuracyOffset(this.accuracyOffset), this.accuracyOffset = null))
    }
    onFireDown() {
        if (this.isAutoPreloading || this.isLoading) return;
        if (this.weaponConfig.usePreloadWeaponSystem && this.weaponIsPreLoaded) return this.shootOneOrMultiple(), void(this.weaponIsPreLoaded = !1);
        let t = 0;
        t = Math.max(t, this.weaponConfig.shootCooldownFromFireUpMs - this.lastFireUpMsAgo), this.lastBowPullWasUsed && (t = Math.max(t, this.weaponConfig.shootCooldownFromFireDownMs - this.lastBowPullMsAgo)), this.fireIsDown = !0, this.autoShootEnabled && (this.isAutoShooting = !0), this.fireDownTime = uc().now + t, this.arrowReady && this.startBowPull()
    }
    onFireUp() {
        this.isAutoPreloading || this.autoShootEnabled && !this.fullyCharged || this.performFireCheck(), this.fireIsDown = !1, this.updateFirstPersonOffset()
    }
    setAutoShootEnabled(t) {
        this.autoShootEnabled = t
    }
    checkAutoShoot() {
        this.autoShootEnabled && !this.fireIsDown && this.performFireCheck()
    }
    performFireCheck() {
        let t = !0;
        this.fireTime >= 0 && (this.lastBowPullWasUsed = !0, this.weaponConfig.usePreloadWeaponSystem ? this.fullyCharged ? this.weaponIsPreLoaded = !0 : this.fireAmount01 > this.weaponConfig.preloadAutoCompleteAmount01 ? (this.isAutoPreloading = !0, t = !1) : this.lastBowPullWasUsed = !1 : this.shootOneOrMultiple()), t && this.stopBowPull(), this.isAutoShooting = !1
    }
    startBowPull() {
        this.isPullingBow || (this.startPullSound(), this.lastBowPull = uc().now, this.isPullingBow = !0, this.updateFirstPersonOffset(), uc().renderer.renderWorthyEventHappened())
    }
    stopBowPull() {
        this.isPullingBow && (this.stopPullSound(), this.isPullingBow = !1, this.updateFirstPersonOffset())
    }
    updateFirstPersonOffset(t = !1) {
        if (!this.holdingHandler) return;
        let e;
        e = this.isPullingBow ? this.weaponConfig.weaponConfigWhenLoading : this.firstPersonRunningState ? this.weaponConfig.weaponConfigWhenRunning : this.weaponConfig.weaponConfigAfterLoad, this.holdingHandler.setFirstPersonConfig(e, t)
    }
    async shootOneOrMultiple() {
        const t = uc().gameManager.currentGame;
        if (!t) return;
        const e = this.fireAmount01;
        this.holdingHandler && this.holdingHandler.addFirstPersonImpulse(new w(0, 0, .005 * e));
        const i = 50,
            n = this.shootCount; //ARROW HACK1
        for (let t = 0; t < 5; t++) this.shootOne(e, i), this.weaponConfig.shootMultipleDelay > 0 && await ra.promise(this.weaponConfig.shootMultipleDelay)
    }
    shootOne(t, e) {
        const i = uc().gameManager.currentGame;
        if (i) {
            if (this.player.hasOwnership) {
                const n = this.player.getCamPos(),
                    s = this.player.getLookDirection(),
                    r = this.randomRotateVec(s, ca(0, 30, 0, .05, e)),
                    o = this.player.getSendArrowId(),
                    a = uc().network.sendCreateArrow(this.player.id, {
                        arrowId: o,
                        pos: n,
                        dir: r,
                        fireAmount01: t //ARROW HACK2
                    });
                i.arrowManager.createArrow(this.player, a)
            }
            this.lastFireUp = uc().now, this.prevArrowReady = 1, this.prevFullyCharged = 1
        }
    }
    randomRotateVec(t, e) {
        const i = t.clone();
        i.x += 1, i.cross(t).normalize();
        const n = new v;
        n.setFromAxisAngle(t, Math.random() * Math.PI * 2), i.applyQuaternion(n);
        const s = new v;
        return s.setFromAxisAngle(i, la(-e, e, Math.random())), t.clone().applyQuaternion(s)
    }
    getArrowOpts(t) {
        const e = new w;
        return e.set(1, 1, 1), this.bowAssetLoader.assetLoaded && e.copy(this.bowAssetLoader.getLoadedArrowPointScale()), {
            visualOffset: this.weaponConfig.trailVisualOffset,
            damageMultiplier: this.weaponConfig.arrowDamageMultiplier,
            scale: e,
            travelDistanceMultiplier: this.weaponConfig.arrowTravelDistanceMultiplier,
            trailThicknessMultiplier: this.weaponConfig.trailThicknessMultiplier,
            trailDurationMultiplier: this.weaponConfig.trailDurationMultiplier
        }
    }
    loop(t, e) {
        this.accuracyOffset && (this.accuracyOffset.offset = la(this.weaponConfig.maxAccuracy, this.weaponConfig.minAccuracy, this.fireAmount01));
        const i = this.arrowReady,
            n = this.shootCount;
        if (this.bowAssetLoader.updateFireAmount(this.fireAmount01, i ? n : 0), n != this.prevShootCount) {
            if (n > this.prevShootCount) {
                const t = ca(1, 3, .95, 1.1, n),
                    e = ca(1, 3, 1, 1.15, n);
                uc().sfx.playSound("weapon/bow/arrowReady", {
                    pos: this.player.getSfxPos(),
                    minPitch: t,
                    maxPitch: e
                })
            }
            this.prevShootCount = n
        }
        if (this.prevArrowReady ? this.prevFullyCharged || this.fullyCharged && (this.prevFullyCharged = !0, this.isAutoPreloading && (this.isAutoPreloading = !1, this.weaponIsPreLoaded = !0), this.stopBowPull(), this.checkAutoShoot()) : i && (this.prevArrowReady = !0, this.isLoading && this.startBowPull()), this.player.useFirstPersonHoldingHandlers) {
            let t = null;
            if (this.fullyCharged || this.isPullingBow || this.lastFireUpMsAgo < 1e3) t = !1;
            else {
                const e = this.player.rigidBody.velocity.clone();
                e.y = 0, e.length() > 8 * this.weaponConfig.walkSpeedMultiplier && (t = !0)
            }
            null != t && t != this.firstPersonRunningState && (this.firstPersonRunningState = t, this.updateFirstPersonOffset())
        }
    }
    get isLoading() {
        return this.fireIsDown || this.isAutoShooting
    }
    get fireTime() {
        return this.weaponIsPreLoaded ? this.weaponConfig.shootChargeDurationMs : this.isLoading || this.isAutoPreloading ? uc().now - this.fireDownTime : 0
    }
    get fireAmount01() {
        return ua(this.fireAmountUnclamped01)
    }
    get fireAmountUnclamped01() {
        return ha(0, this.weaponConfig.shootChargeDurationMs, this.fireTime)
    }
    get shootCount() {
        if (!this.arrowReady) return 0;
        const t = ca(1, 2, this.weaponConfig.minShootCount, this.weaponConfig.maxShootCount, this.fireAmountUnclamped01, !0);
        return Math.floor(t)
    }
    get lastBowPullMsAgo() {
        return uc().now - this.lastBowPull
    }
    get lastFireUpMsAgo() {
        return uc().now - this.lastFireUp
    }
    get arrowReady() {
        return !(!this.isPullingBow && !this.fullyCharged) || !(this.lastFireUpMsAgo < this.weaponConfig.shootCooldownFromFireUpMs) && !(this.lastBowPullWasUsed && this.lastBowPullMsAgo < this.weaponConfig.shootCooldownFromFireDownMs)
    }
    get fullyCharged() {
        return this.fireAmount01 >= 1
    }
    get slowDownPlayerMovement() {
        let t = this.isLoading && this.arrowReady;
        return this.weaponConfig.usePreloadWeaponSystem && this.fullyCharged && (t = !1), t
    }
    get walkSpeedMultiplier() {
        let t = this.weaponConfig.walkSpeedMultiplier;
        return this.slowDownPlayerMovement && (t *= this.weaponConfig.walkSpeedWhenLoadingMultiplier), t
    }
    get jumpForceMultiplier() {
        let t = this.weaponConfig.jumpForceMultiplier;
        return this.slowDownPlayerMovement && (t *= this.weaponConfig.jumpForceWhenLoadingMultiplier), t
    }
    get absoluteFov() {
        if (!this.weaponConfig.useAbsoluteFov) return null;
        const t = this.player.getStatClassValue("shootingFocus");
        return la(this.weaponConfig.absoluteFovMinStat, this.weaponConfig.absoluteFovMaxStat, t)
    }
    async startPullSound() {
        this.stopPullSound();
        const t = this.weaponConfig.pullSfxMinPitch,
            e = this.weaponConfig.pullSfxMaxPitch;
        this.currentPullSfx = await uc().sfx.playSound(this.weaponConfig.pullSfx, {
            pos: this.player.getSfxPos(),
            minPitch: t,
            maxPitch: e
        })
    }
    stopPullSound() {
        this.currentPullSfx && (this.currentPullSfx.stop(), this.currentPullSfx = null)
    }
    playShootSound(t) {
        this.player.hasOwnership && (t = null);
        const e = this.weaponConfig.shootSfxMinPitch,
            i = this.weaponConfig.shootSfxMaxPitch;
        uc().sfx.playSound(this.weaponConfig.shootSfx, {
            pos: t,
            minPitch: e,
            maxPitch: i
        })
    }
}
class Bl {
    constructor({
                    startValue: t = 0,
                    springMultiplier: e = .02,
                    maxSpring: i = 1 / 0,
                    dampening: n = .6,
                    loopValue: s = !1,
                    loopStart: r = -Math.PI,
                    loopEnd: o = Math.PI
                } = {}) {
        this.value = t, this.target = t, this.velocity = 0, this.springMultiplier = e, this.maxSpring = i, this.dampening = n, this.loopValue = s, this.loopStart = r, this.loopEnd = o
    }
    loop(t, e) {
        let i = this.target - this.value;
        if (this.loopValue) {
            this.target = this.performValueLoop(this.target);
            const t = this.loopEnd - this.loopStart,
                e = this.target,
                n = this.target - t,
                s = this.target + t,
                r = e - this.value,
                o = n - this.value,
                a = s - this.value;
            i = r, Math.abs(o) < Math.abs(i) && (i = o), Math.abs(a) < Math.abs(i) && (i = a)
        }
        i *= this.springMultiplier, i = da(i, -this.maxSpring, this.maxSpring), this.velocity += i, this.velocity *= this.dampening, this.value += this.velocity * e, this.loopValue && (this.value = this.performValueLoop(this.value))
    }
    performValueLoop(t) {
        return e = t, i = this.loopStart, n = this.loopEnd, aa(e - i, n - i) + i;
        var e, i, n
    }
}
class Vl {
    constructor({
                    startValue: t = new w,
                    springMultiplier: e = .02,
                    maxSpring: i = 1 / 0,
                    dampening: n = .6
                } = {}) {
        this.xValue = new Bl({
            startValue: t.x,
            springMultiplier: e,
            maxSpring: i,
            dampening: n
        }), this.yValue = new Bl({
            startValue: t.y,
            springMultiplier: e,
            maxSpring: i,
            dampening: n
        }), this.zValue = new Bl({
            startValue: t.z,
            springMultiplier: e,
            maxSpring: i,
            dampening: n
        })
    }
    loop(t, e) {
        this.xValue.loop(t, e), this.yValue.loop(t, e), this.zValue.loop(t, e)
    }
    get value() {
        return new w(this.xValue.value, this.yValue.value, this.zValue.value)
    }
    set value(t) {
        this.xValue.value = t.x, this.yValue.value = t.y, this.zValue.value = t.z
    }
    get target() {
        return new w(this.xValue.target, this.yValue.target, this.zValue.target)
    }
    set target(t) {
        this.xValue.target = t.x, this.yValue.target = t.y, this.zValue.target = t.z
    }
    addImpulse(t) {
        this.xValue.velocity += t.x, this.yValue.velocity += t.y, this.zValue.velocity += t.z
    }
}
class Ul {
    constructor(t, {
        holdingObject: e,
        thirdPersonParentName: i,
        firstPersonConfig: n
    }) {
        this.player = t, this.holdingObject = e, this.thirdPersonParentName = i, this.firstPersonPosOffset = new w, this.firstPersonRotOffset = new v, this.smoothFirstPersonPosOffset = new w, this.smoothFirstPersonRotOffset = new v, this.smoothFirstPersonPosFovMultiplierX = 0, this.smoothFirstPersonPosBaseFovMultiplierX = 0, this.smoothFirstPersonPosFovMultiplierY = 0, this.smoothFirstPersonWalkBobMultiplier = 0, this.smoothFirstPersonPitchHeightMultiplier = 0, this.smoothFirstPersonMinFov = 0, this.smoothFirstPersonMaxFov = 0, this.prevCamPosValid = !1, this.prevCamRotValid = !1, this.prevCamPos = new w, this.prevCamRotForwardVector = new w, this.camPosOffsetPhysics = new Vl({
            springMultiplier: .01,
            maxSpring: .001,
            dampening: .6
        }), this.camRotOffsetPhysics = new Bl({
            springMultiplier: .003,
            maxSpring: .001,
            dampening: .8
        }), this.renderOverlay = uc().renderer.createRenderOverlay(), this.firstPersonObjContainer = new xt, this.firstPersonObjContainer.name = "FirstPersonObjContainer", this.renderOverlay.scene.add(this.firstPersonObjContainer), this.linkedThirdPersonObject = null, this.firstPersonConfig, this.setFirstPersonConfig(n || {}, !0), this.updateRenderOverlayEnabled(), this.updateParent(), this.updateFirstPersonPosition(), this.firstPersonMoveDown()
    }
    destructor() {
        this.player.removeHoldingHandler(this), uc().renderer.removeRenderOverlay(this.renderOverlay), this.firstPersonObjContainer.parent && this.firstPersonObjContainer.parent.remove(this.firstPersonObjContainer), this.holdingObject.parent && this.holdingObject.parent.remove(this.holdingObject)
    }
    updateRenderOverlayEnabled() {
        this.renderOverlay.enabled = this.player.useFirstPersonHoldingHandlers
    }
    updateParent() {
        if (this.holdingObject.parent && this.holdingObject.parent.remove(this.holdingObject), this.player.useFirstPersonHoldingHandlers) this.firstPersonObjContainer.add(this.holdingObject), this.holdingObject.position.set(0, 0, 0), this.holdingObject.rotation.set(0, 0, 0);
        else if (this.player.obj && this.player.skeleton.isInit) {
            if (!this.player.skeleton.baseSkeletonObject) throw new Error("Assertion failed, skeleton is not initialized");
            this.linkedThirdPersonObject = this.player.skeleton.baseSkeletonObject.getObjectByName(this.thirdPersonParentName), this.linkedThirdPersonObject && (this.player.obj.add(this.holdingObject), this.holdingObject.position.set(0, 0, 0), this.holdingObject.rotation.set(0, 0, 0), this.holdingObject.scale.setScalar(1))
        }
    }
    loop(t, e) {
        if (this.player.useFirstPersonHoldingHandlers) {
            this.smoothFirstPersonPosOffset.lerp(this.firstPersonPosOffset, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonRotOffset.slerp(this.firstPersonRotOffset, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonPosFovMultiplierX = la(this.smoothFirstPersonPosFovMultiplierX, this.firstPersonConfig.posFovMultiplierX, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonPosBaseFovMultiplierX = la(this.smoothFirstPersonPosBaseFovMultiplierX, this.firstPersonConfig.posBaseFovMultiplierX, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonPosFovMultiplierY = la(this.smoothFirstPersonPosFovMultiplierY, this.firstPersonConfig.posFovMultiplierY, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonWalkBobMultiplier = la(this.smoothFirstPersonWalkBobMultiplier, this.firstPersonConfig.walkBobMultiplier, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonPitchHeightMultiplier = la(this.smoothFirstPersonPitchHeightMultiplier, this.firstPersonConfig.pitchHeightMultiplier, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonMinFov = la(this.smoothFirstPersonMinFov, this.firstPersonConfig.minFov, this.firstPersonConfig.valuesSmoothing), this.smoothFirstPersonMaxFov = la(this.smoothFirstPersonMaxFov, this.firstPersonConfig.maxFov, this.firstPersonConfig.valuesSmoothing);
            const i = this.player.getCamPos(),
                n = this.player.getCamRot();
            this.prevCamPosValid || (this.prevCamPos.copy(i), this.prevCamPosValid = !0);
            const s = i.clone().sub(this.prevCamPos);
            s.applyQuaternion(n.invert());
            const r = new w(0, 0, 1).clone().applyQuaternion(n);
            r.y = 0, this.prevCamRotValid || (this.prevCamRotForwardVector.copy(r), this.prevCamRotValid = !0);
            let o = this.prevCamRotForwardVector.angleTo(r);
            this.prevCamRotForwardVector.clone().cross(r).y > 0 && (o *= -1), this.prevCamPos.copy(i), this.prevCamRotForwardVector.copy(r), this.camPosOffsetPhysics.target = s, this.camPosOffsetPhysics.loop(t, e), this.camRotOffsetPhysics.target = o, this.camRotOffsetPhysics.loop(t, e), this.updateFirstPersonPosition()
        } else if (this.player.obj && this.linkedThirdPersonObject) {
            this.holdingObject.matrixWorld.multiplyMatrices(this.player.obj.matrixWorld, this.linkedThirdPersonObject.matrixWorld);
            for (const t of this.holdingObject.children) t.updateWorldMatrix(!1, !0)
        }
    }
    setFirstPersonConfig(t, e = !1) {
        this.firstPersonConfig = {
            posOffset: new w,
            rotOffset: new w,
            posFovMultiplierX: 0,
            posFovMultiplierY: 0,
            posBaseFovMultiplierX: 0,
            walkBobMultiplier: 1,
            valuesSmoothing: .2,
            pitchHeightMultiplier: .3,
            minFov: 0,
            maxFov: 180,
            ...t
        }, this.firstPersonPosOffset.copy(this.firstPersonConfig.posOffset);
        const i = (new ot).setFromVector3(this.firstPersonConfig.rotOffset, "YXZ");
        this.firstPersonRotOffset.setFromEuler(i), this.firstPersonRotOffset.multiply((new v).setFromAxisAngle(new w(0, 1, 0), Math.PI)), e && (this.smoothFirstPersonPosOffset.copy(this.firstPersonConfig.posOffset), this.smoothFirstPersonRotOffset.copy(this.firstPersonRotOffset), this.smoothFirstPersonPosFovMultiplierX = this.firstPersonConfig.posFovMultiplierX, this.smoothFirstPersonPosBaseFovMultiplierX = this.firstPersonConfig.posBaseFovMultiplierX, this.smoothFirstPersonPosFovMultiplierY = this.firstPersonConfig.posFovMultiplierY, this.smoothFirstPersonWalkBobMultiplier = this.firstPersonConfig.walkBobMultiplier, this.smoothFirstPersonPitchHeightMultiplier = this.firstPersonConfig.pitchHeightMultiplier, this.smoothFirstPersonMinFov = this.firstPersonConfig.minFov, this.smoothFirstPersonMaxFov = this.firstPersonConfig.maxFov, this.updateRenderOverlayFovs(), this.renderOverlay.updateProjectionMatrix()), this.updateFirstPersonPosition()
    }
    updateFirstPersonPosition() {
        if (!this.player.useFirstPersonHoldingHandlers) return;
        const t = uc(),
            e = this.player.getCamRot(),
            i = new w(0, 1, 0),
            n = new w(0, 0, 1),
            s = new w(1, 0, 0),
            r = i.clone().applyQuaternion(e),
            o = n.clone().applyQuaternion(e),
            a = s.clone().applyQuaternion(e),
            l = o.clone();
        r.y < .1 && (l.copy(r), o.y > 0 && l.negate()), l.y = 0;
        let h = l.angleTo(n);
        n.clone().cross(l).y > 0 && (h = -h);
        let c = o.angleTo(l);
        o.clone().cross(l).dot(a) > 0 && (c = -c);
        const d = new v;
        s.applyQuaternion(e), d.setFromAxisAngle(s, c);
        (new v).setFromAxisAngle(new w(0, 1, 0), -h);
        const u = this.smoothFirstPersonPosOffset.clone(),
            p = Math.min(window.innerWidth / window.innerHeight, 2),
            m = this.renderOverlay.cam.fov,
            g = Math.tan(m / 115) * p,
            f = Math.tan(m / 115),
            y = Math.tan(t.cam.baseFov / 115) * p;
        u.x += g * this.smoothFirstPersonPosFovMultiplierX, u.x += y * this.smoothFirstPersonPosBaseFovMultiplierX, u.y -= f * this.smoothFirstPersonPosFovMultiplierY, u.y -= c * this.smoothFirstPersonPitchHeightMultiplier, t.settingsManager.getValue("walkHeadBob") && (u.x += .1 * Math.cos(this.player.legsMoveTForCos / 2) * this.smoothFirstPersonWalkBobMultiplier, u.y += -.07 * Math.sin(this.player.legsMoveTForCos) * this.smoothFirstPersonWalkBobMultiplier), u.sub(this.camPosOffsetPhysics.value), u.x += this.camRotOffsetPhysics.value;
        const b = new v;
        b.multiply(this.smoothFirstPersonRotOffset), this.firstPersonObjContainer.position.copy(u), this.firstPersonObjContainer.quaternion.copy(b), this.updateRenderOverlayFovs(), this.firstPersonObjContainer.updateWorldMatrix(!1, !0)
    }
    updateRenderOverlayFovs() {
        this.renderOverlay.minFov = this.smoothFirstPersonMinFov, this.renderOverlay.maxFov = this.smoothFirstPersonMaxFov
    }
    useFirstPersonUpdated() {
        this.updateRenderOverlayEnabled(), this.updateParent()
    }
    playerObjectChanged() {
        this.updateParent()
    }
    addFirstPersonImpulse(t) {
        this.camPosOffsetPhysics.addImpulse(t)
    }
    firstPersonMoveDown() {
        this.camPosOffsetPhysics.yValue.value = .3
    }
}
class zl {
    constructor(t, {
        once: e = !0,
        run: i = !1
    } = {}) {
        this.once = e, this.promiseFn = t, this.isRunning = !1, this.hasRan = !1, this.onceReturnValue = void 0, this.onRunFinishCbs = new Set, i && this.run()
    }
    async run(t = !1) {
        if (this.isRunning) return t && !this.once ? (await new Promise((t => this.onRunFinishCbs.add(t))), await this.run(!1)) : await new Promise((t => this.onRunFinishCbs.add(t)));
        if (this.hasRan && this.once) return this.onceReturnValue;
        this.isRunning = !0;
        const e = await this.promiseFn();
        this.isRunning = !1, this.hasRan = !0, this.once && (this.onceReturnValue = e);
        const i = this.onRunFinishCbs;
        this.onRunFinishCbs = new Set;
        for (const t of i) t(e);
        return e
    }
    async waitForFinish() {
        this.hasRan || await new Promise((t => this.onRunFinishCbs.add(t)))
    }
    async waitForFinishIfRunning() {
        this.isRunning && await new Promise((t => this.onRunFinishCbs.add(t)))
    }
}
class Hl {
    constructor() {
        this.matchMakingSocketUrl = "", this.ws = null, this.onJoinServerReceivedCbs = new Set, this.nextCloseIsIntentional = !1, this.onConnectionCloseCbs = new Set, this.onConnectionOpenCbs = new Set, this.onConnectionCloseDuringMatchMakingCbs = new Set, this.onSquadMessageCbs = new Set, this.onIsMatchMakingChangeCbs = new Set, this.matchMakingLoadingText = null, this.isMatchMaking = !1, this.shouldApplyLoadingText = !0, this.smoothSkillLevel = 0, this.smoothSkillLevelGameCount = 0, this.isInUnreadyQueue = !1, this.initConnectionInstance = new zl((async () => {
            if (this.connected) return !0;
            for (let t = 0; t < 3; t++) {
                t > 0 && await ra.promise(2e3 * t);
                const e = await this.attemptSingleWsConnection();
                if (e) return this.send({
                    op: "myClientVersion",
                    version: VERSION_TIMESTAMP
                }), this.sendDownloadedMapHashes(), this.sendCurrentMapsConfigTimestamp(), this.sendSkillLevel(), this.onConnectionOpenCbs.forEach((t => t())), e.addEventListener("close", (() => {
                    e == this.ws && this.fireOnCloseCbs()
                })), !0
            }
            return !1
        }), {
            run: !1,
            once: !1
        })
    }
    init() {
        this.matchMakingLoadingText = uc().mainMenu.requestLoadingText("Searching for players...");
        const t = va();
        if ("local" != uc().env || t.useProductionServers) this.matchMakingSocketUrl = "wss://matchmaking.narrow-one.com/";
        else {
            let t = "wss",
                e = 8084;
            "http:" == location.protocol && (t = "ws", e = 8075), this.matchMakingSocketUrl = `${t}://${window.location.hostname}:${e}/matchmaking`
        }
        uc().preferredMapManager.onMatchMakeDataChange((() => {
            this.sendDownloadedMapHashes()
        })), uc().config.mapsConfig.onConfigChange((() => {
            this.sendCurrentMapsConfigTimestamp()
        })), this.loadSmoothSkillLevel()
    }
    setIsMatchMaking(t) {
        this.isMatchMaking = t, this.onIsMatchMakingChangeCbs.forEach((t => t())), this.updateLoadingText()
    }
    setShouldApplyLoadingText(t) {
        this.shouldApplyLoadingText = t, this.updateLoadingText()
    }
    updateLoadingText() {
        this.matchMakingLoadingText && this.matchMakingLoadingText.setIsLoading(this.isMatchMaking && this.shouldApplyLoadingText)
    }
    async loadSmoothSkillLevel() {
        try {
            const t = await uc().indexedDb.get("matchMakeSavedValues");
            t && (this.smoothSkillLevel = t.smoothSkillLevel, this.smoothSkillLevelGameCount = t.smoothSkillLevelGameCount)
        } catch (t) {}(isNaN(this.smoothSkillLevel) || isNaN(this.smoothSkillLevelGameCount) || "number" != typeof this.smoothSkillLevel || "number" != typeof this.smoothSkillLevelGameCount) && (this.smoothSkillLevel = 0, this.smoothSkillLevelGameCount = 0), this.sendSkillLevel()
    }
    async saveSmoothSkillLevel() {
        try {
            await uc().indexedDb.set("matchMakeSavedValues", {
                smoothSkillLevel: this.smoothSkillLevel,
                smoothSkillLevelGameCount: this.smoothSkillLevelGameCount
            })
        } catch (t) {}
    }
    async initConnection() {
        return this.nextCloseIsIntentional = !1, await this.initConnectionInstance.run()
    }
    async assertInitConnection() {
        if (!await this.initConnection()) throw new dl
    }
    get connected() {
        return this.ws && this.ws.readyState == WebSocket.OPEN
    }
    async attemptSingleWsConnection() {
        const t = new WebSocket(this.matchMakingSocketUrl);
        this.ws = t;
        const e = ["squadId", "squadJoinError", "fullSquadMembersList", "squadMemberUpdated", "squadMemberRemoved", "squadStartedState", "squadSettings", "squadSettingChanged", "yourSquadLeaderState", "squadReadyForStartState"];
        return this.ws.addEventListener("message", (i => {
            if (t != this.ws) return;
            const n = JSON.parse(i.data);
            if ("joinGame" == n.op) {
                this.setIsMatchMaking(!1);
                for (const t of this.onJoinServerReceivedCbs) t(n.game)
            } else "reloadMapsConfig" == n.op ? uc().config.mapsConfig.load() : e.includes(n.op) && this.onSquadMessageCbs.forEach((t => t(n)))
        })), await new Promise((e => {
            t.addEventListener("close", (t => {
                e(null)
            })), t.addEventListener("open", (i => {
                e(t)
            }))
        }))
    }
    closeMatchMakingConnection() {
        if (!this.ws) return;
        this.markNextCloseAsIntentional();
        const t = this.ws;
        this.ws = null, t.close(), this.fireOnCloseCbs()
    }
    markNextCloseAsIntentional() {
        this.nextCloseIsIntentional = !0
    }
    fireOnCloseCbs() {
        this.isMatchMaking && (this.onConnectionCloseDuringMatchMakingCbs.forEach((t => t())), this.setIsMatchMaking(!1)), this.onConnectionCloseCbs.forEach((t => t(this.nextCloseIsIntentional)))
    }
    async updateQueueState({
                               isReadyToJoin: t = !0,
                               maxWaitTimeMs: e
                           } = {}) {
        this.setIsMatchMaking(!0), this.isInUnreadyQueue = !t;
        try {
            await this.assertInitConnection()
        } catch (t) {
            throw this.setIsMatchMaking(!1), t
        }
        const i = uc(),
            n = !i.gameManager.joinedOnce;
        let s;
        s = null == e ? n || i.preferredMapManager.isForcingSoloMap ? 0 : Math.min(5e3, 1e3 * this.smoothSkillLevelGameCount) : e, this.send({
            op: "updateQueueState",
            maxWaitTimeMs: s,
            isFirstGame: n,
            isReadyToJoin: t
        })
    }
    onConnectionOpen(t) {
        this.onConnectionOpenCbs.add(t)
    }
    onConnectionClose(t) {
        this.onConnectionCloseCbs.add(t)
    }
    onConnectionCloseDuringMatchMaking(t) {
        this.onConnectionCloseDuringMatchMakingCbs.add(t)
    }
    onIsMatchMakingChange(t) {
        this.onIsMatchMakingChangeCbs.add(t)
    }
    send(t) {
        if (!this.connected || !this.ws) return;
        const e = JSON.stringify(t);
        this.ws.send(e)
    }
    sendDownloadedMapHashes() {
        const t = uc().preferredMapManager.getMatchMakeData();
        t && this.send(t)
    }
    sendCurrentMapsConfigTimestamp() {
        const t = uc().config.mapsConfig;
        t.loadedConfigData && this.send({
            op: "currentMapsConfigTimestamp",
            timestamp: t.loadedConfigData.lastUpdatedTimestamp
        })
    }
    getMappedSmoothSkillLevel() {
        const t = this.smoothSkillLevel / 100,
            e = -5.7,
            i = -Math.pow(2, 5.7 - 12.8 * t),
            n = (Math.log10(i * e * Math.log10(2) + 1) + e * Math.log10(2)) / (e * Math.log10(2));
        return Math.max(0, n)
    }
    sendSkillLevel() {
        this.send({
            op: "skillLevel",
            skillLevel: this.getMappedSmoothSkillLevel()
        })
    }
    onJoinServerReceived(t) {
        this.onJoinServerReceivedCbs.add(t)
    }
    updateSmoothSkillLevel(t) {
        this.smoothSkillLevelGameCount++;
        const e = ca(0, 5, .7, .4, this.smoothSkillLevelGameCount, !0);
        this.smoothSkillLevel = la(this.smoothSkillLevel, t, e), this.saveSmoothSkillLevel()
    }
    async sendRequestSquadId() {
        await this.assertInitConnection(), this.send({
            op: "requestSquadId"
        })
    }
    async sendJoinSquad(t, e, i) {
        await this.assertInitConnection(), this.send({
            op: "joinSquad",
            squadId: t,
            allowJoinExistingGame: e,
            allowCreate: i
        })
    }
    onSquadMessage(t) {
        this.onSquadMessageCbs.add(t)
    }
    sendSquadSettingChange(t, e) {
        this.send({
            op: "changeSquadSetting",
            setting: t,
            value: e
        })
    }
    sendAllSquadSettings(t) {
        this.send({
            op: "allSquadSettings",
            settings: t
        })
    }
    sendUsername(t) {
        this.send({
            op: "username",
            username: t
        })
    }
    sendStartSquad() {
        this.send({
            op: "startSquad"
        })
    }
    sendAllowAutoStartSquad() {
        this.send({
            op: "allowAutoStartSquad"
        })
    }
    sendRequestSquadLeadership(t) {
        this.send({
            op: "requestSquadLeadership",
            token: t
        })
    }
    sendMySkinData(t) {
        this.send({
            op: "mySkinData",
            skinData: t
        })
    }
}
class Gl {
    constructor(t, e, i) {
        this.networkManager = t, this.matchMakeManager = e, this.gameManager = i, this.isJoiningSquad = !1, this.matchmakeServerSquadId = null, this.gameServerSquadId = null, this.onBeforeJoinFired = !1, this.lastSentUsername = null, this.lastSentSkinDataStr = null, this.matchMakeSquadMembers = new Map, this.matchMakeSquadMembersOnGameJoin = [], this.includeUnjoinedMembers = !1, this.includeUnjoinedMembersTimeout = new ra((() => {
            this.includeUnjoinedMembers = !1, this.updateSquadMembersData()
        }), 3e4), this.gameSquadPlayers = [], this.matchMakeAllReady = !1, this.serverReadyForStartState = !1, this.onServerReadyForStartStateChangeCbs = new Set, this.onServerReadyForStartTrueCbs = new Set, this.clientStartClicked = !1, this.clientStartClickedTimeout = new ra((() => {
            this.clientStartClicked = !1, this.updateStartClicked()
        }), 2e3), this.serverStartClicked = !1, this.startClicked = !1, this.onStartClickedChangeCbs = new Set, this.prevUserVisibleSquadId = null, this.onUserVisibleSquadIdChangeCbs = new Set, this.onIsJoiningSquadChangeCbs = new Set, this.onSquadMembersChangeCbs = new Set, this.currentSquadSettings = null, this.beforeMatchmakeConnectSquadSettings = null, this.myClientIsSquadLeader = !1, this.lastSquadLeaderToken = null, this.onSquadSettingChangeCbs = new Set, this.onMySquadLeaderStateChangeCbs = new Set, this.matchMakeManager.onSquadMessage((t => {
            if ("squadId" == t.op) this.setIsJoiningSquad(!1), this.setMatchmakeServerSquadId(t.squadId), this.sendCurrentUsername(), this.sendMySkinIds(), this.setMyClientIsSquadLeader(!1), this.lastSquadLeaderToken && this.matchMakeManager.sendRequestSquadLeadership(this.lastSquadLeaderToken);
            else if ("squadJoinError" == t.op) this.handleSquadJoinError(t.errorType, t.squadId);
            else if ("squadSettings" == t.op) this.currentSquadSettings = t.settings;
            else if ("squadSettingChanged" == t.op) this.currentSquadSettings && (this.currentSquadSettings[t.setting] = t.value), this.onSquadSettingChangeCbs.forEach((e => e(t.setting, t.value)));
            else if ("yourSquadLeaderState" == t.op) t.token && (this.lastSquadLeaderToken = t.token), this.setMyClientIsSquadLeader(t.isLeader);
            else if ("fullSquadMembersList" == t.op) {
                for (const e of t.members) this.matchMakeSquadMembers.set(e.id, {
                    name: e.name,
                    skinData: Fa(e.skinDataStr),
                    ready: e.ready,
                    leader: e.leader
                });
                this.updateSquadMembersData()
            } else if ("squadMemberUpdated" == t.op) {
                let e = this.matchMakeSquadMembers.get(t.member.id);
                e || (e = {
                    name: "",
                    ready: !1,
                    skinData: Na(),
                    leader: !1
                }, this.matchMakeSquadMembers.set(t.member.id, e)), e.name = t.member.name, e.ready = t.member.ready, e.skinData = Fa(t.member.skinDataStr), e.leader = t.member.leader, this.updateSquadMembersData()
            } else "squadMemberRemoved" == t.op ? (this.matchMakeSquadMembers.delete(t.id), this.updateSquadMembersData()) : "squadReadyForStartState" == t.op ? (this.serverReadyForStartState = t.readyForStart, this.onServerReadyForStartStateChangeCbs.forEach((t => t())), t.readyForStart && this.onServerReadyForStartTrueCbs.forEach((t => t()))) : "squadStartedState" == t.op && (this.serverStartClicked = t.started, this.updateStartClicked(), this.updateLoadingText())
        })), t.onBeforeConnectGameServer((() => {
            this.onBeforeJoinFired = !0, this.gameServerSquadId = this.matchmakeServerSquadId, this.matchMakeSquadMembersOnGameJoin = [];
            for (const t of this.matchMakeSquadMembers.values()) this.matchMakeSquadMembersOnGameJoin.push({
                name: t.name,
                skinData: t.skinData,
                ready: t.ready,
                leader: t.leader
            });
            this.includeUnjoinedMembers = !0, this.includeUnjoinedMembersTimeout.start(), this.updateSquadMembersData(), this.updateUserVisibleSquadId()
        })), t.onConnectionOpen((() => {
            t.sendSquadId(this.userVisibleSquadId || "")
        })), t.onConnectionClosed(((t, e) => {
            this.setIsJoiningSquad(!1), !t && this.gameServerSquadId && "afk" != e && this.joinExistingSquad(this.gameServerSquadId, !1), this.setGameServerSquadId(null)
        })), t.onSquadJoinError((t => {
            this.handleSquadJoinError(t)
        })), this.matchMakeManager.onConnectionOpen((() => {
            if (this.onBeforeJoinFired = !1, this.includeUnjoinedMembersTimeout.stop(), this.serverReadyForStartState = !1, this.currentSquadSettings) {
                const t = {};
                for (const [e, i] of Object.entries(this.currentSquadSettings)) {
                    t[e] = i
                }
                this.beforeMatchmakeConnectSquadSettings = t
            } else this.beforeMatchmakeConnectSquadSettings = null;
            if (this.gameServerSquadId) {
                let t = !0;
                i.currentGame && i.currentGame.gameEnded && (t = !1), this.joinExistingSquad(this.gameServerSquadId, t, t), this.matchMakeManager.sendAllowAutoStartSquad()
            }
            this.serverStartClicked = !1, this.updateStartClicked()
        })), this.matchMakeManager.onConnectionClose((t => {
            t ? this.setMatchmakeServerSquadId(null) : this.matchmakeServerSquadId && this.joinExistingSquad(this.matchmakeServerSquadId), this.lastSentUsername = null, this.lastSentSkinDataStr = null, this.matchMakeSquadMembers.clear(), this.updateSquadMembersData()
        })), this.matchMakeManager.onIsMatchMakingChange((() => {
            this.updateLoadingText()
        })), this.boundUpdateGameSquadPlayers = this.updateGameSquadPlayers.bind(this), i.onCurrentGameChange((t => {
            t && t.onSquadPlayersChange(this.boundUpdateGameSquadPlayers), this.updateGameSquadPlayers()
        })), window.addEventListener("hashchange", (() => {
            this.joinSquadFromCurrentHash()
        }))
    }
    init() {
        this.waitingForSquadLoadingText = uc().mainMenu.requestLoadingText("Waiting for squad...", {
            shouldBounce: !1
        }), this.waitingForSquadStartLoadingText = uc().mainMenu.requestLoadingText("Waiting for squad to start", {
            shouldBounce: !1
        }), uc().profileState.onStateChanged((() => {
            this.matchmakeServerSquadId && this.sendCurrentUsername()
        })), uc().skins.onSkinConfigChange((() => {
            this.sendMySkinIds()
        })), this.joinSquadFromCurrentHash(!0)
    }
    get userVisibleSquadId() {
        return this.matchmakeServerSquadId || this.gameServerSquadId
    }
    get isInSquad() {
        return null != this.userVisibleSquadId
    }
    updateGameSquadPlayers() {
        this.gameSquadPlayers = [];
        const t = this.gameManager.currentGame;
        if (t)
            for (const e of t.players.values()) e.sameSquadOrOwned && this.gameSquadPlayers.push({
                name: e.playerName,
                teamId: e.teamId,
                skinData: e.equippedSkinData,
                leader: !1
            });
        this.updateSquadMembersData()
    }* getMatchMakeSquadMembers() {
        if (this.onBeforeJoinFired) {
            const t = [...this.gameSquadPlayers];
            for (const e of this.matchMakeSquadMembersOnGameJoin) {
                let i = !1,
                    n = 0,
                    s = Na();
                const r = t.findIndex((({
                                            name: t
                                        }) => t == e.name || !("Guest" != e.name || !t.match(/^Guest\s\d+$/))));
                r >= 0 && (n = t[r].teamId, s = t[r].skinData, i = !0, t.splice(r, 1)), (this.includeUnjoinedMembers || i) && (yield {
                    name: e.name,
                    teamId: n,
                    ready: e.ready,
                    joined: i,
                    skinData: s,
                    leader: e.leader
                })
            }
            for (const e of t) yield {
                name: e.name,
                teamId: e.teamId,
                ready: !0,
                joined: !0,
                skinData: e.skinData,
                leader: e.leader
            }
        } else
            for (const t of this.matchMakeSquadMembers.values()) yield {
                name: t.name,
                teamId: 0,
                ready: t.ready,
                joined: !1,
                skinData: t.skinData,
                leader: t.leader
            }
    }
    get totalSquadMemberCount() {
        let t = 0;
        for (const e of this.getMatchMakeSquadMembers()) t++;
        return t
    }
    setSquadSetting(t, e) {
        this.currentSquadSettings && "boolean" == typeof e && (this.currentSquadSettings[t] = e), this.matchMakeManager.connected && this.matchMakeManager.sendSquadSettingChange(t, e)
    }
    onSquadSettingChange(t) {
        this.onSquadSettingChangeCbs.add(t)
    }
    onMySquadLeaderStateChange(t) {
        this.onMySquadLeaderStateChangeCbs.add(t)
    }
    sendCurrentUsername() {
        if (!this.matchMakeManager.connected) return;
        const t = uc().profileState.username;
        t != this.lastSentUsername && (this.lastSentUsername = t, this.matchMakeManager.sendUsername(t))
    }
    sendMySkinIds() {
        if (!this.matchMakeManager.connected) return;
        const t = uc().skins.getClassSkinDataWithAppliedPreset("assault"),
            e = JSON.stringify(t);
        e != this.lastSentSkinDataStr && (this.lastSentSkinDataStr = e, this.matchMakeManager.sendMySkinData(e))
    }
    setMyClientIsSquadLeader(t) {
        this.myClientIsSquadLeader = t, t && this.beforeMatchmakeConnectSquadSettings && (this.matchMakeManager.sendAllSquadSettings(this.beforeMatchmakeConnectSquadSettings), this.beforeMatchmakeConnectSquadSettings = null), this.onMySquadLeaderStateChangeCbs.forEach((t => t()))
    }
    setIsJoiningSquad(t) {
        t != this.isJoiningSquad && (this.isJoiningSquad = t, this.onIsJoiningSquadChangeCbs.forEach((t => t())))
    }
    async requestInitialSquadId() {
        if (!this.isJoiningSquad && !this.isInSquad) {
            if (this.setIsJoiningSquad(!0), this.networkManager.hasGameServerConnection) this.networkManager.sendRequestSquadId();
            else {
                try {
                    await this.matchMakeManager.sendRequestSquadId()
                } catch (t) {
                    throw this.setIsJoiningSquad(!1), t
                }
                this.setIsJoiningSquad(!1)
            }
            this.sendCurrentUsername(), this.sendMySkinIds()
        }
    }
    handleSquadJoinError(t, e) {
        if (this.setIsJoiningSquad(!1), "squad-not-found" == t) {
            let t = "The squad you are trying to join does not exist.";
            null != e && (t = `The squad with code "${e}" does not exist.`), uc().dialogManager.showAlert({
                title: "Squad not found",
                text: t
            })
        } else "client-version-mismatch" == t ? uc().dialogManager.showAlert({
            title: "Joining squad failed",
            text: "Either your version of the game is too old or that of your squadmates is. Refresh the page to update to the latest version."
        }) : "no-mm-connection" == t ? uc().dialogManager.showAlert({
            title: "Joining squad failed",
            text: "Could not connect to the matchmake server. Please try again later."
        }) : "proxy-create-timed-out" == t ? uc().dialogManager.showAlert({
            title: "Failed to create squad id",
            text: "The matchmake server timed out. Please try again later."
        }) : (uc().dialogManager.showAlert({
            title: "Joining squad failed",
            text: "An unknown error occurred. Please try again later."
        }), console.error(`Squad join error: ${t}`));
        this.updateUserVisibleSquadId()
    }
    async joinExistingSquad(t, e = !0, i = !0) {
        if (this.isJoiningSquad) return;
        i && this.networkManager.hasGameServerConnection && this.networkManager.closeCurrentConnection(), this.setIsJoiningSquad(!0);
        let n = [];
        try {
            n = await uc().indexedDb.get("recentSquadIds")
        } catch (t) {
            console.error(t)
        }
        let s = !1;
        n && n.includes(t) && (s = !0);
        try {
            await this.matchMakeManager.sendJoinSquad(t, e, s)
        } catch (t) {
            return console.error(t), uc().dialogManager.showAlert({
                title: "Failed to join the squad",
                text: "Couldn't connect to the server. Please try again later."
            }), this.setIsJoiningSquad(!1), void this.setMatchmakeServerSquadId(null)
        }
        this.sendCurrentUsername(), this.sendMySkinIds()
    }
    setMatchmakeServerSquadId(t) {
        this.matchmakeServerSquadId = t, this.addRecentSquadId(t), this.updateUserVisibleSquadId()
    }
    setGameServerSquadId(t) {
        this.gameServerSquadId = t, this.addRecentSquadId(t), this.updateUserVisibleSquadId()
    }
    addRecentSquadId(t) {
        if (!t) return;
        uc().indexedDb.getSet("recentSquadIds", (e => {
            e || (e = []);
            const i = new Set(e);
            return i.delete(t), i.add(t), (e = Array.from(i)).length > 5 && e.splice(0, e.length - 5), e
        }))
    }
    squadIdReceivedFromGameServer(t) {
        this.setIsJoiningSquad(!1), this.setGameServerSquadId(t)
    }
    onUserVisibleSquadIdChange(t) {
        this.onUserVisibleSquadIdChangeCbs.add(t)
    }
    removeOnUserVisibleSquadIdChange(t) {
        this.onUserVisibleSquadIdChangeCbs.delete(t)
    }
    updateUserVisibleSquadId() {
        let t = this.userVisibleSquadId || "";
        t && (t = "#" + t), t = window.location.pathname + window.location.search + t, history.replaceState(null, "", t), this.userVisibleSquadId != this.prevUserVisibleSquadId && (this.prevUserVisibleSquadId = this.userVisibleSquadId, this.updateLoadingText(), this.onUserVisibleSquadIdChangeCbs.forEach((t => t(this.userVisibleSquadId))))
    }
    updateLoadingText() {
        if (!this.waitingForSquadLoadingText) return;
        if (!this.waitingForSquadStartLoadingText) return;
        const t = !this.isInSquad || this.serverStartClicked;
        this.matchMakeManager.setShouldApplyLoadingText(t), !t && this.matchMakeManager.isMatchMaking ? this.matchMakeAllReady ? (this.waitingForSquadStartLoadingText.setIsLoading(!0), this.waitingForSquadLoadingText.setIsLoading(!1)) : (this.waitingForSquadStartLoadingText.setIsLoading(!1), this.waitingForSquadLoadingText.setIsLoading(!0)) : (this.waitingForSquadLoadingText.setIsLoading(!1), this.waitingForSquadStartLoadingText.setIsLoading(!1))
    }
    updateStartClicked() {
        const t = this.clientStartClicked || this.serverStartClicked;
        t != this.startClicked && (this.startClicked = t, this.onStartClickedChangeCbs.forEach((t => t())))
    }
    joinSquadFromCurrentHash(t = !1) {
        let e = null;
        const i = window.location.hash;
        if (i.startsWith("#")) {
            const t = i.substring(1);
            t && (e = t)
        }
        t && !e || e != this.matchmakeServerSquadId && e != this.gameServerSquadId && (this.isJoiningSquad || (e && e.length > 7 ? this.updateUserVisibleSquadId() : e && this.joinExistingSquad(e)))
    }
    startSquad() {
        this.matchMakeManager.sendStartSquad(), this.clientStartClicked = !0, this.updateStartClicked(), this.clientStartClickedTimeout.start()
    }
    onIsJoiningSquadChange(t) {
        this.onIsJoiningSquadChangeCbs.add(t)
    }
    removeOnIsJoiningSquadChange(t) {
        this.onIsJoiningSquadChangeCbs.delete(t)
    }
    onSquadMembersChange(t) {
        this.onSquadMembersChangeCbs.add(t)
    }
    removeOnSquadMembersChange(t) {
        this.onSquadMembersChangeCbs.delete(t)
    }
    onServerReadyForStartStateChange(t) {
        this.onServerReadyForStartStateChangeCbs.add(t)
    }
    removeOnServerReadyForStartStateChange(t) {
        this.onServerReadyForStartStateChangeCbs.delete(t)
    }
    async waitForServerReadyForStart() {
        const t = new Promise((t => {
            this.onServerReadyForStartTrueCbs.add(t)
        }));
        await t
    }
    onStartClickedChange(t) {
        this.onStartClickedChangeCbs.add(t)
    }
    removeOnStartClickedChange(t) {
        this.onStartClickedChangeCbs.delete(t)
    }
    updateSquadMembersData() {
        let t = !0;
        for (const e of this.matchMakeSquadMembers.values()) e.ready || (t = !1);
        this.matchMakeAllReady != t && (this.matchMakeAllReady = t, this.updateLoadingText()), this.onSquadMembersChangeCbs.forEach((t => t()))
    }
}
class Wl {
    constructor(t) {
        this.ws = null, this.useMatchMaking = !1, this.joiningLoadingText = null, this.connectionOpenedAndDataSent = !1, this.onConnectionOpenCbs = new Set, this.onConnectionClosedCbs = new Set, this.onSquadJoinErrorCbs = new Set, this.onBeforeConnectGameServerCbs = new Set, this.lastSentSkinData = "", this.lastDisconnectReason = "unknown", this.lastDisconnectReasonExtra = [], this.nextCloseIsIntentional = !1, this.nextJoinGameId = -1, this.nextJoinRequestId = null, this.matchMaking = new Hl, this.matchMaking.onJoinServerReceived((t => {
            let e;
            if (this.joiningLoadingText && this.joiningLoadingText.setIsLoading(!0), this.nextJoinGameId = t.gameId, this.nextJoinRequestId = t.joinRequestId ?? null, t.isLocal) e = Wl.getLocalGameServerUrl();
            else {
                e = (t.insecure ? "ws" : "wss") + "://" + t.url4
            }
            this.connect(e), this.matchMaking.closeMatchMakingConnection(), uc().preferredMapManager.disableForcedSoloMap()
        })), this.matchMaking.onConnectionCloseDuringMatchMaking((() => {
            this.fireConnectionClosed()
        })), this.squadManager = new Gl(this, this.matchMaking, t), this.isInit = !1, this.onInitCbs = new Set
    }
    init() {
        const t = uc();
        this.joiningLoadingText = t.mainMenu.requestLoadingText("Joining game...");
        const e = va();
        this.useMatchMaking = "production" == t.env || !!e.useMatchMaking || !!e.useProductionServers, this.matchMaking.init(), t.auth.onLoggedInAccountChange((() => {
            this.sendCurrentSession()
        })), t.auth.onGuestSessionDataChange((() => {
            this.sendCurrentSession()
        })), this.squadManager.init(), this.isInit = !0;
        for (const t of this.onInitCbs) t();
        this.onInitCbs.clear()
    }
    async waitForInit() {
        this.isInit || await new Promise((t => this.onInitCbs.add((() => t(void 0)))))
    }
    get shouldUseMatchMaking() {
        return this.useMatchMaking || this.squadManager.isInSquad
    }
    static getLocalGameServerUrl() {
        let t = 8077,
            e = "ws";
        return "https:" == location.protocol && (t = 8082, e = "wss"), e + "://" + window.location.hostname + ":" + t + "/gameServer"
    }
    async prepareJoinGame() {
        let t = null;
        const e = va();
        if (this.nextCloseIsIntentional = !1, e.ip && !this.squadManager.isInSquad) t = e.ip;
        else if (this.shouldUseMatchMaking) try {
            await this.matchMaking.updateQueueState()
        } catch (t) {
            return void this.fireConnectionClosed()
        } else if ("local" == uc().env) t = Wl.getLocalGameServerUrl();
        else if ("dev" == uc().env || "staging" == uc().env) {
            let e = "ws";
            "https:" == location.protocol && (e = "wss");
            let i = window.location.hostname;
            uc().poki.isPokiBuild && (i = uc().env + ".narrow.one"), t = e + "://" + i + "/ws"
        }
        t && (this.joiningLoadingText && this.joiningLoadingText.setIsLoading(!0), this.connect(t))
    }
    static ceilBytesLength(t) {
        return 4 * Math.ceil(t / 4)
    }
    static get MinusOne() {
        return new Uint32Array([-1])[0]
    }
    static get ReceiveAction() {
        return {
            JOINED_GAME_ID: 0,
            CREATE_PLAYER: 1,
            DESTROY_PLAYER: 2,
            PLAYER_OWNERSHIP: 3,
            PLAYER_DATA: 4,
            CREATE_ARROW: 5,
            CHANGE_FLAG: 6,
            SCOREBOARD: 7,
            FLAG_POSITION: 8,
            PING: 9,
            PLAYER_PING_DATA: 10,
            GAME_END: 11,
            HIT_BY_ARROW: 12,
            DISCONNECT_REASON: 13,
            GAME_MAP_HASH: 14,
            PLAYER_PERFORM_ACTION: 15,
            PLAYER_NAME: 16,
            PLAYER_SCORES: 17,
            CHANGE_SELECTED_WEAPON: 18,
            GAME_START: 19,
            SET_AUTOSHOOT_VALUE: 20,
            EQUIPPED_SKIN_DATA: 21,
            OFFSET_PLAYER_SCORE: 22,
            GAME_END_ACCOUNT_STATS: 23,
            GUEST_DATA_CHANGED: 24,
            PLAYER_TEAM_ID: 25,
            SAME_SQUAD_PLAYERS: 26,
            SQUAD_ID_RESPONSE: 27,
            SQUAD_JOIN_ERROR_RESPONSE: 28,
            REQUEST_MAP_HASH: 29,
            GAME_TIME: 30,
            PLAYER_NAME_VERIFIED: 31,
            GAME_SEED: 32
        }
    }
    static get SendAction() {
        return {
            MY_CLIENT_VERSION: 0,
            REQUEST_JOIN_GAME_ID: 1,
            PLAYER_DATA: 2,
            CREATE_ARROW: 3,
            CHANGE_FLAG: 4,
            PONG: 5,
            CURRENT_LOADED_MAP_HASH: 6,
            HIT_BY_ARROW: 7,
            REQUEST_MAP_HASH: 8,
            PLAYER_PERFORM_ACTION: 9,
            CHANGE_SELECTED_WEAPON: 10,
            MY_SKILL_LEVEL: 11,
            REQUEST_NEXT_GAME_STATE: 12,
            SET_AUTOSHOOT_VALUE: 13,
            EQUIPPED_SKIN_DATA: 14,
            FLAG_RETURN_PROGRESS: 15,
            ACCOUNT_SESSION_DATA: 16,
            SQUAD_ID: 17,
            REQUEST_SQUAD_ID: 18,
            MAP_BOUNDS: 19,
            DEFAULT_FLAG_POSITIONS: 20,
            REPORT_CHEATER: 21
        }
    }
    static get FlagChangeOperation() {
        return {
            GRAB: 0,
            CAPTURE: 1,
            DROP: 2,
            RETURN: 3
        }
    }
    static get DisconnectReason() {
        return {
            UNKNOWN: 0,
            VERSION_OUT_OF_DATE: 1,
            AFK: 2,
            GAME_DOESNT_EXIST: 3,
            PING_TOO_HIGH: 4,
            SUSPECTED_CHEATER: 0
        }
    }
    static get PlayerScoreOffsetReason() {
        return {
            UNKNOWN: 0,
            KILL: 1,
            ASSIST: 2,
            FLAG_CARRIER_KILL: 3,
            FLAG_GRAB: 4,
            FLAG_CARRY: 5,
            FLAG_CAPTURE: 6,
            FLAG_CARRY_ASSIST: 7,
            WIN_BONUS: 8,
            FLAG_RETURN: 9,
            HEADSHOT: 10,
            LONG_RANGE: 11
        }
    }
    closeCurrentConnection(t = !0, e = !0) {
        this.ws && this.ws.readyState == WebSocket.OPEN && (t && this.markNextCloseAsIntentional(), this.ws.close()), this.ws = null, e && (t && this.markNextCloseAsIntentional(), this.fireConnectionClosed())
    }
    async connect(t) {
        this.onBeforeConnectGameServerCbs.forEach((t => t())), this.closeCurrentConnection(!0, !1);
        try {
            this.ws = new WebSocket(t)
        } catch (t) {
            console.error("failed to connect to websocket", t), this.fireConnectionClosed()
        }
        if (this.ws) {
            const t = this.ws;
            this.ws.binaryType = "arraybuffer", this.ws.addEventListener("message", (e => {
                this.ws == t && this.onMessage(new Uint8Array(e.data))
            })), this.ws.addEventListener("close", (e => {
                this.ws == t && this.fireConnectionClosed()
            })), this.ws.addEventListener("open", (e => {
                this.ws == t && this.onOpen()
            })), this.ws.addEventListener("error", (e => {
                console.error("websocket error: ", e), this.ws == t && this.fireConnectionClosed()
            }))
        }
    }
    onMessage(t) {
        const e = t.buffer,
            i = new Float32Array(e, 0, Math.floor(e.byteLength / 4)),
            n = new Uint32Array(e, 0, Math.floor(e.byteLength / 4)),
            s = new Int32Array(e, 0, Math.floor(e.byteLength / 4)),
            r = new Uint16Array(e, 0, Math.floor(e.byteLength / 2));
        if (n[0] == Wl.ReceiveAction.JOINED_GAME_ID) uc().gameManager.joinedGameId(n[1]);
        else if (n[0] == Wl.ReceiveAction.CREATE_PLAYER) {
            const t = n[1],
                e = n[2],
                i = uc().gameManager.currentGame;
            i && i.createPlayer(t, {
                teamId: e
            })
        } else if (n[0] == Wl.ReceiveAction.DESTROY_PLAYER) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            let e = 1;
            for (; e < n.length;) t.destroyPlayer(n[e++])
        } else if (n[0] == Wl.ReceiveAction.PLAYER_OWNERSHIP) {
            const t = n[1],
                e = !!n[2],
                i = uc().gameManager.currentGame;
            i && i.setPlayerOwnership(t, e), e && this.joiningLoadingText && this.joiningLoadingText.setIsLoading(!1)
        } else if (n[0] == Wl.ReceiveAction.PLAYER_DATA) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const i = 1 == r[2];
            let n = 6;
            const s = 12;
            for (; n <= e.byteLength - s;) {
                const r = new Uint8Array(e, n, s),
                    o = new Uint8Array(s);
                o.set(r);
                const a = new Uint16Array(o.buffer);
                n += s;
                const l = a[0],
                    [h, c, d] = this.mapNetworkPosToWorldPos(a[1], a[2], a[3]),
                    u = this.unnormalizeU8(a[4], 2 * Math.PI),
                    p = this.unnormalizeS8(a[5], .5 * Math.PI);
                t.setPlayerServerData(l, h, c, d, u, p, i)
            }
        } else if (n[0] == Wl.ReceiveAction.CREATE_ARROW) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = r[2],
                i = r[3],
                [n, s, o] = this.mapNetworkPosToWorldPos(r[4], r[5], r[6]),
                a = this.unnormalizeS16(r[7], -1, 1),
                l = this.unnormalizeS16(r[8], -1, 1),
                h = this.unnormalizeS16(r[9], -1, 1),
                c = this.unnormalizeU16(r[10]);
            t.createServerArrow(e, i, n, s, o, a, l, h, c)
        } else if (n[0] == Wl.ReceiveAction.CHANGE_FLAG) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = n[2],
                s = n[3];
            t.playerChangeFlag(e, i, s)
        } else if (n[0] == Wl.ReceiveAction.SCOREBOARD) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = [];
            for (let t = 1; t < n.length; t++) e.push(n[t]);
            t.updateScoreboard(e)
        } else if (n[0] == Wl.ReceiveAction.FLAG_POSITION) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = r[2],
                [i, n, s] = this.mapNetworkPosToWorldPos(r[3], r[4], r[5]),
                [o, a, l] = this.mapNetworkVelocityToWorldVelocity(r[6], r[7], r[8]);
            t.setFlagDroppedPosition(e, i, n, s, o, a, l)
        } else if (n[0] == Wl.ReceiveAction.PING) this.send([Wl.SendAction.PONG]);
        else if (n[0] == Wl.ReceiveAction.PLAYER_PING_DATA) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            let i = 4;
            const n = 4;
            for (; i <= e.byteLength - n;) {
                const s = new Uint8Array(e, i, n),
                    r = new Uint8Array(n);
                r.set(s);
                const o = new Uint16Array(r.buffer);
                i += n;
                const a = o[0],
                    l = o[1];
                t.setPlayerPingData(a, l)
            }
        } else if (n[0] == Wl.ReceiveAction.GAME_END) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            t.notifyGameEnded()
        } else if (n[0] == Wl.ReceiveAction.HIT_BY_ARROW) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = n[2],
                s = n[3],
                r = n[4];
            t.playerHitByArrowFromServer(e, i, s, r)
        } else if (n[0] == Wl.ReceiveAction.DISCONNECT_REASON) {
            const [, t, ...e] = n;
            switch (this.lastDisconnectReasonExtra = e, t) {
                case Wl.DisconnectReason.VERSION_OUT_OF_DATE:
                    this.lastDisconnectReason = "version-out-of-date";
                    break;
                case Wl.DisconnectReason.AFK:
                    this.lastDisconnectReason = "afk";
                    break;
                case Wl.DisconnectReason.GAME_DOESNT_EXIST:
                    this.lastDisconnectReason = "game-doesnt-exist";
                    break;
                case Wl.DisconnectReason.PING_TOO_HIGH:
                    this.lastDisconnectReason = "ping-too-high";
                    break;
                case Wl.DisconnectReason.SUSPECTED_CHEATER:
                    this.lastDisconnectReason = "suspected-cheater";
                    break;
                case Wl.DisconnectReason.UNKNOWN:
                default:
                    this.lastDisconnectReason = "unknown"
            }
        } else if (n[0] == Wl.ReceiveAction.GAME_MAP_HASH) {
            const t = this.parseStringMessage(e);
            if (!t) return;
            const i = uc();
            i.mapLoader.loadMapWithDialogMessage(t), i.preferredMapManager.markRecentMap(t)
        } else if (n[0] == Wl.ReceiveAction.PLAYER_PERFORM_ACTION) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = n[2];
            t.receivedPlayerPerformAction(e, i)
        } else if (n[0] == Wl.ReceiveAction.PLAYER_NAME) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const i = n[1],
                s = this.parseStringMessage(e, 8) || "";
            t.setPlayerName(i, s)
        } else if (n[0] == Wl.ReceiveAction.PLAYER_SCORES) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                s = n[2],
                r = n[3],
                o = n[4],
                a = n[5],
                l = i[6];
            t.setPlayerScores({
                playerId: e,
                flags: s,
                kills: r,
                deaths: o,
                total: a,
                skillLevel: l
            })
        } else if (n[0] == Wl.ReceiveAction.CHANGE_SELECTED_WEAPON) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = n[2];
            t.receivePlayerChangeWeapon(e, i)
        } else if (n[0] == Wl.ReceiveAction.GAME_START) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            t.notifyGameStarted()
        } else if (n[0] == Wl.ReceiveAction.SET_AUTOSHOOT_VALUE) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = !!n[2];
            t.playerChangedAutoShootValue(e, i)
        } else if (n[0] == Wl.ReceiveAction.EQUIPPED_SKIN_DATA) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const i = n[1],
                s = Fa(this.parseStringMessage(e, 8) || "");
            t.setPlayerEquippedSkinData(i, s)
        } else if (n[0] == Wl.ReceiveAction.OFFSET_PLAYER_SCORE) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = s[2],
                r = n[3];
            t.offsetPlayerScore(e, i, r)
        } else if (n[0] == Wl.ReceiveAction.GAME_END_ACCOUNT_STATS) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = n[1],
                i = n[2];
            t.receivedGameEndAccountStats({
                receivedCoins: e,
                newCoinCount: i
            })
        } else if (n[0] == Wl.ReceiveAction.GUEST_DATA_CHANGED) {
            const t = this.parseStringMessage(e);
            t && uc().auth.setGuestAccountData(t, !1)
        } else if (n[0] == Wl.ReceiveAction.PLAYER_TEAM_ID) {
            const t = n[1],
                e = n[2],
                i = uc().gameManager.currentGame;
            if (!i) return;
            i.setPlayerTeamId(t, e)
        } else if (n[0] == Wl.ReceiveAction.SAME_SQUAD_PLAYERS) {
            const t = uc().gameManager.currentGame;
            if (!t) return;
            const e = [];
            for (let t = 1; t < n.length; t++) e.push(n[t]);
            t.setSameSquadPlayerIds(e)
        } else if (n[0] == Wl.ReceiveAction.SQUAD_ID_RESPONSE) {
            const t = this.parseStringMessage(e);
            t && this.squadManager.squadIdReceivedFromGameServer(t)
        } else if (n[0] == Wl.ReceiveAction.SQUAD_JOIN_ERROR_RESPONSE) {
            const t = this.parseStringMessage(e);
            this.onSquadJoinErrorCbs.forEach((e => e(t)))
        } else if (n[0] == Wl.ReceiveAction.REQUEST_MAP_HASH) {
            const t = uc().mapLoader.currentMapHash;
            t && this.sendRequestMapHash(t)
        } else if (n[0] == Wl.ReceiveAction.GAME_TIME) {
            const t = n[1],
                e = uc().gameManager.currentGame;
            if (!e) return;
            e.setServerGameTime(t)
        } else if (n[0] == Wl.ReceiveAction.GAME_SEED) {
            const t = n[1],
                e = uc().gameManager.currentGame;
            if (!e) return;
            e.setServerGameSeed(t)
        } else if (n[0] == Wl.ReceiveAction.PLAYER_NAME_VERIFIED) {
            const t = n[1],
                e = uc().gameManager.currentGame;
            if (!e) return;
            e.setPlayerNameVerified(t)
        }
    }
    markNextCloseAsIntentional() {
        this.nextCloseIsIntentional = !0
    }
    fireConnectionClosed() {
        if (this.ws = null, this.joiningLoadingText && this.joiningLoadingText.setIsLoading(1), uc().gameManager.connectionClosed(), this.onConnectionClosedCbs.forEach((t => t(this.nextCloseIsIntentional, this.lastDisconnectReason))), !this.nextCloseIsIntentional) {
            uc().mainMenu.setJoinState("joinable"), uc().input.unlockPointer();
            let t = null;
            switch (this.lastDisconnectReason) {
                case "version-out-of-date":
                    t = "Your version is out of date, update your client in order to play online.";
                    break;
                case "afk":
                    t = "You have been kicked for being afk for too long";
                    break;
                case "game-doesnt-exist":
                    t = "Game not found.";
                    break;
                case "ping-too-high":
                    t = "Your ping is too high, please try again later.";
                    break;
                case "suspected-cheater":
                    t = `Cheats detected. (code ${this.lastDisconnectReasonExtra[0]||0})`;
                    break;
                default:
                    t = "The connection closed abruptly :("
            }
            t && uc().dialogManager.showAlert({
                title: "Connection closed",
                text: t
            })
        }
    }
    onOpen() {
        this.lastDisconnectReason = "unknown", this.lastSentSkinData = "", this.nextCloseIsIntentional = !1;
        const t = va();
        t.gameId ? this.sendJoinGameId(Number(t.gameId)) : (this.sendJoinGameId(this.nextJoinGameId, this.nextJoinRequestId), this.nextJoinGameId = -1), this.sendCurrentVersion(), this.sendCurrentSession(), this.sendMySkillLevel(), this.connectionOpenedAndDataSent = !0;
        for (const t of this.onConnectionOpenCbs) t()
    }
    async waitForConnectionOpen() {
        if (!this.connectionOpenedAndDataSent) return await new Promise((t => this.onConnectionOpenCbs.add((() => t(void 0)))))
    }
    onConnectionOpen(t) {
        this.onConnectionOpenCbs.add(t)
    }
    onConnectionClosed(t) {
        this.onConnectionClosedCbs.add(t)
    }
    onSquadJoinError(t) {
        this.onSquadJoinErrorCbs.add(t)
    }
    onBeforeConnectGameServer(t) {
        this.onBeforeConnectGameServerCbs.add(t)
    }
    get hasGameServerConnection() {
        return this.ws && this.ws.readyState == WebSocket.OPEN
    }
    send(t) {
        if (this.ws && this.hasGameServerConnection) {
            t instanceof Array && (t = new Uint32Array(t));
            try {
                return this.ws.send(t), !0
            } catch (e) {
                throw console.log("error sending message", t), e
            }
        }
    }
    sendStringMessage(t, e) {
        const i = (new TextEncoder).encode(e),
            n = Wl.ceilBytesLength(i.length),
            s = new ArrayBuffer(8 + n),
            r = new Uint32Array(s);
        r[0] = t, r[1] = i.length;
        new Uint8Array(s, 8).set(i), this.send(s)
    }
    parseStringMessage(t, e = 4) {
        if (t.byteLength < e + 4) return null;
        const i = new Uint32Array(t, e, 1)[0];
        try {
            const n = new Uint8Array(t, e + 4, i);
            return (new TextDecoder).decode(n)
        } catch (t) {
            return null
        }
    }
    sendJsonMessage(t, e) {
        const i = JSON.stringify(e);
        this.sendStringMessage(t, i)
    }
    sendCurrentVersion() {
        this.sendStringMessage(Wl.SendAction.MY_CLIENT_VERSION, VERSION_TIMESTAMP)
    }
    sendMySkillLevel() {
        const t = new ArrayBuffer(8),
            e = new Uint32Array(t),
            i = new Float32Array(t);
        e[0] = Wl.SendAction.MY_SKILL_LEVEL, i[1] = this.matchMaking.getMappedSmoothSkillLevel(), this.send(t)
    }
    sendMySkinData(t) {
        const e = JSON.stringify(t);
        e != this.lastSentSkinData && (this.lastSentSkinData = e, this.sendStringMessage(Wl.SendAction.EQUIPPED_SKIN_DATA, e))
    }
    sendJoinGameId(t, e = null) {
        let i = 8;
        e && (i += 16);
        const n = new ArrayBuffer(i),
            s = new Uint32Array(n);
        if (s[0] = Wl.SendAction.REQUEST_JOIN_GAME_ID, s[1] = t, e) {
            const t = function(t) {
                const e = new ArrayBuffer(16);
                if (!t) return e;
                let i = 0,
                    n = 0;
                const s = new DataView(e);
                for (; i < t.length;) {
                    "-" == t[i] && i++;
                    const e = t.slice(i, i + 2),
                        r = parseInt(e, 16);
                    s.setUint8(n++, r), i += 2
                }
                return e
            }(e);
            new Uint8Array(n).set(new Uint8Array(t), 8)
        }
        this.send(n)
    }
    sendPlayerData(t, {
        posX: e = 0,
        posY: i = 0,
        posZ: n = 0,
        rotX: s = 0,
        rotY: r = 0
    } = {}) {
        const o = new ArrayBuffer(16),
            a = new Uint32Array(o, 0, 1),
            l = new Uint16Array(o, 0);
        a[0] = Wl.SendAction.PLAYER_DATA, l[2] = t;
        const [h, c, d] = this.mapWorldPosToNetworkPos(e, i, n);
        l[3] = h, l[4] = c, l[5] = d;
        const u = 2 * Math.PI;
        l[6] = this.normalizeU8(aa(s, u), u), l[7] = this.normalizeS8(r, .5 * Math.PI), this.send(o)
    }
    normalizeS16(t, e, i) {
        return this.normalize(t, e, i, 16)
    }
    normalizeU16(t, e = 1) {
        return this.normalize(t, 0, e, 16)
    }
    normalizeS8(t, e = 1) {
        return this.normalize(t, -e, e, 8)
    }
    normalizeU8(t, e = 1) {
        return this.normalize(t, 0, e, 8)
    }
    normalize(t, e = -1, i = 1, n = 8) {
        return t = ca(e, i, 0, 2 ** n - 1, t, !0), t = Math.round(t)
    }
    unnormalizeS16(t, e, i) {
        return this.unnormalize(t, e, i, 16)
    }
    unnormalizeU16(t, e = 1) {
        return this.unnormalize(t, 0, e, 16)
    }
    unnormalizeS8(t, e = 1) {
        return this.unnormalize(t, -e, e, 8)
    }
    unnormalizeU8(t, e = 1) {
        return this.unnormalize(t, 0, e, 8)
    }
    unnormalize(t, e = -1, i = 1, n = 8) {
        return t = ca(0, 2 ** n - 1, e, i, t, !0)
    }
    getWorldBounds() {
        let t = 0,
            e = 0,
            i = 0,
            n = 0,
            s = 0,
            r = 0;
        const o = uc().physics.mapBounds;
        return o && (t = o.min.x - 5, e = o.min.y - 5, i = o.min.z - 5, n = o.max.x + 5, s = o.max.y + 5, r = o.max.z + 5), {
            minX: t,
            minY: e,
            minZ: i,
            maxX: n,
            maxY: s,
            maxZ: r
        }
    }* getDefaultFlagNetworkPositions(t) {
        for (const e of t) yield this.mapWorldPosToNetworkPos(e.position.x, e.position.y, e.position.z)
    }
    mapWorldPosToNetworkPos(t, e, i) {
        const n = this.getWorldBounds();
        return [this.normalizeS16(t, n.minX, n.maxX), this.normalizeS16(e, n.minY, n.maxY), this.normalizeS16(i, n.minZ, n.maxZ)]
    }
    mapNetworkPosToWorldPos(t, e, i) {
        const n = this.getWorldBounds();
        return [this.unnormalizeS16(t, n.minX, n.maxX), this.unnormalizeS16(e, n.minY, n.maxY), this.unnormalizeS16(i, n.minZ, n.maxZ)]
    }
    mapNetworkVelocityToWorldVelocity(t, e, i) {
        return [this.unnormalizeS16(t, -30, 30), this.unnormalizeS16(e, -30, 30), this.unnormalizeS16(i, -30, 30)]
    }
    sendCreateArrow(t, {
        arrowId: e,
        pos: i,
        dir: n,
        fireAmount01: s
    }) {
        const r = new ArrayBuffer(22),
            o = new Uint32Array(r, 0, 4),
            a = new Uint16Array(r, 0);
        o[0] = Wl.SendAction.CREATE_ARROW, a[2] = t, a[3] = e;
        const [l, h, c] = this.mapWorldPosToNetworkPos(i.x, i.y, i.z);
        a[4] = l, a[5] = h, a[6] = c;
        const [d, u, p] = this.mapNetworkPosToWorldPos(l, h, c), m = this.normalizeS16(n.x, -1, 1), g = this.normalizeS16(n.y, -1, 1), f = this.normalizeS16(n.z, -1, 1);
        a[7] = m, a[8] = g, a[9] = f;
        const y = this.unnormalizeS16(m, -1, 1),
            v = this.unnormalizeS16(g, -1, 1),
            b = this.unnormalizeS16(f, -1, 1),
            x = this.normalizeU16(s);
        a[10] = x;
        const S = this.unnormalizeU16(x);
        this.send(r);
        return {
            arrowId: e,
            pos: new w(d, u, p),
            dir: new w(y, v, b),
            fireAmount01: S,
            networkOffsetPos: new w(0, 0, 0)
        }
    }
    sendChangeFlag(t, e, i) {
        this.send([Wl.SendAction.CHANGE_FLAG, t, e, i])
    }
    sendCurrentLoadedMapHash(t) {
        this.sendStringMessage(Wl.SendAction.CURRENT_LOADED_MAP_HASH, t)
    }
    sendWorldBounds() {
        const t = new ArrayBuffer(28);
        new Uint32Array(t, 0, 1)[0] = Wl.SendAction.MAP_BOUNDS;
        const e = new Float32Array(t, 0),
            i = this.getWorldBounds();
        e[1] = i.minX, e[2] = i.minY, e[3] = i.minZ, e[4] = i.maxX, e[5] = i.maxY, e[6] = i.maxZ, this.send(t)
    }
    sendDefaultFlagPositions(t) {
        const e = Array.from(this.getDefaultFlagNetworkPositions(t)),
            i = new ArrayBuffer(4 + 3 * e.length * 2);
        new Uint32Array(i, 0, 1)[0] = Wl.SendAction.DEFAULT_FLAG_POSITIONS;
        const n = new Uint16Array(i, 4);
        for (const [t, i] of e.entries()) n[3 * t + 0] = i[0], n[3 * t + 1] = i[1], n[3 * t + 2] = i[2];
        this.send(i)
    }
    sendReportCheater(t, e) {
        this.send([Wl.SendAction.REPORT_CHEATER, t, e])
    }
    sendHitByArrow(t, e, i, n) {
        this.send([Wl.SendAction.HIT_BY_ARROW, t, e, i, n])
    }
    sendRequestMapHash(t) {
        this.sendStringMessage(Wl.SendAction.REQUEST_MAP_HASH, t)
    }
    sendRequestNextGameState() {
        this.send([Wl.SendAction.REQUEST_NEXT_GAME_STATE])
    }
    sendPlayerPerformAction(t, e) {
        this.send([Wl.SendAction.PLAYER_PERFORM_ACTION, t, e])
    }
    sendChangeSelectedWeapon(t, e) {
        this.send([Wl.SendAction.CHANGE_SELECTED_WEAPON, t, e])
    }
    sendAutoShootValue(t, e) {
        this.send([Wl.SendAction.SET_AUTOSHOOT_VALUE, t, e ? 1 : 0])
    }
    sendFlagReturnProgress(t, e) {
        const i = this.normalize(e, 0, 1, 32);
        this.send([Wl.SendAction.FLAG_RETURN_PROGRESS, t, i])
    }
    async sendCurrentSession() {
        const t = await uc().auth.getSessionDataForGameServer();
        this.sendSession(t)
    }
    sendSession(t) {
        const e = JSON.stringify(t);
        this.sendStringMessage(Wl.SendAction.ACCOUNT_SESSION_DATA, e)
    }
    sendSquadId(t) {
        this.sendStringMessage(Wl.SendAction.SQUAD_ID, t)
    }
    sendRequestSquadId() {
        this.send([Wl.SendAction.REQUEST_SQUAD_ID])
    }
}
class ql {
    constructor(t, e, i, n, s) {
        this.rigidBody = t, this.radius = e, this.heightOffset = i, this.bodyPart = n, this.arrowDamage = s
    }
    get center() {
        const t = this.rigidBody.pos.clone();
        return t.y += this.heightOffset, t
    }
    rayCast(t, e) {
        const i = t.x,
            n = t.y,
            s = t.z,
            r = e.x,
            o = e.y,
            a = e.z,
            l = this.center,
            h = l.x,
            c = l.y,
            d = l.z,
            u = 2 * (i * r + n * o + s * a - r * h - o * c - a * d),
            p = u * u - 4 * (i * i - 2 * i * h + h * h + n * n - 2 * n * c + c * c + s * s - 2 * s * d + d * d - this.radius * this.radius);
        if (p < 0) return null;
        const m = (-u - Math.sqrt(p)) / 2;
        if (m < 0) return null;
        const g = t.clone().addScaledVector(e, m);
        return {
            dist: g.distanceTo(t),
            pos: g,
            collider: this
        }
    }
}
class jl {
    constructor(t, {
        ignoreArrows: e = !1,
        isLadder: i = !1,
        isLadderAllSides: n = !1,
        excludeTeamId: s = -1,
        isDeathTrigger: r = !1,
        allowJump: o = !0,
        movePlayerUp: a = !0,
        slippery: l = !1,
        slowDownPlayerAmount: h = 0
    }) {
        this.invWorldMatrix = t.clone().invert(), this.invWorldMatrixNoTranslate = this.invWorldMatrix.clone().setPosition(0, 0, 0), this.worldMatrix = t, this.aabb = null, this.ignoreArrows = e, this.isLadder = i, this.isLadderAllSides = n, this.isDeathTrigger = r, this.allowJump = o, this.movePlayerUp = a, this.slippery = l, this.slowDownPlayerAmount = h, this.excludeTeamId = s
    }
    rayCast(t, e) {
        throw new Error("base class")
    }
    getSphereManifold(t, e) {
        throw new Error("base class")
    }
}
const Yl = 1,
    Jl = 2,
    Xl = 3,
    $l = 4,
    Zl = 5,
    Kl = 6;
class Ql extends jl {
    constructor(...t) {
        super(...t), this.box = new S(new w(-1, -1, -1), new w(1, 1, 1)), this.aabb = this.box.clone(), this.aabb.applyMatrix4(this.worldMatrix), this.cachedUpFaces = null
    }
    getSphereManifold(t, e) {
        const i = t.clone().applyMatrix4(this.invWorldMatrix),
            n = this.box.clampPoint(i, new w);
        let s = 0;
        (n.x <= -1 || n.x >= 1) && s++, (n.y <= -1 || n.y >= 1) && s++, (n.z <= -1 || n.z >= 1) && s++;
        const r = s >= 2,
            o = this.getUpFaces(),
            a = this.getIsOnFace(n, o[0]),
            l = this.getIsOnFace(n, o[1]);
        n.applyMatrix4(this.worldMatrix);
        const h = e - t.distanceTo(n);
        return {
            colliderType: "box",
            pos: n,
            isAtEdge: r,
            isAtUpFace: a,
            isAtSecondUpFace: l,
            normal: t.clone().sub(n).normalize(),
            penetration: h
        }
    }
    getUpFaces() {
        if (this.cachedUpFaces) return this.cachedUpFaces;
        const t = new w,
            e = new w(1, 0, 0),
            i = new w(0, 1, 0),
            n = new w(0, 0, 1);
        t.applyMatrix4(this.worldMatrix), e.applyMatrix4(this.worldMatrix), i.applyMatrix4(this.worldMatrix), n.applyMatrix4(this.worldMatrix), e.sub(t), i.sub(t), n.sub(t), e.normalize(), i.normalize(), n.normalize();
        const s = e.clone().negate(),
            r = i.clone().negate(),
            o = n.clone().negate(),
            a = new w(0, 1, 0),
            l = [{
                face: Yl,
                normal: i,
                dot: 0
            }, {
                face: Jl,
                normal: r,
                dot: 0
            }, {
                face: Xl,
                normal: e,
                dot: 0
            }, {
                face: $l,
                normal: s,
                dot: 0
            }, {
                face: Zl,
                normal: n,
                dot: 0
            }, {
                face: Kl,
                normal: o,
                dot: 0
            }];
        for (const t of l) t.dot = t.normal.dot(a);
        return l.sort(((t, e) => e.dot - t.dot)), this.cachedUpFaces = l, this.cachedUpFaces
    }
    getIsOnFace(t, e) {
        switch (e.face) {
            case Yl:
                return t.y >= 1;
            case Jl:
                return t.y <= -1;
            case Xl:
                return t.x >= 1;
            case $l:
                return t.x <= -1;
            case Zl:
                return t.z >= 1;
            case Kl:
                return t.z <= -1
        }
        return !1
    }
    rayCast(t, e) {
        const i = t;
        t = t.clone().applyMatrix4(this.invWorldMatrix), e = e.clone().applyMatrix4(this.invWorldMatrixNoTranslate);
        const n = (this.box.min.x - t.x) / e.x,
            s = (this.box.max.x - t.x) / e.x,
            r = (this.box.min.y - t.y) / e.y,
            o = (this.box.max.y - t.y) / e.y,
            a = (this.box.min.z - t.z) / e.z,
            l = (this.box.max.z - t.z) / e.z,
            h = Math.min(Math.max(n, s), Math.max(r, o), Math.max(a, l));
        if (h < 0) return null;
        const c = Math.max(Math.min(n, s), Math.min(r, o), Math.min(a, l));
        if (c < h) {
            const n = t.clone().addScaledVector(e, c);
            n.applyMatrix4(this.worldMatrix);
            return {
                dist: n.distanceTo(i),
                pos: n,
                collider: this
            }
        }
        return null
    }
}
class th {
    constructor() {
        this.enabled = !0
    }
    beginPhysicsSteps() {}
    stepVelocity(t) {}
    resolveMapCollisionsOctree(t) {}
    endPhysicsSteps() {}
}
class eh extends th {
    constructor(t) {
        super(), this.player = t, this.pos = new w, this.velocity = new w, this.totalForce = new w, this.colliders = [new ql(this, .4, .4, "feet", 1 / 3), new ql(this, .5, 1.1, "body", .5), new ql(this, .3, 1.7, "head", 1)], this.aabb = new S;
        for (const t of this.colliders) {
            const e = t.radius,
                i = new S(new w(-e, -e, -e), new w(e, e, e));
            i.translate(t.center), this.aabb.union(i)
        }
        this.gravity = new w(0, -30, 0), this.lastFloorTouchTime = 0, this.lastJumpableColliderTouchTime = 0, this.isOnFloor = 1, this.isOnJumpableCollider = 1, this.lastJumpTime = 0, this.inAirAfterJump = !1, this.climbingLadder = null, this.climbingLadderNormal = null, this.wasOnFloorLastFrame = !1, this.isOnSlipperyCollider = !1, this.slowDownColliderAmount = 0
    }
    beginPhysicsSteps() {
        this.wasOnFloorLastFrame = this.isOnFloor, this.isOnFloor = 1, this.isOnSlipperyCollider = !1, this.isOnJumpableCollider = 1
    }
    stepVelocity(t) {
        this.climbingLadder || this.velocity.addScaledVector(this.gravity, t), this.velocity.addScaledVector(this.totalForce, t);
        let e = .9995,
            i = e;
        this.isOnSlipperyCollider ? e = .2 : this.climbingLadder ? (e = .9999, i = .9999) : this.wasOnFloorLastFrame || (i = .2, e = .9);
        const n = Math.pow(1 - e, t),
            s = Math.pow(1 - i, t);
        this.velocity.x *= n, this.velocity.y *= s, this.velocity.z *= n, this.pos.addScaledVector(this.velocity, 0.002)
    }
    endPhysicsSteps() {
        (this.isOnFloor || this.climbingLadder) && (this.lastFloorTouchTime = uc().now, this.inAirAfterJump = !1), this.isOnJumpableCollider && (this.lastJumpableColliderTouchTime = uc().now), this.totalForce.set(0, 0, 0)
    }
    get inAirTime() {
        return this.isOnFloor || this.climbingLadder ? 0 : uc().now - this.lastFloorTouchTime
    }
    get onJumpableColliderTime() {
        return this.isOnJumpableCollider || this.climbingLadder ? 0 : uc().now - this.lastJumpableColliderTouchTime
    }
    getCurrentPlayerAabb() {
        const t = this.aabb.clone();
        return t.translate(this.pos), t
    }
    getIntersectingOctreeNodes() {
        const t = this.getCurrentPlayerAabb();
        return uc().physics.getOctreeNodesInAabb(t)
    }
    getManifolds() {
        const t = [],
            e = this.getCurrentPlayerAabb();
        for (const i of uc().physics.getCollidersForAabbUsingOctree(e))
            if (i.aabb && i.aabb.intersectsBox(e) && i.excludeTeamId != this.player.teamId)
                for (const e of this.colliders) {
                    const n = i.getSphereManifold(e.center, e.radius);
                    n.penetration > 0 && t.push({
                        manifold: n,
                        mapCollider: i,
                        playerCollider: e
                    })
                }
        return t
    }
    resolveMapCollisionsOctree(t) {
        const e = this.getManifolds();
        this.slowDownColliderAmount = 0;
        let i = 0;
        for (const {
            manifold: t,
            mapCollider: n,
            playerCollider: s
        }
            of e) {
            const e = t.normal.dot(new w(0, 1, 0));
            if (n.isDeathTrigger) continue;
            if (n.slowDownPlayerAmount > 0) continue;
            if (!n.movePlayerUp) continue;
            if (this.needsLadderPhysics(t, n)) continue;
            let r = !1;
            if ("feet" == s.bodyPart && (e > .6 || "box" == t.colliderType && t.isAtEdge && t.isAtUpFace && e > .1) && (r = !0), r && t.penetration > 0) {
                const e = t.normal.clone();
                e.setLength(t.penetration + 1e-7);
                const s = t.normal.clone().cross(new w(0, 1, 0));
                if (s.lengthSq() > 0) {
                    const i = s.clone().cross(t.normal);
                    let n = 0;
                    0 != i.x ? n = Math.abs(e.x / i.x) : 0 != i.z && (n = Math.abs(e.z / i.z)), i.multiplyScalar(n), e.add(i)
                }
                e.y > 0 && e.y < 1 && (i = Math.max(e.y, i), this.isOnFloor = !0, n.allowJump && (this.isOnJumpableCollider = !0), n.slippery && (this.isOnSlipperyCollider = !0))
            }
        }
        let n = e;
        if (i > 0) {
            const t = this.pos.clone();
            this.pos.y += i;
            const s = new Map;
            for (const {
                manifold: t,
                mapCollider: i
            }
                of e) {
                let e = s.get(i) || 0;
                e = Math.max(e, t.penetration), s.set(i, e)
            }
            let r = !1;
            const o = this.getManifolds();
            for (const {
                manifold: t,
                mapCollider: e
            }
                of o) {
                if (!s.has(e)) {
                    r = !0;
                    break
                } {
                    const i = s.get(e);
                    if (null != i && t.penetration > i) {
                        r = !0;
                        break
                    }
                }
            }
            r ? this.pos.copy(t) : n = o
        }
        let s = null;
        for (const {
            manifold: t,
            mapCollider: e,
            playerCollider: i
        }
            of n) {
            const n = this.needsLadderPhysics(t, e);
            if (e.slowDownPlayerAmount > 0) {
                const i = ca(0, .5, 0, e.slowDownPlayerAmount, t.penetration, !0);
                this.slowDownColliderAmount = Math.max(this.slowDownColliderAmount, i);
                continue
            }
            const r = this.velocity.dot(t.normal);
            if (r < 0) {
                const o = t.normal.dot(new w(0, 1, 0));
                e.isDeathTrigger ? this.player.dieFromFall() : n && (e.isLadderAllSides || "head" != i.bodyPart && o > -.1) && (s = e, this.climbingLadderNormal = t.normal.clone()), this.velocity.addScaledVector(t.normal, -r);
                const a = .8,
                    l = .001,
                    h = Math.max(t.penetration - l, 0) * a,
                    c = t.normal.clone().multiplyScalar(h);
                this.pos.add(c), "feet" == i.bodyPart && o > .3 && !n && (this.isOnFloor = !0, e.allowJump && (this.isOnJumpableCollider = !0), e.slippery && (this.isOnSlipperyCollider = !0))
            }
        }
        if (!s) {
            const t = this.climbingLadder;
            if (t)
                for (const e of this.colliders) {
                    t.getSphereManifold(e.center, e.radius).penetration > -.05 && (s = t)
                }
        }!s && this.climbingLadder && uc().now - this.lastJumpTime > 300 && (this.velocity.y *= .3), this.climbingLadder = s
    }
    needsLadderPhysics(t, e) {
        if (!(e instanceof Ql)) return !1;
        if ("box" != t.colliderType) return !1;
        if (!e.isLadder && !e.isLadderAllSides) return !1;
        const i = new w(0, 1, 0),
            n = t.normal.dot(i);
        if (n > -1e-4 && n < 1e-4) {
            if (e.getUpFaces()[0].normal.dot(i) > .9999) return !0
        }
        return !!e.isLadderAllSides || t.isAtSecondUpFace && !t.isAtEdge
    }
    applyForce(t) {
        this.totalForce.add(t)
    }
    getAllowJump() {
        return !(this.onJumpableColliderTime > 200) && !this.inAirAfterJump
    }
    jump(t) {
        this.isOnFloor = !1, this.isOnJumpableCollider = !1, this.isOnSlipperyCollider = !1, this.inAirAfterJump = !0, this.lastJumpTime = uc().now;
        const e = Math.max(0, t - this.velocity.y);
        this.velocity.y += e
    }
}
const ih = 1,
    nh = 2,
    sh = 3;
class rh {
    constructor() {
        this.reportedPlayerTimes = new Map, this.onPlayerNeedsReportCbs = new Set
    }
    reportPlayer(t, e) {
        const i = this.reportedPlayerTimes.get(t),
            n = uc().now;
        i && n < i + 1e4 || (this.reportedPlayerTimes.set(t, n), this.onPlayerNeedsReportCbs.forEach((i => i(t, e))))
    }
    onPlayerNeedsReport(t) {
        this.onPlayerNeedsReportCbs.add(t)
    }
}
class oh {
    constructor(t, e, i, n, s, r, o, {
        teamId: a = 0
    } = {}) {
        this.game = t, this.inputManager = e, this.sfxManager = i, this.physicsManager = n, this.settingsManager = s, this.hudIconsManager = r, this.id = o, this.hasOwnership = !1, this.creationTime = uc().now, this.teamId = a, this.equippedSkinData = {
            equippedSkinIds: []
        }, this.isSameSquadPlayer = !1, this.gender = "male", this.walkSpeed = 60, this.airWalkSpeedMultiplier = .4, this.flagWalkSpeed = 45, this.jumpForce = 8.6, this.ladderClimbSpeed = 1, this.ladderTangentWalkSpeed = .5, this.health = 1, this.lastHitTime = 0, this.damageReceivedHistory = [], this.currentHealthRegenSfx = null, this.playerName = "", this.playerNameVerified = !1, this.scoreFlags = 0, this.scoreKills = 0, this.scoreDeaths = 0, this.scoreTotal = 0, this.scoreSkillLevel = 0, this.serverPos = new w, this.recentForcedServerPositions = new Set, this.lastReceivedServerPosTime = 0, this.maxPredictedServerPosDistance = 3, this.predictedServerPos = new w, this.lastPredictedServerVelocity = new w, this.predictedServerVelocity = new w, this.predictedServerAcceleration = new w, this.serverPosSmooth = new w, this.unlockRigidBodyY = !1, this.networkPosIsMovingUp = !1, this.flyAntiCheatCooldownTime = 0, this.pos = new w, this.negativeHealthStartTime = 0, this.prevHealthIsNegative = !1, this.cachedCamPos = new w, this.cachedCamPosDirty = !0, this.cachedCamRot = new v, this.cachedCamRotDirty = !0, this.lookRot = new h, this.smoothLookRotTarget = new h, this.noSentDataChangeUpdateCount = 0, this.lastSentPos = new w, this.lastSentRot = new h, this.lastPosSentTime = 0, this.ping = 0, this.positionHistory = [], this.rigidBody = new eh(this), this.physicsManager.registerRigidBody(this.rigidBody), this.boundOnJumpPress = this.onJumpPress.bind(this), this.boundOnFireDown = this.onFireDown.bind(this), this.boundOnFireUp = this.onFireUp.bind(this), this.lastAirJumpPressTime = -1, this.prevWasOnFloor = !1, this.prevOnFloorTime = 0, this.hasTouchedFloorEver = !1, this.lastJumpTime = 0, this.lastJumpLandTime = 0, this.lastJumpLandAmount = 0, this.highestInAirPoint = 0, this.currentFallingSfx = null, this.hasKeyEvents = !1, this.useFirstPersonHoldingHandlers = !1, this.thirdPerson = !1, this.noclip = !1, this.noclipSpeed = 0, this.movementAccuracyOffset = null, this.holdingFlag = null, this.sentChangeFlagMessages = [], this.statClassValues = null, this.holdingHandlers = new Set, this.loadingModel = null, this.activeModel = null, this.skeleton = new Ha({
            player: this,
            init: !1
        }), this.weapon = null, this.lastSentArrowId = 0, this.dead = !1, this.didInitRespawn = !1, this.hasWalkedAwayFromSpawn = !1, this.lastRespawnPosition = new w, this.onWeaponSelectionChangeFromDialog = () => {
            this.updateMySelectedWeapon(), !this.dead && this.hasOwnership && this.sendMyEquippedSkinData()
        }, this.onSkinConfigChange = () => {
            this.hasOwnership && this.sendMyEquippedSkinData()
        }, uc().skins.onSkinConfigChange(this.onSkinConfigChange), this.smoothCamSetting = !1, this.smoothCamDebug = !1, this.smoothCam = !1, this.lastShotByOwnerTime = 0, this.nextHitFlashIndex = 0, this.obj = null, this.legsMoveT = 0, this.legsMoveAmount = 0, this.walkHeadBobAmount = 0, this.legsMoveSpeed = 2, this.lastSfxStep = 0, this.waitForSkeletonLoad(), this.updateUseFirstPersonHoldingHandlers(), this.boundOnAutoShootSettingChange = this.onAutoShootSettingChange.bind(this), this.settingsManager.onValueChange("autoShoot", this.boundOnAutoShootSettingChange), this.sendAutoShootValue(), this.icon = this.hudIconsManager.createIcon({
            url: "img/hudIcons/playerIcon.svg",
            size: .03
        }), this.destructed = !1
    }
    init() {
        this.skeleton.init(), this.setPlayerEquippedSkinData(this.equippedSkinData), this.updateIconVisibility()
    }
    async waitForSkeletonLoad() {
        await this.skeleton.waitForLoad(), this.destructed || this.updateModelVisibility()
    }
    destructor() {
        this.destructed || (this.destructed = !0, this.obj && uc().scene.remove(this.obj), this.activeModel && this.activeModel.destructor(), this.loadingModel && this.loadingModel.destructor(), this.physicsManager.removeRigidBody(this.rigidBody), uc().skins.removeOnSkinConfigChange(this.onSkinConfigChange), this.settingsManager.removeOnValueChange("autoShoot", this.boundOnAutoShootSettingChange), this.icon.destructor(), this.setHasKeyEvents(!1), this.stopFallSound(), this.stopHealthRegenSound(), this.removeActiveWeapon())
    }
    get sameSquadOrOwned() {
        return this.isSameSquadPlayer || this.hasOwnership
    }
    removeActiveWeapon() {
        this.weapon && this.weapon.destructor(), this.weapon = null
    }
    setActiveWeapon(t, e = !1) {
        this.weapon && t == this.weapon.weaponId && !e || (this.removeActiveWeapon(), t < 0 || t >= Ea.length || (this.weapon = new Nl(this, t), this.weapon.setHasCursorAccuracyOffset(this.hasOwnership), this.weapon.setAutoShootEnabled(this.settingsManager.getValue("autoShoot")), this.hasOwnership && uc().network.sendChangeSelectedWeapon(this.id, t), this.skeleton.updateWeaponPoses()))
    }
    updateMySelectedWeapon(t = !1) {
        this.hasOwnership && (this.dead ? this.removeActiveWeapon() : this.setActiveWeapon(this.game.weaponSelectionDialog.currentSelectedWeaponIndex, t))
    }
    sendMyEquippedSkinData() {
        const t = uc(),
            e = Ea[this.game.weaponSelectionDialog.currentSelectedWeaponIndex],
            i = t.skins.getClassSkinDataWithAppliedPreset(e.id);
        t.network.sendMySkinData(i)
    }
    getSendArrowId() {
        return this.lastSentArrowId++, this.lastSentArrowId >= 65536 && (this.lastSentArrowId = 0), this.lastSentArrowId
    }
    loop(t, e) {
        if (this.hasOwnership) {
            if (!this.dead) {
                if (this.smoothCam) this.inputManager.lookInput.length() > .1 && uc().renderer.renderWorthyEventHappened(1e4), this.smoothLookRotTarget.addScaledVector(this.inputManager.lookInput, -.002), this.lookRot.lerp(this.smoothLookRotTarget, .1);
                else {
                    this.inputManager.lookInput.length() > .1 && uc().renderer.renderWorthyEventHappened();
                    const t = ca(0, 180, 1, .1, uc().cam.fovOffset, !0);
                    this.lookRot.addScaledVector(this.inputManager.lookInput, -.002 * t)
                }
                this.lookRot.y = da(this.lookRot.y, .5 * -Math.PI, .5 * Math.PI), this.cachedCamRotDirty = !0
            }
            let i = new h;
            uc().mainMenu.visible || (i = this.inputManager.walkInput), i.length() > .01 && uc().renderer.renderWorthyEventHappened();
            const n = new w(i.x, 0, i.y);
            n.applyQuaternion(this.getClampedCamRot()), n.clampLength(0, 1);
            const s = n.length();
            this.noclip || (n.y = 0), n.setLength(s);
            let r = this.holdingFlag ? this.flagWalkSpeed : this.walkSpeed;
            this.rigidBody.isOnSlipperyCollider ? r *= .15 : this.rigidBody.climbingLadder ? r *= this.ladderClimbSpeed : this.rigidBody.isOnFloor || (r *= this.airWalkSpeedMultiplier);
            const o = .8;
            if (r *= 1 / (this.rigidBody.slowDownColliderAmount * o + 1), r *= la(.9, 1.1, this.getStatClassValue("movementSpeed")), this.weapon && (r *= this.weapon.walkSpeedMultiplier), this.rigidBody.climbingLadder && this.rigidBody.climbingLadderNormal) {
                const t = n.dot(this.rigidBody.climbingLadderNormal),
                    e = uc().now - this.lastJumpTime > 500 && !this.rigidBody.isOnFloor;
                let i = !0;
                if (t > 0 && !e && (i = !1), i) {
                    const t = new v;
                    t.setFromUnitVectors(new w(0, 1, 0), this.rigidBody.climbingLadderNormal), n.applyQuaternion(t)
                }
                const s = this.rigidBody.climbingLadderNormal.clone().cross(new w(0, 1, 0));
                s.normalize();
                const r = n.dot(s),
                    o = s.clone().multiplyScalar(r * (1 - this.ladderTangentWalkSpeed));
                n.sub(o)
            }
            if (this.noclip && (this.inputManager.getKey("flyUp").pressed && (n.y += 1, uc().renderer.renderWorthyEventHappened()), this.inputManager.getKey("flyDown").pressed && (n.y -= 1, uc().renderer.renderWorthyEventHappened())), n.multiplyScalar(r), this.noclip && this.noclipCamVelocity && this.noclipCamPos) {
                const t = e / 1e3;
                this.noclipCamVelocity.addScaledVector(n, t * 1.001 ** this.noclipSpeed), this.noclipCamVelocity.multiplyScalar(.1 ** t), this.noclipCamPos.addScaledVector(this.noclipCamVelocity, t)
            } else this.dead || this.rigidBody.applyForce(n);
            let a = 0,
                l = 0;
            const c = this.rigidBody.velocity,
                d = new h(c.x, c.z);
            if (l = Math.max(0, c.y), a = d.length(), this.rigidBody.inAirTime < 200 && !this.rigidBody.climbingLadder && (this.legsMoveT += a * (e / 1e3) * this.physicsManager.timeScale), this.legsMoveAmount += .005 * e, this.legsMoveAmount = Math.min(this.legsMoveAmount, a), this.legsMoveAmount = ua(this.legsMoveAmount), this.walkHeadBobAmount += 3e-4 * e, this.walkHeadBobAmount = Math.min(this.walkHeadBobAmount, a), this.walkHeadBobAmount = ua(this.walkHeadBobAmount), this.movementAccuracyOffset && (this.movementAccuracyOffset.offset = 10 * l + 2 * a), !this.dead) {
                const t = 1.5;
                if (this.holdingFlag)
                    for (const e of this.game.getMyFlags(this.teamId)) {
                        e.defaultPosition.distanceTo(this.pos) < t && this.sendChangeFlag(this.holdingFlag.id, Wl.FlagChangeOperation.CAPTURE)
                    } else
                    for (const e of this.game.getEnemyFlags(this.teamId)) {
                        if (e.currentHoldingPlayer) continue;
                        e.position.distanceTo(this.pos) < t && this.sendChangeFlag(e.id, Wl.FlagChangeOperation.GRAB)
                    }
                let i = 1 / 0,
                    n = null;
                for (const e of this.game.getMyFlags(this.teamId))
                    if (!e.isNearDefaultPos && !e.currentHoldingPlayer) {
                        const s = e.position.distanceTo(this.pos);
                        s < t && s < i && (i = s, n = e)
                    } if (n) {
                    const t = 1 / ca(5, 60, 300, 1e4, this.game.gameTime / 1e3 / 60, !0);
                    n.addReturnProgress(e * t), this.game.crosshair.setFlagReturnProgress(n.returnProgress), n.returnProgress > 1 && this.sendChangeFlag(n.id, Wl.FlagChangeOperation.RETURN)
                }
                this.game.crosshair.setFlagReturnProgressVisibility(null != n)
            }
            const u = Math.round(e / uc().smoothDt);
            for (let t = 0; t < u; t++) this.positionHistory.unshift(this.pos.clone());
            const p = Math.round(2e3 / uc().smoothDt);
            this.positionHistory.length > p && this.positionHistory.splice(p);
            const m = uc().mapLoader.mapVariablesManager.get("floorDeathHeight");
            "number" == typeof m && this.pos.y < m && this.dieFromFall();
            for (const e of this.recentForcedServerPositions)(t > e.time + 1e4 || e.pos.distanceTo(this.pos) > 10) && this.recentForcedServerPositions.delete(e)
        } else {
            const i = uc().now - this.lastReceivedServerPosTime,
                n = ca(0, 800, 1, 0, i, !0);
            this.predictedServerPos.addScaledVector(this.predictedServerVelocity, e * n);
            const s = this.predictedServerPos.clone().sub(this.serverPos);
            s.clampLength(0, this.maxPredictedServerPosDistance - .01), this.predictedServerPos.copy(this.serverPos).add(s), i < 100 && this.predictedServerVelocity.addScaledVector(this.predictedServerAcceleration, e);
            const r = .02;
            this.predictedServerVelocity.multiplyScalar((1 - r) ** e);
            const o = this.serverPosSmooth.clone();
            this.serverPosSmooth.lerp(this.predictedServerPos, 1 - .8 ** (e / 16.66));
            const a = this.serverPosSmooth.clone().sub(o),
                l = new h(a.x, a.z).length();
            this.rigidBody.inAirTime < 200 && (this.legsMoveT += l), this.legsMoveAmount += .005 * e, this.legsMoveAmount = Math.min(this.legsMoveAmount, 1e3 * l / e), this.legsMoveAmount = ua(this.legsMoveAmount), this.pos.distanceTo(this.serverPos) > this.maxPredictedServerPosDistance ? (this.rigidBody.pos.copy(this.serverPos), this.serverPosSmooth.copy(this.serverPos), this.rigidBody.velocity.set(0, 0, 0)) : (this.rigidBody.pos.x = this.serverPosSmooth.x, this.rigidBody.pos.z = this.serverPosSmooth.z, this.unlockRigidBodyY || (this.rigidBody.pos.y = this.serverPosSmooth.y)), !this.dead && this.hasTouchedFloorEver && !this.prevWasOnFloor && t > this.prevOnFloorTime + 5e3 && t - this.lastReceivedServerPosTime < 500 && t > this.flyAntiCheatCooldownTime && this.report(ih)
        }
        if (this.health < 1 && !this.dead) {
            const i = ua((.3 * ((t - this.lastHitTime) / 1e3 - 4)) ** 5);
            this.hasOwnership && (i > .1 ? this.startHealthRegenSound() : this.stopHealthRegenSound()), this.health += 5e-4 * e * i, this.health = Math.min(1, this.health), this.hasOwnership && this.updateHealthUi()
        }
        const i = this.health < 0;
        if (i != this.prevHealthIsNegative && (this.prevHealthIsNegative = i, i && (this.negativeHealthStartTime = t)), i && !this.dead) {
            t - this.negativeHealthStartTime > 3e3 && this.report(nh)
        }
        this.weapon && this.weapon.loop(t, e);
        const n = Math.floor((this.legsMoveTForCos + Math.PI / 2) / Math.PI);
        if (n > this.lastSfxStep) {
            this.lastSfxStep = n;
            const t = n % 2 == 0 ? "L" : "R";
            let e = .9,
                i = 1.1;
            "female" == this.gender && (e = 1.4, i = 1.8), this.sfxManager.playSound("player/walk" + t, {
                pos: this.getSfxPos(),
                minPitch: e,
                maxPitch: i
            })
        }
        this.activeModel && this.activeModel.setHitFlashMaterialsTime(t), this.loadingModel && this.loadingModel.setHitFlashMaterialsTime(t)
    }
    get legsMoveTForCos() {
        return this.legsMoveT * this.legsMoveSpeed
    }
    afterPhysicsLoop(t, e) {
        if (this.prevWasOnFloor != this.rigidBody.isOnFloor)
            if (this.prevWasOnFloor = this.rigidBody.isOnFloor, this.rigidBody.isOnFloor) {
                t - this.lastAirJumpPressTime < 300 && this.lastAirJumpPressTime >= 0 && (this.lastAirJumpPressTime = -1, this.jump());
                const e = this.highestInAirPoint - this.pos.y,
                    i = ca(.5, 20, 0, this.sfxManager.cachedSfx["player/land"].opts.volume, e, !0);
                i > 0 && (this.sfxManager.playSound("player/land", {
                    volume: i,
                    pos: this.getSfxPos(),
                    minPitch: "female" == this.gender ? 1.1 : .9,
                    maxPitch: "female" == this.gender ? 1.2 : 1
                }), this.lastJumpLandTime = t, this.lastJumpLandAmount = i), this.highestInAirPoint = this.pos.y, this.hasTouchedFloorEver = !0, this.unlockRigidBodyY = !1
            } else this.prevOnFloorTime = t;
        if (this.rigidBody.isOnFloor || (this.highestInAirPoint = Math.max(this.highestInAirPoint, this.pos.y)), this.hasOwnership && (this.rigidBody.inAirTime > 50 ? this.startFallSound() : this.stopFallSound(), !this.hasWalkedAwayFromSpawn && this.game.gameStarted)) {
            this.pos.distanceTo(this.lastRespawnPosition) > 5 && (this.hasWalkedAwayFromSpawn = !0, this.game.weaponSelectionDialog.visible = !1, uc().adBanners.setPageVisibility("respawn", !1))
        }
        if (this.holdingFlag && this.holdingFlag.updateRenderPosition(), !this.dead) {
            if (this.pos.copy(this.rigidBody.pos), this.cachedCamPosDirty = !0, this.activeModel && this.activeModel.isInit && this.obj) {
                this.obj.position.copy(this.pos);
                const i = this.lookRot;
                this.obj.rotation.y = i.x + Math.PI, this.obj.updateWorldMatrix(!1, !0), this.skeleton.isInit && (this.skeleton.loop(t, e), this.activeModel.applySkeleton(this.skeleton))
            }
            const i = this.pos.clone();
            i.y += 2.2, this.icon.setPos(i)
        }
        for (const i of this.holdingHandlers) i.loop(t, e);
        this.hasOwnership && t - this.lastPosSentTime > 50 && (this.pos.distanceTo(this.lastSentPos) < .01 && this.lookRot.distanceTo(this.lastSentRot) < .01 ? (this.noSentDataChangeUpdateCount++, this.noSentDataChangeUpdateCount < 3 && this.sendPlayerDataToServer()) : (this.noSentDataChangeUpdateCount = 0, this.sendPlayerDataToServer()))
    }
    createHoldingHandler(t) {
        const e = new Ul(this, t);
        return this.holdingHandlers.add(e), e
    }
    removeHoldingHandler(t) {
        this.holdingHandlers.delete(t)
    }
    getSfxPos() {
        return this.hasOwnership ? null : this.serverPos.clone()
    }
    async startFallSound() {
        if (this.currentFallingSfx) return;
        if (this.physicsManager.timeScale < .8) return;
        const t = await this.sfxManager.playSound("player/fall");
        this.currentFallingSfx ? t && t.stop() : this.currentFallingSfx = t
    }
    stopFallSound() {
        this.currentFallingSfx && (this.currentFallingSfx.stop(), this.currentFallingSfx = null)
    }
    async startHealthRegenSound() {
        if (this.currentHealthRegenSfx) return;
        const t = await this.sfxManager.playSound("feedback/healthRegen");
        this.currentHealthRegenSfx ? t && t.stop() : this.currentHealthRegenSfx = t
    }
    stopHealthRegenSound() {
        this.currentHealthRegenSfx && (this.currentHealthRegenSfx.stop(), this.currentHealthRegenSfx = null)
    }
    sendPlayerDataToServer() {
        uc().network.sendPlayerData(this.id, {
            posX: this.pos.x,
            posY: this.pos.y,
            posZ: this.pos.z,
            rotX: this.lookRot.x,
            rotY: this.lookRot.y
        }), this.lastPosSentTime = uc().now, this.lastSentPos.copy(this.pos), this.lastSentRot.copy(this.lookRot), this.holdingFlag && this.holdingFlag.sendFlagReturnProgressToServer(this.pos)
    }
    static get PlayerAction() {
        return {
            JUMP: 0,
            FIRE_DOWN: 1,
            FIRE_UP: 2,
            SPAWN: 3,
            DIE: 4
        }
    }
    sendPerformAction(t) {
        this.hasOwnership && uc().network.sendPlayerPerformAction(this.id, t)
    }
    receivedPerformAction(t) {
        this.hasOwnership || (t == oh.PlayerAction.JUMP ? this.onJumpPress() : t == oh.PlayerAction.FIRE_DOWN ? this.onFireDown() : t == oh.PlayerAction.FIRE_UP ? this.onFireUp() : t == oh.PlayerAction.SPAWN ? this.respawnFromServer() : t == oh.PlayerAction.DIE && this.die())
    }
    receiveChangeWeaponFromServer(t) {
        this.hasOwnership || this.setActiveWeapon(t)
    }
    setHasOwnership(t) {
        this.hasOwnership = t, t && (this.didInitRespawn || (this.respawn(), this.didInitRespawn = !0)), this.setHasKeyEvents(t), this.weapon && this.weapon.setHasCursorAccuracyOffset(t), this.setHasMovementAccuracyOffset(t), this.updateModelVisibility(), this.sendAutoShootValue()
    }
    setPlayerName(t) {
        this.playerName = t
    }
    setNamePlayerVerified() {
        this.playerNameVerified = !0
    }
    setTeamId(t) {
        this.teamId != t && (this.teamId = t, this.updateMySelectedWeapon(!0), this.reloadPlayerModel(), this.hasOwnership ? (this.game.updateMyTeamColor(), this.game.updatePlayerIconVisibilities()) : this.updateIconVisibility())
    }
    setIsSameSquadPlayer(t) {
        this.isSameSquadPlayer = t
    }
    setScores({
                  flags: t,
                  kills: e,
                  deaths: i,
                  total: n,
                  skillLevel: s
              }) {
        this.scoreFlags = t, this.scoreKills = e, this.scoreDeaths = i, this.scoreTotal = n, this.scoreSkillLevel = s
    }
    getMatchMakeSkillLevel() {
        let t = 0;
        return t += 10 * this.scoreKills, t += 30 * this.scoreFlags, t
    }
    setHasKeyEvents(t) {
        if (t == this.hasKeyEvents) return;
        const e = uc();
        this.hasKeyEvents = t;
        const i = this.inputManager.getKey("jump"),
            n = this.inputManager.getKey("fire");
        t ? (i.onPressedDown(this.boundOnJumpPress), n.onPressedDown(this.boundOnFireDown), n.onPressedUp(this.boundOnFireUp), this.game.weaponSelectionDialog.onSelectionChange(this.onWeaponSelectionChangeFromDialog), e.settingsManager.onValueChange("smoothCam", (t => {
            this.smoothCamSetting = t, this.updateSmoothCam()
        })), this.smoothCamSetting = e.settingsManager.getValue("smoothCam"), this.updateSmoothCam()) : (i.removeCb(this.boundOnJumpPress), n.removeCb(this.boundOnFireDown), n.removeCb(this.boundOnFireUp), this.game.weaponSelectionDialog.removeOnSelectionChange(this.onWeaponSelectionChangeFromDialog))
    }
    updateSmoothCam() {
        const t = this.smoothCamSetting || this.smoothCamDebug;
        this.smoothCam != t && (this.smoothCam = t, this.smoothCam && this.smoothLookRotTarget.copy(this.lookRot))
    }
    setHasMovementAccuracyOffset(t) {
        t ? this.movementAccuracyOffset || (this.movementAccuracyOffset = this.game.crosshair.createAccuracyOffset()) : this.movementAccuracyOffset && (this.game.crosshair.deleteAccuracyOffset(this.movementAccuracyOffset), this.movementAccuracyOffset = null)
    }
    getStatClassValue(t) {
        if (!this.statClassValues || !this.statClassValues.has(t)) return 0;
        return ua((this.statClassValues.get(t) || 0) / 5)
    }
    reloadPlayerModel() {
        this.setPlayerEquippedSkinData(this.equippedSkinData)
    }
    setPlayerEquippedSkinData(t) {
        this.equippedSkinData = t, this.statClassValues = uc().skins.getStatClassValuesFromShopSkinIds(t.equippedSkinIds || []), this.loadingModel && this.loadingModel.destructor(), this.loadingModel = null, this.loadingModel = new ja({
            skinObjectOpts: {
                teamId: this.teamId,
                skin: t
            }
        }), this.gender = t.gender || "male", this.skeleton.setGender(this.gender), this.weapon && this.weapon.reloadAsset(), this.replaceLoadingModel()
    }
    async replaceLoadingModel() {
        if (!this.loadingModel) return;
        if (await this.loadingModel.waitForInit(), !this.loadingModel) return;
        if (!this.loadingModel.obj) return;
        this.activeModel && this.activeModel.destructor(), this.activeModel = this.loadingModel, this.loadingModel = null, this.obj && uc().scene.remove(this.obj);
        const t = this.activeModel.obj;
        this.obj = t, t && (t.name = "player", uc().scene.add(t));
        for (const t of this.holdingHandlers) t.playerObjectChanged();
        this.updateModelVisibility(), uc().renderer.renderWorthyEventHappened()
    }
    updateModelVisibility() {
        this.obj && (this.obj.visible = !this.dead && this.skeleton.isInit && (!this.hasOwnership || this.thirdPerson || this.noclip), this.updateUseFirstPersonHoldingHandlers())
    }
    updateUseFirstPersonHoldingHandlers() {
        const t = this.hasOwnership && !this.thirdPerson && !this.noclip;
        if (t != this.useFirstPersonHoldingHandlers) {
            this.useFirstPersonHoldingHandlers = t;
            for (const t of this.holdingHandlers) t.useFirstPersonUpdated()
        }
    }
    onJumpPress() {
        this.noclip || this.hasOwnership && uc().mainMenu.visible || (this.rigidBody.getAllowJump() ? this.jump() : this.lastAirJumpPressTime = uc().now)
    }
    jump() {
        if (this.dead) return;
        let t = 1;
        this.weapon && (t = this.weapon.jumpForceMultiplier);
        const e = this.jumpForce * 2; //JUMP HACK
        e > 0 && (this.lastJumpTime = uc().now, this.sendPerformAction(oh.PlayerAction.JUMP), this.sfxManager.playSound(`player/jump/${this.gender}/${pa(1,4)}`, {
            pos: this.getSfxPos()
        }), this.rigidBody.jump(e))
    }
    onFireDown() {
        this.sendPerformAction(oh.PlayerAction.FIRE_DOWN), this.weapon && this.weapon.onFireDown()
    }
    onFireUp() {
        this.sendPerformAction(oh.PlayerAction.FIRE_UP), this.weapon && this.weapon.onFireUp()
    }
    receiveAutoShootValueFromServer(t) {
        this.hasOwnership || this.setAutoShootEnabled(t)
    }
    onAutoShootSettingChange(t) {
        this.hasOwnership && (this.setAutoShootEnabled(t), this.sendAutoShootValue())
    }
    setAutoShootEnabled(t) {
        this.weapon && this.weapon.setAutoShootEnabled(t)
    }
    sendAutoShootValue() {
        this.hasOwnership && uc().network.sendAutoShootValue(this.id, this.settingsManager.getValue("autoShoot"))
    }
    addHitFlash(t) {
        const e = new w;
        0 == t ? e.y = .2 : 1 == t ? e.y = .9 : 2 == t && (e.y = 1.9);
        const i = uc().now;
        this.activeModel && this.activeModel.setHitFlashMaterialsValue(this.nextHitFlashIndex, i, e), this.loadingModel && this.loadingModel.setHitFlashMaterialsValue(this.nextHitFlashIndex, i, e), this.nextHitFlashIndex++, this.nextHitFlashIndex >= 5 && (this.nextHitFlashIndex = 0)
    }
    onArrowHitFromServer(t, e, i) {
        const n = this.rigidBody.colliders[i];
        if (n) {
            const i = this.game.arrowManager.getArrowById(t.id, e);
            if (!i) return;
            const s = 3;
            let r = !1;
            if (i.prevPos) {
                let t = 1 / 0;
                for (const e of i.travelledPositions) {
                    const i = e.distanceTo(n.center);
                    t = Math.min(t, i)
                }
                t < s && (r = !0)
            }
            if (this.onValidArrowHitFromServer(t, i, n), !r) {
                let e = !1;
                i.onTravel((t => {
                    if (e) return;
                    t.distanceTo(n.center) < s && (e = !0)
                })), setTimeout((() => {
                    e || t.report(sh)
                }), 1e3)
            }
        }
        this.hasOwnership || (t.hasOwnership ? this.lastShotByOwnerTime = uc().now : this.addHitFlash(i), this.sfxManager.playSound(`player/takeDamage/${this.gender}/${pa(1,4)}`, {
            pos: this.getSfxPos()
        }))
    }
    onValidArrowHitFromServer(t, e, i) {
        let n = i.arrowDamage;
        e && (n *= e.damageMultiplier), n *= la(1.1, .9, this.getStatClassValue("armorStrength"));
        const s = performance.now();
        for (let t = this.damageReceivedHistory.length - 1; t >= 0; t--) {
            if (!(s - this.damageReceivedHistory[t].time > 1e3)) break;
            this.damageReceivedHistory.splice(t, 1)
        }
        let r = 0;
        for (const t of this.damageReceivedHistory) r += t.damage;
        const o = n + r;
        n -= o - Math.min(o, .9);
        const a = {
            damage: a, //Immortality
            time: s,
            appliedDamage: 0
        };
        if (this.damageReceivedHistory.unshift(a), n > .001) {
            a.appliedDamage = n, this.game.gameStarted && (this.health -= n);
            let t = null;
            e && (t = e.lookDirection), this.lastHitTime = uc().now, this.hasOwnership && (uc().screenFlash.flash(t, n), this.sfxManager.playSound(`player/takeDamage/${this.gender}/${pa(1,4)}`), this.updateHealthUi(), this.health < .05 && this.die())
        }
    }
    getCamPos() {
        if (this.cachedCamPosDirty) {
            if (this.cachedCamPos.copy(this.pos), this.cachedCamPos.y += 1.6, this.noclip && this.noclipCamPos) this.cachedCamPos.add(this.noclipCamPos);
            else if (this.thirdPerson) {
                const t = new w(0, 0, 5);
                t.applyQuaternion(this.getCamRot()), this.cachedCamPos.add(t)
            }
            if (this.settingsManager.getValue("walkHeadBob")) {
                const t = this.getCamRot(),
                    e = new w(0, 1, 0);
                e.applyQuaternion(t), e.multiplyScalar(.1 * Math.sin(this.legsMoveTForCos - .9) * this.walkHeadBobAmount), this.cachedCamPos.add(e);
                const i = new w(1, 0, 0);
                i.applyQuaternion(t), i.multiplyScalar(.05 * Math.cos(this.legsMoveTForCos / 2) * this.walkHeadBobAmount), this.cachedCamPos.add(i)
            }
            this.cachedCamPosDirty = !1
        }
        return this.cachedCamPos.clone()
    }
    getCamRot() {
        if (this.cachedCamRotDirty) {
            const t = .01 * (this.lastJumpLandTime - uc().now);
            let e = 0;
            this.settingsManager.getValue("landHeadBob") && this.lastJumpLandAmount > .005 && (e = ca(.012, .1, .1, .3, this.lastJumpLandAmount));
            const i = t / (.5 + t ** 2) * e,
                n = new ot(this.lookRot.y + i, this.lookRot.x, 0, "YXZ");
            this.cachedCamRot.setFromEuler(n), this.cachedCamRotDirty = !1
        }
        return this.cachedCamRot.clone()
    }
    getClampedCamRot() {
        const t = da(this.lookRot.y, -Math.PI / 2, Math.PI / 2),
            e = new ot(t, this.lookRot.x, 0, "YXZ"),
            i = new v;
        return i.setFromEuler(e), i
    }
    getLookDirection() {
        const t = new w(0, 0, -1);
        return t.applyQuaternion(this.getCamRot()), t
    }
    setServerData(t, e, i, n, s, r = !1) {
        const o = this.serverPos.clone();
        this.serverPos.set(t, e, i), this.predictedServerVelocity.copy(this.serverPos), this.predictedServerVelocity.sub(o);
        const a = uc().now - this.lastReceivedServerPosTime;
        if (this.lastReceivedServerPosTime = uc().now, a > 100 && (this.flyAntiCheatCooldownTime = uc().now + 1e3), a <= 0 || this.predictedServerVelocity.length() > 5 ? (this.predictedServerVelocity.set(0, 0, 0), this.predictedServerAcceleration.set(0, 0, 0)) : (this.predictedServerVelocity.divideScalar(a), this.predictedServerAcceleration.copy(this.predictedServerVelocity), this.predictedServerAcceleration.sub(this.lastPredictedServerVelocity), this.predictedServerAcceleration.divideScalar(a)), this.hasOwnership && r) {
            let t = !1;
            for (const e of this.recentForcedServerPositions)
                if (this.serverPos.distanceTo(e.pos) < .1) {
                    t = !0;
                    break
                } t || (this.recentForcedServerPositions.add({
                pos: this.serverPos.clone(),
                time: uc().now
            }), this.setPosition(this.serverPos))
        }
        this.predictedServerPos.set(t, e, i), this.lastPredictedServerVelocity.copy(this.predictedServerVelocity), this.hasOwnership || this.lookRot.set(n, s);
        const l = e > o.y;
        l != this.networkPosIsMovingUp && (this.networkPosIsMovingUp = l, !this.rigidBody.isOnFloor && l && (this.unlockRigidBodyY = !0))
    }
    setPingData(t) {
        this.ping = t
    }
    getDeltaPositionMsAgo(t) {
        if (this.positionHistory.length <= 0) return this.pos.clone();
        const e = da(Math.round(t / uc().smoothDt), 0, this.positionHistory.length - 1),
            i = this.positionHistory[e];
        return this.pos.clone().sub(i)
    }
    updateIconVisibility(t = this.game.getMyTeamId()) {
        let e = !this.hasOwnership;
        t != this.teamId && (e = !1), this.icon.setVisibility(e)
    }
    dieFromFall() {
        this.hasOwnership && (this.holdingFlag && this.sendChangeFlag(this.holdingFlag.id, Wl.FlagChangeOperation.RETURN, !1), this.die())
    }
    die() {
        this.dead || (this.hasOwnership && (this.sfxManager.playSound("feedback/die"), this.game.showKilledNotification(), this.game.weaponSelectionDialog.visible = !0, this.game.gameStarted && uc().adBanners.setPageVisibility("respawn", !0)), this.sendPerformAction(oh.PlayerAction.DIE), this.dead = !0, this.updateMySelectedWeapon(), this.stopFallSound(), this.updateModelVisibility(), uc().now - this.lastShotByOwnerTime < 1e3 && (this.game.showKillNotification(), this.sfxManager.playSound("feedback/kill")), this.hasOwnership && setTimeout((() => {
            this.destructed || this.respawn()
        }), 1e3))
    }
    respawn() {
        if (!this.hasOwnership) return;
        const {
            pos: t,
            rot: e
        } = this.game.getSpawnPosition(this.teamId), i = new w(0, 0, 1);
        i.applyQuaternion(e), i.y = 0;
        const n = new w(0, 0, 1);
        let s = i.angleTo(n);
        n.cross(i).y < 0 && (s *= -1), this.dead = !1, this.sendPerformAction(oh.PlayerAction.SPAWN), this.setPosition(t), this.hasWalkedAwayFromSpawn = !1, this.lastRespawnPosition.copy(t), this.game.weaponSelectionDialog.visible = !0, this.updateMySelectedWeapon(), this.lookRot.set(s, 0), uc().cam.playerRespawned(), this.sfxManager.playSound("player/spawn"), this.health = 1, this.updateHealthUi(), this.sendPlayerDataToServer(), this.sendMyEquippedSkinData()
    }
    respawnFromServer() {
        this.dead = !1, this.health = 1, this.updateModelVisibility(), this.sfxManager.playSound("player/spawn", {
            pos: this.getSfxPos()
        })
    }
    updateHealthUi() {
        this.game.healthUi.setHealth(this.health)
    }
    setPosition(t) {
        this.pos.copy(t), this.rigidBody.pos.copy(t), this.rigidBody.velocity.set(0, 0, 0), this.cachedCamPosDirty = !0
    }
    sendChangeFlag(t, e, i = !0) {
        if (!this.game.gameEnded && this.game.gameStarted) {
            if (i) {
                for (const [i, n] of this.sentChangeFlagMessages.entries()) {
                    if (uc().now - n.sendTime > 3e3) {
                        this.sentChangeFlagMessages.splice(i);
                        break
                    }
                    if (n.flagId == t && n.changeOperation == e) return
                }
                this.sentChangeFlagMessages.unshift({
                    flagId: t,
                    changeOperation: e,
                    sendTime: uc().now
                })
            }
            uc().network.sendChangeFlag(this.id, t, e)
        }
    }
    changeFlagFromServer(t, e) {
        e == Wl.FlagChangeOperation.GRAB ? (this.holdingFlag = t, t.startHoldByPlayer(this), this.sfxManager.playSound("flag/grab", {
            pos: this.pos
        })) : e == Wl.FlagChangeOperation.CAPTURE ? (this.holdingFlag = null, t.returnToDefaultPos()) : e == Wl.FlagChangeOperation.DROP ? (this.holdingFlag = null, t.removeCurrentHoldingPlayer(), this.sfxManager.playSound("flag/drop", {
            pos: this.pos
        })) : e == Wl.FlagChangeOperation.RETURN && (this.holdingFlag == t && (this.holdingFlag = null), t.returnToDefaultPos()), this.removeChangeFlagFromQueue(t.id, e)
    }
    stopHoldingFlag(t) {
        this.holdingFlag == t && (this.holdingFlag = null)
    }
    removeChangeFlagFromQueue(t, e) {
        for (let i = this.sentChangeFlagMessages.length - 1; i >= 0; i--) {
            const n = this.sentChangeFlagMessages[i];
            if (n.flagId == t && n.changeOperation == e) return void this.sentChangeFlagMessages.splice(i, 1)
        }
    }
    report(t) {
        this.hasOwnership || this.game.gameEnded || uc().now < this.creationTime + 15e3 || this.game.antiCheat.reportPlayer(this.id, t)
    }
}
const ah = new w(0, -20, 0);
class lh extends th {
    constructor(t) {
        super(), this.flag = t, this.pos = new w, this.velocity = new w, this.isOnFloor = !1, this.radius = .5;
        const e = this.radius;
        this.aabb = new S(new w(-e, -e, -e), new w(e, e, e))
    }
    stepVelocity(t) {
        this.velocity.addScaledVector(ah, t);
        const e = this.isOnFloor ? 1 : .8,
            i = Math.pow(1 - e, t);
        this.velocity.multiplyScalar(i), this.pos.addScaledVector(this.velocity, t)
    }
    resolveMapCollisionsOctree(t) {
        this.isOnFloor = !1;
        const e = this.getManifolds();
        for (const {
            manifold: t,
            mapCollider: i
        }
            of e) {
            const e = this.velocity.dot(t.normal);
            if (e < 0) {
                i.isDeathTrigger && this.flag.returnToDefaultPosFromFall(), this.velocity.addScaledVector(t.normal, -e);
                t.normal.dot(new w(0, 1, 0)) > .7 && (this.isOnFloor = !0);
                const n = .8,
                    s = .001,
                    r = Math.max(t.penetration - s, 0) * n,
                    o = t.normal.clone().multiplyScalar(r);
                this.pos.add(o)
            }
        }
    }
    getColliderAabb() {
        const t = this.aabb.clone();
        return t.translate(this.pos), t
    }
    getManifolds() {
        const t = [],
            e = this.getColliderAabb();
        for (const i of uc().physics.getCollidersForAabbUsingOctree(e)) {
            if (!i.aabb) continue;
            if (!i.aabb.intersectsBox(e)) continue;
            const n = i.getSphereManifold(this.pos, this.radius);
            n.penetration > 0 && t.push({
                manifold: n,
                mapCollider: i
            })
        }
        return t
    }
}
class hh {
    constructor(t, e, i, n, s) {
        this.id = t, this.teamId = e, this.defaultPosition = i, this.defaultRotation = n, this.position = i.clone(), this.physicsManager = s, this.isOnDefaultPos = !0, this.rigidBody = new lh(this), this.rigidBody.enabled = !1, s.registerRigidBody(this.rigidBody), this.obj = new xt, this.obj.name = "flag", this.obj.position.copy(i), this.obj.quaternion.copy(n), uc().scene.add(this.obj), this.grabAnimationContainer = new xt, this.grabAnimationContainer.name = "flagGrabAnimationContainer", this.obj.add(this.grabAnimationContainer), this.obj.updateWorldMatrix(!1, !0), this.grabStartTime = 0, this.returnProgress = 0, this.currentHoldingPlayer = null, this.prevIsBeingHeld = !1, this.holdingHandler = null, this.icon = uc().hudIcons.createIcon({
            url: `img/hudIcons/flag${Ka[e].nameCapitalized}.svg`
        }), this.initModel(), this.destructed = !1
    }
    destructor() {
        this.destructed = !0, this.icon.destructor(), this.removeCurrentHoldingPlayer(), this.destroyHoldingHandler(), this.obj.parent == uc().scene && uc().scene.remove(this.obj), this.physicsManager.removeRigidBody(this.rigidBody)
    }
    async initModel() {
        const t = await uc().assets.loadGlbViaWorker("flag.glb", {
            teamId: this.teamId
        });
        this.destructed || (t && this.grabAnimationContainer.add(t), this.updateRenderState())
    }
    updateRenderState() {
        const t = !!this.currentHoldingPlayer;
        t ? this.holdingHandler && this.holdingHandler.player == this.currentHoldingPlayer || (this.destroyHoldingHandler(), this.currentHoldingPlayer && (this.holdingHandler = this.currentHoldingPlayer.createHoldingHandler({
            holdingObject: this.obj,
            thirdPersonParentName: "flagHoldingPos",
            firstPersonConfig: {
                posOffset: new w(.4, -1.4, -1.03),
                rotOffset: new w(-.2, -.1, .4),
                posBaseFovMultiplierX: -.93
            }
        })), this.icon.setVisibility(!this.currentHoldingPlayer || !this.currentHoldingPlayer.hasOwnership)) : t != this.prevIsBeingHeld && (this.destroyHoldingHandler(), this.icon.setVisibility(!0)), this.prevIsBeingHeld = t, this.updateRenderPosition()
    }
    updateRenderPosition() {
        let t;
        this.currentHoldingPlayer ? t = this.currentHoldingPlayer.pos.clone() : (this.obj.position.copy(this.position), this.obj.quaternion.copy(this.defaultRotation), t = this.position.clone()), t.y += 2.7, this.icon.setPos(t), this.obj.updateWorldMatrix(!1, !0)
    }
    loop(t, e) {
        const i = (t - this.grabStartTime) / 1e3,
            n = ca(0, .8, 2 * Math.PI * 2, 0, i, !0);
        this.grabAnimationContainer.rotation.y = 1 / (10 * i + 1) * n;
        const s = 1 / (1 + Math.pow(Math.E, -50 * (i - .7)));
        this.grabAnimationContainer.position.y = .3 * (1 - s)
    }
    afterPhysicsLoop(t, e) {
        if (!this.currentHoldingPlayer && !this.isOnDefaultPos) {
            this.position.copy(this.rigidBody.pos), this.position.y -= this.rigidBody.radius, this.updateRenderPosition();
            const t = uc().mapLoader.mapVariablesManager.get("floorDeathHeight");
            "number" == typeof t && this.position.y < t && this.returnToDefaultPosFromFall()
        }
    }
    startHoldByPlayer(t) {
        t != this.currentHoldingPlayer && (this.removeCurrentHoldingPlayer(), this.currentHoldingPlayer = t, this.grabStartTime = uc().now, this.updateRenderState())
    }
    destroyHoldingHandler() {
        this.holdingHandler && (this.holdingHandler.destructor(), this.holdingHandler = null, uc().scene.add(this.obj))
    }
    returnToDefaultPos() {
        this.isOnDefaultPos = !0, this.rigidBody.enabled = !1, this.removeCurrentHoldingPlayer(), this.position.copy(this.defaultPosition), this.updateRenderState()
    }
    returnToDefaultPosFromFall() {
        this.currentHoldingPlayer || this.isOnDefaultPos || this.returnToDefaultPos()
    }
    removeCurrentHoldingPlayer() {
        this.currentHoldingPlayer && this.currentHoldingPlayer.stopHoldingFlag(this), this.currentHoldingPlayer = null
    }
    setDroppedPosition(t, e, i, n, s, r) {
        this.isOnDefaultPos = !1, this.currentHoldingPlayer || (this.position.set(t, e + this.rigidBody.radius, i), this.rigidBody.pos.copy(this.position), this.rigidBody.velocity.set(n, s, r), this.rigidBody.enabled = !0, this.returnProgress = 0, this.updateRenderState())
    }
    get isNearDefaultPos() {
        return this.position.distanceTo(this.defaultPosition) < 1
    }
    sendFlagReturnProgressToServer(t) {
        let e = 1 / 0;
        const i = uc().gameManager.currentGame;
        if (i) {
            for (const n of i.getMyFlags()) {
                const i = 1 - t.distanceTo(n.position) / n.defaultPosition.distanceTo(this.defaultPosition);
                i < e && (e = i)
            }
            uc().network.sendFlagReturnProgress(this.id, e)
        }
    }
    addReturnProgress(t) {
        this.returnProgress += t
    }
}
class ch {
    constructor(t, {
        arrowId: e,
        pos: i,
        networkOffsetPos: n,
        dir: s,
        fireAmount01: r
    }, {
                    arrowManager: o,
                    scene: a
                }) {
        this.shotBy = t, this.arrowId = e, this.startPos = i, this.arrowManager = o, this.scene = a, this.networkOffsetPos = n, this.networkStartPos = i.clone().add(n), this.dir = s, this.arrowWeaponOpts = {
            visualOffset: new w,
            scale: new w(1, 1, 1),
            damageMultiplier: 1,
            travelDistanceMultiplier: 1,
            trailThicknessMultiplier: 1,
            trailDurationMultiplier: 1
        }, this.playerDamageMultiplier = la(.8, 1.2, t.getStatClassValue("bowAttackStrength")), t.weapon && (t.weapon.playShootSound(i), this.arrowWeaponOpts = {
            ...this.arrowWeaponOpts,
            ...t.weapon.getArrowOpts(r)
        }), this.strength = la(10, 500 * this.arrowWeaponOpts.travelDistanceMultiplier, r), this.dir.setLength(this.strength), this.existingTime = 0;
        const l = this.getParabolaExtremePoint();
        this.parabolaXDist = 2 * l.x;
        const h = this.parabolaXDist + 2 * l.y;
        this.xSpeed = 0 == h ? 1 : Math.abs(this.parabolaXDist / h), this.xSpeed *= ca(100, 500, .05, .15, this.strength), this.visualStartPos = this.getParabolaPoint3d(0), this.obj = new xt, this.obj.name = "Arrow container " + this.arrowId, this.obj.position.copy(this.networkStartPos), this.obj.scale.copy(this.arrowWeaponOpts.scale), this.scene.add(this.obj), this.prevPos = null, this.prevRaycastPos = null, this.cachedRays = [], this.travelledPositions = [], this.onTravelCbs = new Set, this.lookDirection = new w, this.sphere = null, this.trailObj = null, this.trailGeo = null, this.trailMat = null, this.didHitWorld = !1, this.didHitPlayer = !1, this.worldHitTime = 0, this.worldHitRot = null, this.worldHitTangent = null, this.worldHitLastRayDistance = 0, this.destructed = !1
    }
    destructor() {
        this.destructed = !0, this.scene.remove(this.obj), this.trailObj && this.scene.remove(this.trailObj), this.trailGeo && this.trailGeo.dispose(), this.trailMat && this.trailMat.dispose()
    }
    get damageMultiplier() {
        return this.arrowWeaponOpts.damageMultiplier * this.playerDamageMultiplier
    }
    async initModel() {
        const t = await uc().arrowAssetCache.getArrowAssetWithCache(this.shotBy.teamId);
        if (this.destructed) return;
        this.obj.add(t.clone());
        const e = this.arrowManager.getSphereGeo(this.shotBy.teamId);
        this.sphere = new _e(e, uc().materials.basicUnlitMat), this.sphere.name = "Arrow sphere", this.sphere.position.z = -1, this.obj.add(this.sphere)
    }
    initTrail() {
        const t = .005 * this.arrowWeaponOpts.trailThicknessMultiplier,
            e = 30,
            i = [];
        for (let e = 0; e < 3; e++) {
            const n = e / 3 * Math.PI * 2,
                s = Math.cos(n) * t,
                r = Math.sin(n) * t;
            i.push(new w(s, r, 0))
        }
        const n = this.getMaxDistanceT(-15),
            s = new Float32Array(270),
            r = new Float32Array(90),
            o = new Float32Array(270),
            a = [];
        let l = 0,
            h = new w;
        for (let t = 0; t < e; t++) {
            const c = Math.pow(t / e, 2) * n,
                d = this.getParabolaPoint3d(c, !0);
            let u = null;
            if (t > 0) u = h.sub(d);
            else {
                u = this.getParabolaPoint3d(-1e-4, !0).sub(d)
            }
            h = d;
            const p = new $;
            p.lookAt(new w, u, new w(0, 1, 0));
            const m = new v;
            m.setFromRotationMatrix(p);
            for (let t = 0; t < 3; t++) {
                const e = i[t].clone();
                e.applyQuaternion(m);
                const n = e.clone();
                s[3 * l + 0] = d.x, s[3 * l + 1] = d.y, s[3 * l + 2] = d.z, o[3 * l + 0] = n.x, o[3 * l + 1] = n.y, o[3 * l + 2] = n.z, r[l] = c, l++
            }
            if (t < 29) {
                const e = 3 * t,
                    i = e + 3;
                for (let t = 0; t < 3; t++) {
                    const n = (t + 1) % 3;
                    a.push(e + t, e + n, i + t), a.push(e + n, i + n, i + t)
                }
            }
        }
        const c = new ae;
        c.setAttribute("position", new Xt(s, 3)), c.setAttribute("arrowT", new Xt(r, 1)), c.setAttribute("normal", new Xt(o, 3)), c.setIndex(a), this.trailGeo = c;
        const d = uc().materials.arrowTrailMat;
        if (!d) throw new Error("Couldn't find arrow trail material.");
        this.trailMat = d.clone(), this.trailMat.uniforms.shootStartPos.value.copy(this.visualStartPos);
        const u = .1 * this.strength,
            p = Math.max(u, Math.abs(this.parabolaXDist)) * this.arrowWeaponOpts.trailDurationMultiplier;
        this.trailMat.uniforms.estimatedXLength.value = p, this.trailObj = new _e(c, this.trailMat), this.trailObj.name = "Arrow trail " + this.arrowId, this.scene.add(this.trailObj)
    }
    loop(t, e) {
        if (!this.didHitWorld && !this.didHitPlayer) {
            const e = this.existingTime * this.xSpeed,
                i = this.getParabolaPoint3d(e),
                n = this.getParabolaPoint3d(e, !1, !1);
            this.prevRaycastPos && this.prevPos || (this.prevRaycastPos = this.getParabolaPoint3d(e - .001, !1, !1), this.prevPos = this.getParabolaPoint3d(e - .001)), this.travelledPositions.push(i), this.onTravelCbs.forEach((t => t(i))), this.lookDirection.copy(i), this.lookDirection.sub(this.prevPos), this.lookDirection.setLength(1), this.trailMat && (this.trailMat.uniforms.arrowPosT.value = e), 0 == this.lookDirection.length() && this.lookDirection.set(0, 1, 0);
            const s = this.getNearbyStartAmount(i),
                r = this.lookDirection.clone().multiplyScalar(s),
                o = i.clone().add(r),
                a = uc().physics.getRayCastCache(t, this.prevRaycastPos, n);
            if (a) {
                this.cachedRays.push(a);
                const e = uc().physics.rayCastMapColliders(a, (t => !t.collider.ignoreArrows && t.collider.excludeTeamId != this.shotBy.teamId));
                e && (-1 != e.collider.excludeTeamId && (this.obj.visible = !1), this.didHitWorld = !0, this.worldHitTime = t, this.worldHitLastRayDistance = e.dist, this.obj.position.copy(e.pos), this.obj.position.addScaledVector(this.lookDirection, .15), this.worldHitRot = this.obj.quaternion.clone(), this.worldHitTangent = this.lookDirection.clone().cross(new w(0, 1, 0)), this.worldHitTangent.normalize(), uc().sfx.playSound("weapon/bow/environmentImpact/" + pa(1, 4), {
                    pos: e.pos
                }))
            }
            this.prevPos.copy(i), this.prevRaycastPos.copy(n), this.obj.quaternion.setFromUnitVectors(new w(0, 0, 1), this.lookDirection), this.didHitWorld || this.obj.position.copy(o)
        }
        if (!this.didHitPlayer) {
            let e = 0;
            for (const [i, n] of this.cachedRays.entries()) t - n.createTime > 200 && (e = i + 1);
            this.cachedRays.splice(0, e);
            for (const [t, e] of this.cachedRays.entries()) {
                const i = uc().physics.rayCastPlayerColliders(e, (t => !t.collider.rigidBody.player.dead && t.collider.rigidBody.player.teamId != this.shotBy.teamId));
                if (i) {
                    let e = !1;
                    if (this.didHitWorld) {
                        t == this.cachedRays.length - 1 && i.dist > this.worldHitLastRayDistance && (e = !0)
                    }
                    if (!e) {
                        const t = i.collider.rigidBody.player;
                        if (this.didHitPlayer = !0, this.shotBy.hasOwnership) {
                            const e = i.collider.rigidBody.colliders.indexOf(i.collider);
                            t.addHitFlash(e), uc().sfx.playSound("feedback/hitPlayer");
                            "head" == i.collider.bodyPart && uc().sfx.playSound("feedback/headShot"), uc().network.sendHitByArrow(t.id, this.shotBy.id, this.arrowId, e)
                        }
                        this.obj.visible = !1
                    }
                }
            }
        }
        if (this.trailMat && (this.trailMat.uniforms.arrowShootT.value = this.existingTime * this.xSpeed), this.existingTime += uc().physics.timeScale * e, this.sphere) {
            const e = uc().cam.pos.distanceTo(this.obj.position);
            let i = 1;
            if (this.didHitWorld) {
                const n = ca(15, 30, 4, 2, e, !0);
                i *= ca(0, 100, n, 1, t - this.worldHitTime, !0)
            }
            this.sphere.scale.setScalar(.002 * e * i), this.sphere.updateWorldMatrix(!1, !0)
        }
        if (this.didHitWorld && this.worldHitRot && this.worldHitTangent) {
            const e = t - this.worldHitTime,
                i = 100,
                n = Math.cos(.08 * e) * (i / (e + i)),
                s = new v;
            s.setFromAxisAngle(this.worldHitTangent, .03 * n), this.obj.quaternion.copy(this.worldHitRot), this.obj.quaternion.premultiply(s)
        }
        this.didHitPlayer || this.obj.updateWorldMatrix(!1, !0)
    }
    onTravel(t) {
        this.onTravelCbs.add(t)
    }
    getParabolaPoint3d(t, e = !1, i = !0) {
        const {
            newDir: n,
            inverseSpaceRotation: s
        } = this.map3dDirTo2d(this.dir), r = this.getParabolaPoint2d(n.x, n.y, t);
        e && 0 == n.x && (r.x = 0);
        const o = new w(r.x, r.y, 0);
        o.applyQuaternion(s), o.add(this.startPos);
        const a = this.getNearbyStartAmount(o);
        if (i) {
            const t = this.arrowWeaponOpts.visualOffset.clone();
            t.multiplyScalar(a), t.applyQuaternion(s), o.add(t)
        }
        const l = this.networkOffsetPos.clone().multiplyScalar(1 - a);
        return o.add(l), o
    }
    getNearbyStartAmount(t) {
        return 3 / (t.distanceTo(this.startPos) + 3)
    }
    map3dDirTo2d(t) {
        let e = new w(t.x, 0, t.z).angleTo(new w(1, 0, 0));
        t.z < 0 && (e = 2 * Math.PI - e);
        const i = new v;
        i.setFromAxisAngle(new w(0, 1, 0), e);
        const n = i.clone().invert();
        return {
            newDir: t.clone().applyQuaternion(i),
            spaceRotation: i,
            inverseSpaceRotation: n
        }
    }
    getParabolaPoint2d(t, e, i) {
        const n = this.sCurve(e / t);
        let s = 0;
        return 0 == n ? s = -Math.pow(i, 2) * (1 / t) : 0 == t ? s = (1 - Math.pow(2 * (i / n - .5), 2)) * e * .5 : (s = (1 - Math.pow((i / n - t) / t, 2)) * e * .5, s *= n), new h(i, s)
    }
    sCurve(t, e = Math.E) {
        let i = 1 / (1 + Math.pow(e, -t));
        return i -= .5, i *= 2, i
    }
    getParabolaExtremePoint() {
        const {
            newDir: t
        } = this.map3dDirTo2d(this.dir), e = t.y / t.x;
        let i = null;
        return i = 0 == t.x ? .5 : Math.cos(Math.atan(e)) * this.sCurve(e) * this.strength, this.getParabolaPoint2d(t.x, t.y, i)
    }
    getMaxDistanceT(t) {
        const {
            newDir: e
        } = this.map3dDirTo2d(this.dir);
        if (0 == e.x) return 1;
        const i = t - this.networkStartPos.y,
            n = this.sCurve(e.y / e.x),
            s = e.x,
            r = e.y;
        if (0 == n) return Math.sqrt(-i * s);
        const o = s * r * n,
            a = Math.pow(s, 2) * r * n * (r * n - 2 * i);
        if (a < 0) return 0;
        const l = Math.sqrt(a),
            h = (o - l) / r,
            c = (o + l) / r;
        return Math.max(h, c)
    }
}

function dh(t, e, i) {
    t = ua(t), e = ua(e), i = ua(i);
    const n = Math.max(t, e, i),
        s = Math.min(t, e, i),
        r = n - s;
    let o, a, l;
    switch (o = 0, a = 0 == n ? 0 : r / n, l = n, n) {
        case s:
            o = 0;
            break;
        case t:
            o = e - i + r * (e < i ? 6 : 0), o /= 6 * r;
            break;
        case e:
            o = i - t + 2 * r, o /= 6 * r;
            break;
        case i:
            o = t - e + 4 * r, o /= 6 * r
    }
    return [o, a, l]
}

function uh(t, e, i) {
    t = aa(t, 1), e = ua(e), i = ua(i);
    const n = Math.floor(6 * t),
        s = 6 * t - n,
        r = i * (1 - e),
        o = i * (1 - s * e),
        a = i * (1 - (1 - s) * e);
    let l = 0,
        h = 0,
        c = 0;
    switch (n % 6) {
        case 0:
            l = i, h = a, c = r;
            break;
        case 1:
            l = o, h = i, c = r;
            break;
        case 2:
            l = r, h = i, c = a;
            break;
        case 3:
            l = r, h = o, c = i;
            break;
        case 4:
            l = a, h = r, c = i;
            break;
        case 5:
            l = i, h = r, c = o
    }
    return [l, h, c]
}
class ph {
    constructor(t) {
        this.teamCount = t, this.arrows = new Map, this.oldPlayerArrows = new Set, this.sphereGeos = [];
        for (let e = 0; e < t; e++) {
            const t = new _r,
                i = t.getAttribute("position"),
                n = new Float32Array(3 * i.count);
            let s = 1,
                r = 0,
                o = 0;
            const a = Ka[e].colorTransform;
            if (a) {
                const [t, e, i] = dh(s, r, o), n = {
                    h: t,
                    s: e,
                    v: i
                };
                a(n), [s, r, o] = uh(n.h, n.s, n.v)
            }
            const l = [s, r, o];
            for (let t = 0; t < n.byteLength; t += 3)
                for (let e = 0; e < l.length; e++) n[t + e] = .3 * l[e];
            t.setAttribute("color", new Xt(n, 3)), this.sphereGeos.push(t)
        }
        this.destructed = !1
    }
    destructor() {
        this.destructed = !0;
        for (const t of this.arrows.values())
            for (const e of t.values()) e.destructor();
        this.arrows.clear();
        for (const t of this.sphereGeos) t.dispose()
    }
    getSphereGeo(t) {
        return this.sphereGeos[t]
    }
    loop(t, e) {
        for (const [i, n] of this.arrows) {
            for (const [i, s] of n) s.loop(t, e), s.existingTime > 5e3 && (s.destructor(), n.delete(i));
            n.size <= 0 && this.arrows.delete(i)
        }
        for (const i of this.oldPlayerArrows) i.loop(t, e), i.existingTime > 5e3 && (i.destructor(), this.oldPlayerArrows.delete(i))
    }
    createArrow(t, e) {
        const i = new ch(t, e, {
            arrowManager: this,
            scene: uc().scene
        });
        i.initModel(), i.initTrail();
        const n = i.arrowId,
            s = i.shotBy.id;
        let r = this.arrows.get(s);
        r || (r = new Map, this.arrows.set(s, r));
        const o = r.get(n);
        o && this.oldPlayerArrows.add(o), r.set(n, i), uc().renderer.renderWorthyEventHappened()
    }
    getArrowById(t, e) {
        const i = this.arrows.get(t);
        return i && i.get(e) || null
    }
}
class mh {
    constructor(t) {
        this.crosshair = t, this._offset = 0
    }
    get offset() {
        return this._offset
    }
    set offset(t) {
        this._offset = t, this.crosshair.updateAccuracyOffset()
    }
}
class gh {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("crosshairContainer"), document.body.appendChild(this.el), this.lines = [];
        for (let t = 30; t < 360; t += 120) {
            const e = document.createElement("div");
            e.classList.add("crosshairLine"), this.el.appendChild(e), this.lines.push({
                rotation: t,
                el: e
            })
        }
        const t = "http://www.w3.org/2000/svg";
        this.flagReturnProgressSvg = document.createElementNS(t, "svg"), this.flagReturnProgressSvg.classList.add("flagReturnProgressContainer"), this.flagReturnProgressSvg.setAttribute("width", String(50)), this.flagReturnProgressSvg.setAttribute("height", String(50)), this.el.appendChild(this.flagReturnProgressSvg), this.flagReturnProgressPath1 = document.createElementNS(t, "path"), this.flagReturnProgressPath2 = document.createElementNS(t, "path"), this.flagReturnProgressPath1.classList.add("flagReturnProgressPath"), this.flagReturnProgressPath2.classList.add("flagReturnProgressPath"), this.flagReturnProgressPath1.style.stroke = "black", this.flagReturnProgressPath1.style.strokeWidth = "10px", this.flagReturnProgressPath2.style.stroke = "white", this.flagReturnProgressPath2.style.strokeWidth = "6px", this.flagReturnProgressSvg.appendChild(this.flagReturnProgressPath1), this.flagReturnProgressSvg.appendChild(this.flagReturnProgressPath2), this.accuracyOffsets = new Set, this.currentAccuracy = 0, this.smoothAccuracy = 0, this.flagReturnAccuracyOffset = this.createAccuracyOffset(), this.setFlagReturnProgressVisibility(!1)
    }
    destructor() {
        document.body.removeChild(this.el)
    }
    loop(t, e) {
        this.smoothAccuracy = la(this.smoothAccuracy, this.currentAccuracy, .5);
        const i = 7 + this.smoothAccuracy;
        for (const t of this.lines) t.el.style.transform = `translateY(-3px) rotate(${t.rotation}deg) translateX(${i}px)`
    }
    createAccuracyOffset() {
        const t = new mh(this);
        return this.accuracyOffsets.add(t), t
    }
    deleteAccuracyOffset(t) {
        this.accuracyOffsets.delete(t), this.updateAccuracyOffset()
    }
    updateAccuracyOffset() {
        let t = 0;
        for (const e of this.accuracyOffsets) t += e.offset;
        this.currentAccuracy = t
    }
    setFlagReturnProgress(t) {
        const e = 15,
            i = 2 * (t = da(t, 1e-4, .9999)) * Math.PI,
            n = `M25,10 A15,15 ${180*i/Math.PI} ${t>.5?1:0},1 ${e+Math.sin(i)*e+10},${e-Math.cos(i)*e+10}`;
        this.flagReturnProgressPath1.setAttribute("d", n), this.flagReturnProgressPath2.setAttribute("d", n)
    }
    setFlagReturnProgressVisibility(t) {
        this.flagReturnProgressSvg.classList.toggle("hidden", !t), this.flagReturnAccuracyOffset.offset = t ? 20 : 0
    }
    setVisible(t) {
        this.el.style.display = t ? "" : "none"
    }
}
class fh {
    constructor(t) {
        this.el = document.createElement("div"), this.el.classList.add("flagScoreItem"), this.iconEl = document.createElement("div"), this.iconEl.classList.add("flagScoreIcon"), this.teamId = t, this.teamName = Ka[t].nameCapitalized, this.iconEl.style.background = `url("img/scoreUI/flag${this.teamName}.svg")`, this.el.appendChild(this.iconEl), this.maxScore = 3, this.score = 0, this.grabbed = !1, this.pointEls = [];
        for (let t = 0; t < this.maxScore; t++) {
            const t = document.createElement("div");
            t.classList.add("flagScorePointEl");
            const e = 90 * pa(0, 3);
            t.style.transform = `rotate(${e}deg) scale(1.3)`, this.el.appendChild(t), this.pointEls.push(t)
        }
    }
    setScore(t) {
        this.score = t, this.updatePointIcons()
    }
    setGrabbed(t) {
        this.grabbed = t, this.updatePointIcons()
    }
    updatePointIcons() {
        for (const [t, e] of this.pointEls.entries()) {
            let i = "pointEmpty";
            this.grabbed && t == this.score && (i = "pointGrabbed"), t < this.score && (i = "pointCaptured" + this.teamName), e.style.background = `url("img/scoreUI/${i}.svg")`
        }
    }
    getFinalFlagHeld() {
        return this.score == this.maxScore - 1 && this.grabbed
    }
    get hasFullScore() {
        return this.score >= this.maxScore
    }
}
class yh {
    constructor(t) {
        this.el = document.createElement("div"), this.el.classList.add("flagScoreContainer"), document.body.appendChild(this.el), this.scoreItems = [];
        for (let e = 0; e < t; e++) {
            if (0 == e) continue;
            const t = new fh(e);
            this.el.appendChild(t.el), this.scoreItems[e] = t
        }
    }
    destructor() {
        document.body.removeChild(this.el)
    }
    update(t) {
        for (let e = 0; e < this.scoreItems.length; e++) 0 != e && this.scoreItems[e].setScore(t[e])
    }
    setGrabbedFlags(t, e) {
        const i = this.scoreItems[t];
        i && i.setGrabbed(e)
    }
    getFinalFlagHeld() {
        for (const t of this.scoreItems)
            if (t && t.getFinalFlagHeld()) return !0;
        return !1
    }
    getWinningTeam() {
        for (const t of this.scoreItems)
            if (t && t.hasFullScore) return t.teamId;
        return -1
    }
    setVisible(t) {
        this.el.style.display = t ? null : "none"
    }
}
class vh {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("healthUiContainer"), document.body.appendChild(this.el);
        const t = document.createElement("div");
        t.classList.add("healthUiBarContainer"), this.el.appendChild(t), this.bar = document.createElement("div"), this.bar.classList.add("healthUiBar"), t.appendChild(this.bar);
        const e = document.createElement("div");
        e.classList.add("healthUiBorder"), this.el.appendChild(e)
    }
    destructor() {
        document.body.removeChild(this.el)
    }
    setHealth(t) {
        const e = -100 * (1 - t);
        this.bar.style.transform = `translateX(${e}%)`
    }
    setVisible(t) {
        this.el.style.display = t ? null : "none"
    }
}
class wh {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("gameplayBottomText", "blueNight", "whiteBigText"), document.body.appendChild(this.el)
    }
    destructor() {
        document.body.removeChild(this.el)
    }
    setTextState(t) {
        switch (t) {
            case "waitingForGameStart":
                this.el.textContent = "Waiting for players...";
                break;
            default:
                this.el.textContent = ""
        }
    }
    setVisible(t) {
        this.el.style.display = t ? null : "none"
    }
}
class bh {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("skipDialogText"), this.text = "Press space to skip...", this.currentTimerValue = 0, this.currentInterval = null, this.onTimerEndCbs = new Set, this.onSkipActionCbs = new Set, this.creationCooldownEnd = 0, this.allowSpaceSkip = !0, this.keyDownCb = t => {
            const e = performance.now() < this.creationCooldownEnd;
            "Space" == t.code && this.allowSpaceSkip && !e && this.fireSkipAction()
        }, window.addEventListener("keydown", this.keyDownCb), this.el.addEventListener("click", (() => {
            this.fireSkipAction()
        })), this.startCreationCooldown(), this.updateText()
    }
    destructor() {
        window.removeEventListener("keydown", this.keyDownCb), this.fireSkipAction()
    }
    setText(t) {
        this.text = t, this.updateText()
    }
    setVisibility(t) {
        this.el.style.display = t ? null : "none"
    }
    updateText() {
        let t = this.text;
        this.currentTimerValue > 0 && (t += " (" + this.currentTimerValue + ")"), this.el.textContent = t
    }
    startTimer(t = this.currentTimerValue) {
        this.stopTimer(), this.currentTimerValue = t, this.currentInterval = window.setInterval((() => {
            this.currentTimerValue--, this.currentTimerValue <= 0 && (this.stopTimer(), this.onTimerEndCbs.forEach((t => t()))), this.updateText()
        }), 1e3)
    }
    stopTimer() {
        this.currentInterval && (window.clearInterval(this.currentInterval), this.currentInterval = null, this.currentTimerValue = 0, this.updateText())
    }
    startCreationCooldown() {
        this.creationCooldownEnd = performance.now() + 1e3
    }
    setAllowSpaceSkip(t) {
        this.allowSpaceSkip = t
    }
    async waitForTimerEnd() {
        return new Promise((t => {
            this.onTimerEndCbs.add(t)
        }))
    }
    async waitForSkipAction() {
        return new Promise((t => {
            this.onSkipActionCbs.add(t)
        }))
    }
    fireSkipAction() {
        this.onSkipActionCbs.forEach((t => t()))
    }
    async waitForSkip() {
        return await Promise.race([this.waitForTimerEnd(), this.waitForSkipAction()])
    }
}
class xh extends Ma {
    constructor(t, e, i) {
        super({
            allowCurtainClose: !1,
            startVisible: !1
        }), this.playersList = t, this.avatarsManager = e, this.skinManager = i, this.teamWonTitle = document.createElement("h2"), this.teamWonTitle.classList.add("playersListTeamWonTitle", "blueNight"), this.teamWonTitle.style.display = "none", this.el.appendChild(this.teamWonTitle), this.teamsContainer = document.createElement("div"), this.teamsContainer.classList.add("playersListContainer"), this.el.appendChild(this.teamsContainer), this.currentAvatarBlobUrlReferences = new Set, this.teamEls = [];
        for (const [t, e] of Ka.entries()) {
            const i = document.createElement("div");
            i.classList.add("playersListTeam", "wrinkledPaper"), i.style.cssText = `\n\t\t\t\tbackground: ${e.cssColorLight};\n\t\t\t\tbackground: paint(wrinkledPaper);\n\t\t\t\t--wrinkled-paper-color: ${e.cssColorLight};\n\t\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t\t`;
            const n = document.createElement("table");
            n.classList.add("playersListTeamTable", "itemsTable"), i.appendChild(n);
            const s = document.createElement("colgroup");
            n.appendChild(s);
            const r = document.createElement("thead");
            r.style.cssText = `\n\t\t\t\tbackground: ${e.cssColor};\n\t\t\t\tbackground: paint(wrinkledPaper);\n\t\t\t\t--wrinkled-paper-color: ${e.cssColor};\n\t\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t\t`, n.appendChild(r);
            const o = document.createElement("tr");
            o.classList.add("playersListHead"), r.appendChild(o);
            const a = [{
                text: "",
                width: 100,
                colOnly: !0
            }, {
                text: "Team " + e.nameCapitalized,
                width: 300,
                colspan: 2
            }, {
                text: "Flags",
                width: 150
            }, {
                text: "Kills",
                width: 150
            }, {
                text: "Deaths",
                width: 150
            }, {
                text: "Score",
                width: 150
            }];
            for (const t of a) {
                const e = document.createElement("col");
                if (e.style.width = t.width + "px", s.appendChild(e), t.colOnly) continue;
                const i = document.createElement("th");
                i.textContent = t.text, t.colspan && (i.colSpan = t.colspan), o.appendChild(i)
            }
            const l = document.createElement("tbody");
            n.appendChild(l), this.teamEls[t] = {
                containerEl: i,
                tbody: l,
                name: e.name
            }
        }
        this.skipText = new bh, this.el.appendChild(this.skipText.el), this.skipText.setVisibility(!1), this.scoresFrozen = !1, this.playersListDirty = !0, this.updateTeamsOrder(), this.boundOnResize = this.onResize.bind(this), ea.addListener(this.boundOnResize), this.onResize(), this.setUnsetTeamVisibility(!0)
    }
    destructor() {
        super.destructor(), ea.removeListener(this.boundOnResize);
        for (const t of this.currentAvatarBlobUrlReferences) t.destructor();
        this.currentAvatarBlobUrlReferences.clear()
    }
    onVisibilityChange() {
        this.playersListDirty && (this.updatePlayersList(), this.playersListDirty = !1)
    }
    onResize() {
        const t = da(window.innerHeight - 200, 100, 600);
        this.el.classList.toggle("topCenter", window.innerHeight < 790), this.teamsContainer.style.maxHeight = t + "px"
    }
    playersListChanged() {
        this.visible ? this.updatePlayersList() : this.playersListDirty = !0
    }
    updateTeamsOrder(t = -1) {
        for (; this.teamsContainer.lastChild;) this.teamsContainer.removeChild(this.teamsContainer.lastChild);
        const e = this.teamEls[t];
        e && this.teamsContainer.appendChild(e.containerEl);
        for (const [e, i] of this.teamEls.entries()) e != t && this.teamsContainer.appendChild(i.containerEl)
    }
    updatePlayersList() {
        if (this.scoresFrozen) return;
        const t = new Map;
        for (const {
            tbody: e
        }
            of this.teamEls)
            for (const i of e.children)
                if (i.childElementCount > 0) {
                    const e = i.children[0];
                    if (e) {
                        const i = e.children[0];
                        if (i && i instanceof HTMLDivElement) {
                            const e = i.style.backgroundImage;
                            if (e) {
                                let n = t.get(e);
                                n || (n = [], t.set(e, n)), n.push(i)
                            }
                        }
                    }
                } for (const t of this.teamEls) {
            const e = t.tbody;
            for (; e.lastChild;) e.removeChild(e.lastChild)
        }
        const e = Array.from(this.currentAvatarBlobUrlReferences);
        this.currentAvatarBlobUrlReferences.clear();
        const i = Array.from(this.playersList.values()).sort(((t, e) => e.scoreTotal - t.scoreTotal));
        for (const e of i) {
            const i = document.createElement("tr");
            i.classList.add("playersListItem", "tableItem"), this.teamEls[e.teamId].tbody.appendChild(i);
            let n = null;
            e.hasOwnership ? n = "You" : e.isSameSquadPlayer && (n = "Squad");
            const s = [{
                text: "",
                isAvatar: !0
            }, {
                text: e.playerName,
                label: n,
                isPlayerName: !0,
                verified: e.playerNameVerified
            }, {
                text: e.scoreFlags,
                isScore: !0
            }, {
                text: e.scoreKills,
                isScore: !0
            }, {
                text: e.scoreDeaths,
                isScore: !0
            }, {
                text: e.scoreTotal,
                isScore: !0
            }];
            for (const n of s) {
                const s = document.createElement("td");
                if (n.isPlayerName || (s.textContent = String(n.text)), n.isScore) s.classList.add("playersListItemScore"), s.style.cssText = `\n\t\t\t\t\t\t--wrinkled-paper-seed: ${e.id};\n\t\t\t\t\t`;
                else if (n.isAvatar) {
                    const i = document.createElement("div");
                    i.classList.add("player-list-avatar"), s.appendChild(i);
                    const n = 40 * globalThis.devicePixelRatio,
                        r = this.avatarsManager.getAvatar({
                            backgroundColor: Ka[e.teamId].cssColor,
                            width: n,
                            height: n,
                            skinObjectOpts: {
                                teamId: e.teamId,
                                skin: e.equippedSkinData
                            }
                        }).getBlobUrlReference();
                    this.currentAvatarBlobUrlReferences.add(r), (async () => {
                        const e = await r.getBlobUrl(),
                            n = `url("${e}")`,
                            o = t.get(n);
                        let a = null;
                        o && o.length > 0 && (a = o.pop()), a ? (s.removeChild(i), s.appendChild(a), t.delete(e)) : i.style.backgroundImage = n
                    })()
                } else if (n.isPlayerName) {
                    const t = document.createElement("span");
                    if (t.classList.add("player-list-username"), t.textContent = n.text, s.appendChild(t), s.classList.add("players-list-item-username"), n.verified) {
                        const t = document.createElement("div");
                        t.classList.add("player-name-verified-icon"), s.appendChild(t)
                    }
                }
                if (n.label) {
                    const t = document.createElement("span");
                    t.textContent = n.label, t.classList.add("players-list-label"), t.style.background = Ka[e.teamId].cssColor, s.appendChild(t)
                }
                i.appendChild(s)
            }
        }
        for (const t of e) t.destructor()
    }
    freezeScores() {
        this.updatePlayersList(), this.scoresFrozen = !0
    }
    setUnsetTeamVisibility(t) {
        for (const {
            containerEl: e,
            name: i
        }
            of this.teamEls) {
            const n = "unset" == i;
            e.style.display = t == n ? "" : "none"
        }
    }
    showTeamWonTitle(t) {
        if (-1 == t) return;
        const e = Ka[t];
        this.teamWonTitle.textContent = `Team ${e.name} won!`, this.teamWonTitle.style.display = "", this.teamWonTitle.style.color = e.cssColor
    }
}
class Sh {
    constructor({
                    classId: t,
                    keyNumber: e,
                    iconPath: i
                }) {
        this.keyNumber = e, this.el = document.createElement("div"), this.el.classList.add("weaponSelectionItem"), this.classSelectionImage = new il(t, {
            extraClasses: ["in-game"]
        }), this.el.appendChild(this.classSelectionImage.el), this.el.addEventListener("click", (() => {
            for (const t of this.onClickCbs) t()
        })), this._selected = !1, this.keyEl = document.createElement("div"), this.keyEl.classList.add("weaponSelectionItemKeyNumber", "blueNight"), this.keyEl.textContent = String(e), this.el.appendChild(this.keyEl), this.onClickCbs = new Set
    }
    get selected() {
        return this._selected
    }
    set selected(t) {
        this._selected = t, this.el.classList.toggle("selected", t)
    }
    set needsAvatarUpdates(t) {
        this.classSelectionImage.needsUpdates = t
    }
    onClick(t) {
        this.onClickCbs.add(t)
    }
    setUiTeamColor(t) {
        this.classSelectionImage.setTeamId(t)
    }
}
class Mh extends Ma {
    constructor() {
        super({
            allowCurtainClose: !1,
            needsCurtain: !1,
            startVisible: !1,
            extraClasses: ["weaponSelectionDialog"]
        }), this.selectionItemsContainer = document.createElement("div"), this.selectionItemsContainer.classList.add("weaponSelectionContainer"), this.el.appendChild(this.selectionItemsContainer), this.weaponSelectionItems = [];
        for (const [t, e] of Ea.entries()) {
            const i = e.id,
                n = t + 1,
                s = `img/weaponSelectionUI/${e.bowId}.svg`,
                r = new Sh({
                    classId: i,
                    keyNumber: n,
                    iconPath: s
                });
            r.onClick((() => {
                this.selectWeapon(t)
            })), this.weaponSelectionItems.push(r), this.selectionItemsContainer.appendChild(r.el)
        }
        this.currentSelectedWeaponIndex = 1, this.updateSelectedUi(), this.boundPrevPress = () => {
            this.deltaSelectWeapon(-1)
        }, this.boundNextPress = () => {
            this.deltaSelectWeapon(1)
        }, this.prevKey = uc().input.getKey("prevWeapon"), this.prevKey.onPressedDown(this.boundPrevPress), this.nextKey = uc().input.getKey("nextWeapon"), this.nextKey.onPressedDown(this.boundNextPress), this.boundKeyDown = this.onKeyDown.bind(this), window.addEventListener("keydown", this.boundKeyDown), this.onSelectionChangeCbs = new Set, this.addOnVisibilityChangeCb((() => {
            this.updateNeedsAvatarUpdates()
        })), this.addOnInertChangeCb((() => {
            this.updateNeedsAvatarUpdates()
        })), uc()
    }
    destructor() {
        super.destructor(), this.prevKey.removeCb(this.boundPrevPress), this.nextKey.removeCb(this.boundNextPress), window.removeEventListener("keydown", this.boundKeyDown), uc()
    }
    updateSelectedUi() {
        for (const [t, e] of this.weaponSelectionItems.entries()) e.selected = t == this.currentSelectedWeaponIndex
    }
    updateNeedsAvatarUpdates() {
        const t = this.visible && !this.inert;
        for (const e of this.weaponSelectionItems) e.needsAvatarUpdates = t
    }
    setUiTeamColor(t) {
        for (const e of this.weaponSelectionItems) e.setUiTeamColor(t)
    }
    onKeyDown(t) {
        for (const [e, i] of this.weaponSelectionItems.entries()) t.code == "Digit" + i.keyNumber && this.selectWeapon(e)
    }
    selectWeapon(t) {
        if (this.visible) {
            this.currentSelectedWeaponIndex = t, this.currentSelectedWeaponIndex = aa(this.currentSelectedWeaponIndex, this.weaponSelectionItems.length), this.updateSelectedUi();
            for (const t of this.onSelectionChangeCbs) t(this.currentSelectedWeaponIndex)
        }
    }
    deltaSelectWeapon(t) {
        this.selectWeapon(this.currentSelectedWeaponIndex + t)
    }
    onSelectionChange(t) {
        this.onSelectionChangeCbs.add(t)
    }
    removeOnSelectionChange(t) {
        this.onSelectionChangeCbs.delete(t)
    }
}
class Ch {
    constructor(t = "topleft") {
        this.el = document.createElement("div"), this.el.classList.add("notificationIconsUiContainer", t), document.body.appendChild(this.el), this.currentIconEl = null
    }
    destructor() {
        document.body.removeChild(this.el)
    }
    showIcon(t) {
        this.currentIconEl && this.el.removeChild(this.currentIconEl);
        let e = null;
        t && (e = document.createElement("div"), e.classList.add("notificationIcon"), e.style.backgroundImage = `url(${t})`, this.el.appendChild(e)), this.currentIconEl = e
    }
    removeIcon() {
        this.showIcon(null)
    }
}
const _h = new Map;
_h.set(Wl.PlayerScoreOffsetReason.KILL, {
    text: "Kill",
    overviewText: "Kills"
}), _h.set(Wl.PlayerScoreOffsetReason.ASSIST, {
    text: "Assist",
    overviewText: "Assists"
}), _h.set(Wl.PlayerScoreOffsetReason.FLAG_CARRIER_KILL, {
    text: "Carrier Kill",
    overviewText: "Carrier Kills"
}), _h.set(Wl.PlayerScoreOffsetReason.FLAG_GRAB, {
    text: "Grab",
    overviewText: "Flag Grabs"
}), _h.set(Wl.PlayerScoreOffsetReason.FLAG_CARRY, {
    text: "",
    overviewText: "Flag Carry",
    visibilityDuration: .5
}), _h.set(Wl.PlayerScoreOffsetReason.FLAG_CARRY_ASSIST, {
    text: "Carrier Assist",
    overviewText: "Carrier Assist",
    visibilityDuration: .5
}), _h.set(Wl.PlayerScoreOffsetReason.FLAG_CAPTURE, {
    text: "Capture",
    overviewText: "Flag Captures"
}), _h.set(Wl.PlayerScoreOffsetReason.WIN_BONUS, {
    overviewText: "Win Bonus",
    hideInGame: !0
}), _h.set(Wl.PlayerScoreOffsetReason.FLAG_RETURN, {
    text: "Flag Return",
    overviewText: "Flag Return"
}), _h.set(Wl.PlayerScoreOffsetReason.HEADSHOT, {
    text: "Headshot",
    overviewText: "Headshots"
}), _h.set(Wl.PlayerScoreOffsetReason.LONG_RANGE, {
    text: "Long Range",
    overviewText: "Long Range Hits"
});
class Eh {
    constructor() {
        this.el = document.createElement("div"), this.el.classList.add("score-offset-notifications-container", "fullScreen"), document.body.appendChild(this.el), this.listEl = document.createElement("div"), this.listEl.classList.add("score-offset-notifications-list", "blueNight", "whiteBigText"), this.el.appendChild(this.listEl), this.createdNotifications = []
    }
    destructor() {
        document.body.removeChild(this.el)
    }
    showOffsetNotification(t, e) {
        const i = _h.get(e);
        if (!i || i.hideInGame) return;
        let n = i.visibilityDuration;
        void 0 === n && (n = 2);
        const s = document.createElement("div");
        s.classList.add("scoreOffsetNotification"), this.listEl.appendChild(s), this.createdNotifications.unshift({
            el: s,
            destroyTime: Date.now() + 1e3 * n + 1e3
        });
        const r = document.createElement("div");
        if (r.classList.add("scoreOffsetNotificationAnim"), r.style.animation = `1s notificationIconFade ${n}s both, 0.2s notificationIconPop`, s.appendChild(r), i.text) {
            const t = document.createTextNode(i.text + " ");
            r.appendChild(t)
        }
        const o = document.createElement("span");
        o.classList.add("scoreOffsetNotificationScore"), o.textContent = `+${t}`, r.appendChild(o), this.destroyOldNotifications(), this.updateNotificationOffsets()
    }
    destroyOldNotifications() {
        let t = -1;
        for (const [e, i] of this.createdNotifications.entries())
            if (i.destroyTime <= Date.now()) {
                t = e;
                break
            } if (t >= 0) {
            for (let e = t; e < this.createdNotifications.length; e++) {
                const t = this.createdNotifications[e];
                t.el.parentNode && t.el.parentNode.removeChild(t.el)
            }
            this.createdNotifications.splice(t)
        }
    }
    updateNotificationOffsets() {
        for (const [t, e] of this.createdNotifications.entries()) e.el.style.transform = `translateY(${-40*t}px)`
    }
    removeAll() {
        for (; this.listEl.firstChild;) this.listEl.removeChild(this.listEl.firstChild)
    }
}
class Ph extends Ma {
    constructor({
                    trackedMyPlayerScores: t,
                    totalScore: e,
                    myTeamId: i,
                    receivedCoins: n
                }) {
        super({
            allowCurtainClose: !1
        });
        const s = document.createElement("h2");
        s.classList.add("dialogTitle", "blueNight"), s.textContent = "Your Game Stats";
        const r = Ka[i];
        s.style.color = r.cssColor, this.el.appendChild(s), this.statsContainer = document.createElement("div"), this.statsContainer.classList.add("gameoverStatsContainer", "wrinkledPaper"), this.statsContainer.style.cssText = `\n\t\t\tbackground: ${r.cssColorLight};\n\t\t\tbackground: paint(wrinkledPaper);\n\t\t\t--wrinkled-paper-color: ${r.cssColorLight};\n\t\t\t--wrinkled-paper-seed: ${pa(1,99999)};\n\t\t`, this.el.appendChild(this.statsContainer);
        const o = document.createElement("table");
        o.classList.add("gameOverStatsTable", "itemsTable"), this.statsContainer.appendChild(o);
        const a = document.createElement("tbody");
        o.appendChild(a);
        for (const [e, i] of _h.entries()) {
            if (!t.has(e)) continue;
            const n = t.get(e),
                s = i.text || i.overviewText,
                r = document.createElement("tr");
            r.classList.add("tableItem"), a.appendChild(r);
            const o = document.createElement("td");
            o.textContent = s, r.appendChild(o);
            const l = document.createElement("td");
            l.textContent = n, r.appendChild(l)
        }
        const l = document.createElement("tr");
        l.classList.add("tableItem", "totalScoreRow"), a.appendChild(l);
        const h = document.createElement("td");
        h.textContent = "Total", l.appendChild(h);
        const c = document.createElement("td");
        if (c.textContent = e, l.appendChild(c), this.didWatchRewardedAd = !1, this.onRewardedAdIsPlayingChangeCbs = new Set, n > 0) {
            const t = document.createElement("div");
            t.classList.add("game-over-stats-coins-container"), this.el.appendChild(t);
            const e = new xa;
            e.animateAmount(n), t.appendChild(e.el);
            const i = new Sa({
                text: "Claim x2",
                icon: "img/rewardedAdIcon.svg",
                iconSize: 1.8,
                extraClasses: ["shake-anim"],
                onClick: async () => {
                    if (this.skipText.setAllowSpaceSkip(!1), this.skipText.stopTimer(), i.enabled = !1, !this.didWatchRewardedAd) {
                        this.fireRewardedAdIsPlayingChange(!0);
                        const t = await uc().poki.rewardedBreakWithErrorDialog();
                        this.fireRewardedAdIsPlayingChange(!1), t ? this.didWatchRewardedAd = !0 : i.enabled = !0
                    }
                    this.skipText.setAllowSpaceSkip(!0);
                    let t = !1;
                    if (this.didWatchRewardedAd) {
                        const s = await uc().shopState.doubleLastGameCoins();
                        s.success ? (i.visible = !1, e.animateAmount(2 * n), this.skipText.startTimer(6), t = !0) : (uc().dialogManager.showAlert({
                            title: "Server error",
                            text: "An error occurred while doubling your coins."
                        }), console.error(s.error), i.enabled = !0)
                    }
                    t || uc().network.matchMaking.closeMatchMakingConnection()
                }
            });
            t.appendChild(i.el)
        }
        this.skipText = new bh, this.el.appendChild(this.skipText.el), this.boundOnResize = this.onResize.bind(this), ea.addListener(this.boundOnResize), this.onResize()
    }
    onResize() {
        this.el.classList.toggle("topCenter", window.innerHeight < 900);
        const t = da(window.innerHeight - 350, 100, 600);
        this.statsContainer.style.maxHeight = t + "px"
    }
    onRewardedAdIsPlayingChange(t) {
        this.onRewardedAdIsPlayingChangeCbs.add(t)
    }
    fireRewardedAdIsPlayingChange(t) {
        this.onRewardedAdIsPlayingChangeCbs.forEach((e => e(t)))
    }
}
class Th {
    constructor(t = 0, e = "") {
        this.timeSeconds = t, this.name = e, this.running = !1, this.startTime = 0, this.onSuddenChangeCbs = new Set
    }
    setTotalTime(t) {
        this.timeSeconds = t
    }
    start() {
        this.running = !0, this.startTime = Date.now()
    }
    clear() {
        const t = this.timeRemaining > 1;
        this.cleared = !0, t && this.onSuddenChangeCbs.forEach((t => t()))
    }
    onSuddenChange(t) {
        this.onSuddenChangeCbs.add(t)
    }
    get timeRemaining() {
        if (this.cleared) return 0;
        if (this.running) {
            const t = (Date.now() - this.startTime) / 1e3;
            return Math.max(0, this.timeSeconds - t)
        }
        return this.timeSeconds
    }
    toString() {
        let t = this.timeRemaining;
        return t = Math.round(10 * t) / 10, `<${this.name} ${t}>`
    }
}
class Ah {
    constructor() {
        this.teamCount = 3, this.players = new Map, this.arrowManager = new ph(this.teamCount), this.crosshair = new gh, this.flags = [], this.uiVisible = !1, this.flagScoreUi = new yh(this.teamCount), this.healthUi = new vh, this.bottomText = new wh, this.weaponSelectionDialog = new Mh, uc().dialogManager.addDialog(this.weaponSelectionDialog), this.playersListDialog = new xh(this.players, uc().avatars, uc().skins), uc().dialogManager.addDialog(this.playersListDialog), this.gameOverStatsDialog = null, this.cornerNotificationsUi = new Ch, this.gameOverNotificationsUi = new Ch("centerbig"), this.crosshairNotificationsUi = new Ch("crosshair"), this.scoreOffsetNotificationsUi = new Eh, this.gameEndLoweringTimeScaleDuration = 6, this.gameEndTitleDurationWin = 3, this.gameEndTitleDurationLose = 2, this.gameEndPlayersListDuration = 6, this.gameEndShowStatsDuration = 8, this.gameEndRewardedAdDuration = 15, this.gameEndShowStatsAfterRewardedDuration = 6, this.trackedMyPlayerScores = new Map, this.spawnPositions = [], this.lobbypawnPositions = [], this.gameStartTime = 0, this.gameStarted = !1, this.gameEnded = !1, this.gameSeed = 0, this.onGameSeedChangeCbs = new Set, this.destructed = !1, this.shouldPlayFinalFlagMusic = !1, this.currentFinalFlagMusic = null, this.currentGameEndWaitingMusic = null, this.onGameEndCbs = new Set, this.gameEndWaitTimers = [], this.gameEndTimerSuddenChangeDisabled = !1, this.onEstimatedMaxGameEndWaitTimeSuddenChangeCbs = new Set, this.onGameCloseCbs = new Set, this.onSdkGameplayStartedChangeCbs = new Set, this.onSquadPlayersChangeCbs = new Set, this.gameEndAccountStats = null, this.onGameEndAccountStatsChangeCbs = new Set, this.isDoingGameEndSteps = !1, this.gameEndMyTotalScore = 0, this.gameEndReceivedCoins = 0, this.gameEndShowStatsScreen = !1, this.gameEndStatsShowTimer = null, this.gameEndAdBreakTimer = null, this.gameEndRewardedAdTimer = null, this.gameEndStatsAfterRewardedAdTimer = null, this.boundUpdateMapGameplayData = this.updateMapGameplayData.bind(this), uc().mapLoader.onGameplayDataChange(this.boundUpdateMapGameplayData), this.updateMapGameplayData(), this.boundNotifyServerCurrentMap = this.notifyServerCurrentMap.bind(this), uc().mapLoader.onMapContentLoaded(this.boundNotifyServerCurrentMap), this.notifyServerCurrentMap(), this.boundUpdateUiVisible = this.updateUiVisible.bind(this), uc().mainMenu.onVisibilityChange(this.boundUpdateUiVisible), this.updateUiVisible(), this.boundOnPlayerListDown = this.onPlayerListDown.bind(this), this.boundOnPlayerListUp = this.onPlayerListUp.bind(this);
        const t = uc().input.getKey("playerList");
        t.onPressedDown(this.boundOnPlayerListDown), t.onPressedUp(this.boundOnPlayerListUp), uc().physics.resetTimeScale(), this.antiCheat = new rh, this.antiCheat.onPlayerNeedsReport(((t, e) => {
            uc().network.sendReportCheater(t, e)
        }))
    }
    destructor() {
        if (this.destructed) return;
        this.destructed = !0, this.fireSdkGameplayStartedChange();
        for (const t of this.players.values()) t.destructor();
        this.players.clear(), this.arrowManager.destructor(), this.crosshair.destructor();
        for (const t of this.flags) t.destructor();
        this.flagScoreUi.destructor(), this.healthUi.destructor(), this.bottomText.destructor(), this.cornerNotificationsUi.destructor(), this.gameOverNotificationsUi.destructor(), this.crosshairNotificationsUi.destructor(), this.scoreOffsetNotificationsUi.destructor(), uc().mapLoader.removeOnGameplayDataChange(this.boundUpdateMapGameplayData), uc().mapLoader.removeOnMapContentLoaded(this.boundNotifyServerCurrentMap), uc().mainMenu.removeOnVisibilityChange(this.boundUpdateUiVisible);
        const t = uc().input.getKey("playerList");
        t.removeCb(this.boundOnPlayerListDown), t.removeCb(this.boundOnPlayerListUp), this.playersListDialog.close(), this.gameOverStatsDialog && (this.gameOverStatsDialog.close(), this.gameOverStatsDialog = null), this.weaponSelectionDialog.close(), this.gameEndWaitTimers = [], uc().adBanners.setPageVisibility("gameEnd", !1), this.currentFinalFlagMusic && (this.currentFinalFlagMusic.stop(), this.currentFinalFlagMusic = null), this.currentGameEndWaitingMusic && (this.currentGameEndWaitingMusic.stop(), this.currentGameEndWaitingMusic = null), uc().classSelectionImageManager.setTeamId(null)
    }
    get sdkGameplayStarted() {
        return this.gameStarted && !this.gameEnded && !this.isDoingGameEndSteps && !this.destructed
    }
    onSdkGameplayStartedChange(t) {
        this.onSdkGameplayStartedChangeCbs.add(t)
    }
    fireSdkGameplayStartedChange() {
        this.onSdkGameplayStartedChangeCbs.forEach((t => t()))
    }
    updateMapGameplayData() {
        const t = uc().mapLoader.currentGameplayData;
        if (t) {
            for (const t of this.flags) t.destructor();
            this.flags = [];
            for (const {
                flagTeamId: e,
                pos: i,
                rot: n
            }
                of t.flags) this.createFlag(e, i, n);
            this.spawnPositions = t.spawnPositions
        }
    }
    setServerGameTime(t) {
        this.gameStartTime = uc().now - t
    }
    setServerGameSeed(t) {
        this.gameSeed = t, this.onGameSeedChangeCbs.forEach((e => e(t)))
    }
    onGameSeedChange(t) {
        this.onGameSeedChangeCbs.add(t)
    }
    get gameTime() {
        return uc().now - this.gameStartTime
    }
    notifyServerCurrentMap() {
        const t = uc(),
            e = t.mapLoader;
        if (!e.currentMapHasScene || null == e.currentMapHash) return;
        if (!e.currentMapHasGameplayObjects) return;
        t.network.sendCurrentLoadedMapHash(e.currentMapHash);
        t.physics.mapBounds && t.network.sendWorldBounds(), t.network.sendDefaultFlagPositions(this.flags)
    }
    createPlayer(t, e) {
        const i = uc(),
            n = new oh(this, i.input, i.sfx, i.physics, i.settingsManager, i.hudIcons, t, e);
        n.init(), this.players.set(t, n), this.playersListDialog.playersListChanged(), i.renderer.renderWorthyEventHappened()
    }
    destroyPlayer(t) {
        const e = this.players.get(t);
        if (e) {
            const i = e.sameSquadOrOwned;
            e.destructor(), this.players.delete(t), this.playersListDialog.playersListChanged(), uc().renderer.renderWorthyEventHappened(), i && this.fireSquadPlayersChange()
        }
    }
    setPlayerOwnership(t, e) {
        const i = this.players.get(t);
        i && i.setHasOwnership(e), uc().mainMenu.setJoinState("joined"), uc().gameManager.setJoinedOnce(), this.updatePlayerIconVisibilities(), this.playersListDialog.playersListChanged();
        const n = this.getMyTeamId();
        this.playersListDialog.updateTeamsOrder(n), this.updateMyTeamColor(), this.updateBottomText(), this.fireSquadPlayersChange()
    }
    updateMyTeamColor() {
        let t = 0;
        const e = this.getMyPlayer();
        e && (t = e.teamId), this.weaponSelectionDialog.setUiTeamColor(t), uc().classSelectionImageManager.setTeamId(t)
    }
    setPlayerName(t, e) {
        const i = this.players.get(t);
        i && (i.setPlayerName(e), this.playersListDialog.playersListChanged(), i.sameSquadOrOwned && this.fireSquadPlayersChange())
    }
    setPlayerNameVerified(t) {
        const e = this.players.get(t);
        e && (e.setNamePlayerVerified(), this.playersListDialog.playersListChanged())
    }
    setPlayerTeamId(t, e) {
        const i = this.players.get(t);
        i && i.setTeamId(e), this.playersListDialog.playersListChanged(), i && i.sameSquadOrOwned && this.fireSquadPlayersChange()
    }
    setSameSquadPlayerIds(t) {
        let e = !1;
        for (const i of t) {
            const t = this.players.get(i);
            t && (t.setIsSameSquadPlayer(!0), e = !0)
        }
        e && (this.fireSquadPlayersChange(), this.playersListDialog.playersListChanged())
    }
    onSquadPlayersChange(t) {
        this.onSquadPlayersChangeCbs.add(t)
    }
    fireSquadPlayersChange() {
        this.onSquadPlayersChangeCbs.forEach((t => t()))
    }
    setPlayerScores(t) {
        const e = this.players.get(t.playerId);
        e && e.setScores(t), this.playersListDialog.playersListChanged()
    }
    createFlag(t, e, i) {
        const n = uc().physics,
            s = new hh(this.flags.length, t, e, i, n);
        this.flags.push(s)
    }* getMyFlags(t = -1) {
        if (-1 == t) {
            const e = this.getMyPlayer();
            e && (t = e.teamId)
        }
        for (const e of this.flags) e.teamId == t && (yield e)
    }* getEnemyFlags(t = -1) {
        for (const e of this.flags) e.teamId != t && (yield e)
    }
    playerChangeFlag(t, e, i) {
        const n = this.flags[e];
        if (n) {
            if (!this.gameEnded) {
                let t = !1,
                    e = n.teamId == this.getMyTeamId(),
                    s = null;
                i == Wl.FlagChangeOperation.GRAB ? (s = "grab", e = !e) : i == Wl.FlagChangeOperation.CAPTURE ? (s = "capture", t = !0, e = !e) : i == Wl.FlagChangeOperation.DROP ? s = "drop" : i == Wl.FlagChangeOperation.RETURN && (s = "return");
                let r = e ? "positive" : "negative";
                t && (r += "Important"), uc().sfx.playSound("flag/" + r);
                const o = Ka[n.teamId].name;
                if (s) {
                    const t = `img/notificationIcons/flag/${o}/${s}.svg`;
                    this.uiVisible && this.cornerNotificationsUi.showIcon(t)
                }
            }
            const e = this.players.get(t);
            e ? e.changeFlagFromServer(n, i) : i == Wl.FlagChangeOperation.RETURN && n.returnToDefaultPos(), this.updateFlagGrabbedStates()
        }
    }
    setFlagDroppedPosition(t, e, i, n, s, r, o) {
        const a = this.flags[t];
        a && a.setDroppedPosition(e, i, n, s, r, o), this.updateFlagGrabbedStates()
    }
    loop(t, e) {
        for (const i of this.players.values()) i.loop(t, e);
        for (const i of this.flags) i.loop(t, e);
        this.arrowManager.loop(t, e), this.crosshair.loop(t, e);
        const i = uc(),
            n = i.mapLoader.cloudsObj;
        n && (n.rotation.y = 1e-5 * t, n.updateWorldMatrix(!1, !0));
        const s = this.getMyPlayer();
        let r = 0;
        const o = i.mapLoader.mapVariablesManager.get("windSfxVolume");
        "number" == typeof o && (r = o);
        let a = 0,
            l = 0;
        const h = i.mapLoader.mapVariablesManager.get("birdsSfxVolume");
        "number" == typeof h && (l = h);
        let c = 0;
        const d = i.mapLoader.mapVariablesManager.get("jungleSfxVolume");
        "number" == typeof d && (c = d);
        let u = 0;
        const p = i.mapLoader.mapVariablesManager.get("rainSfxVolume");
        if ("number" == typeof p && (u = p), s) {
            const t = s.pos.y,
                e = i.mapLoader.mapVariablesManager.get("windSfxBoostVolume");
            if ("number" == typeof e && e > 0) {
                const n = i.mapLoader.mapVariablesManager.get("windSfxBoostHeight");
                if ("number" == typeof n) {
                    const i = ua(1 / Math.max(0, n - t) - .2) * e;
                    r = Math.max(i, r)
                }
            }
            const n = i.mapLoader.mapVariablesManager.get("waterSfxVolume");
            if ("number" == typeof n && n > 0) {
                const e = i.mapLoader.mapVariablesManager.get("waterSfxHeight");
                if ("number" == typeof e) {
                    a = da(.07 / Math.max(0, t - e), 0, .05), a *= n
                }
            }
        }
        i.gameManager.setAmbientVolumes(r, a, l, c, u)
    }
    afterPhysicsLoop(t, e) {
        for (const i of this.players.values()) i.afterPhysicsLoop(t, e);
        for (const i of this.flags) i.afterPhysicsLoop(t, e)
    }
    getMyPlayer() {
        for (const t of this.players.values())
            if (t.hasOwnership) return t;
        return null
    }
    getMyTeamId() {
        const t = this.getMyPlayer();
        return t ? t.teamId : -1
    }
    updatePlayerIconVisibilities() {
        const t = this.getMyTeamId();
        for (const e of this.players.values()) e.updateIconVisibility(t)
    }
    updateBottomText() {
        let t = null;
        this.gameStarted || (t = "waitingForGameStart"), this.bottomText.setTextState(t)
    }
    setPlayerServerData(t, e, i, n, s, r, o = !1) {
        const a = this.players.get(t);
        a && a.setServerData(e, i, n, s, r, o), uc().renderer.renderWorthyEventHappened()
    }
    setPlayerPingData(t, e) {
        const i = this.players.get(t);
        i && i.setPingData(e)
    }
    createServerArrow(t, e, i, n, s, r, o, a, l) {
        const h = this.players.get(t),
            c = this.getMyPlayer();
        let d = new w(0, 0, 0);
        if (c && h) {
            const t = c.ping + h.ping;
            d = c.getDeltaPositionMsAgo(t)
        }
        if (h) {
            const t = new w(i, n, s),
                c = new w(r, o, a),
                u = h.getCamPos(),
                p = u.clone().add(d);
            t.distanceTo(u) > 3 && t.distanceTo(p) > 3 && (t.copy(u), d.set(0, 0, 0)), this.arrowManager.createArrow(h, {
                arrowId: e,
                pos: t,
                networkOffsetPos: d,
                dir: c,
                fireAmount01: l
            })
        }
    }
    getSpawnPosition(t) {
        const e = this.spawnPositions[t];
        return e ? fa(e) : {
            pos: new w,
            rot: new v
        }
    }
    playerHitByArrowFromServer(t, e, i, n) {
        const s = this.players.get(t),
            r = this.players.get(e);
        s && r && s.onArrowHitFromServer(r, i, n)
    }
    receivedPlayerPerformAction(t, e) {
        const i = this.players.get(t);
        i && i.receivedPerformAction(e)
    }
    receivePlayerChangeWeapon(t, e) {
        const i = this.players.get(t);
        i && i.receiveChangeWeaponFromServer(e)
    }
    playerChangedAutoShootValue(t, e) {
        const i = this.players.get(t);
        i && i.receiveAutoShootValueFromServer(e)
    }
    setPlayerEquippedSkinData(t, e) {
        const i = this.players.get(t);
        i && (i.setPlayerEquippedSkinData(e), this.playersListDialog.playersListChanged()), i && i.sameSquadOrOwned && this.fireSquadPlayersChange()
    }
    updateScoreboard(t) {
        this.flagScoreUi.update(t)
    }
    updateFlagGrabbedStates() {
        const t = new Set;
        for (const e of this.flags)
            if (e.currentHoldingPlayer) t.add(e.currentHoldingPlayer.teamId);
            else if (!e.isNearDefaultPos)
                for (let i = 0; i < this.teamCount; i++) i != e.teamId && t.add(i);
        for (let e = 0; e < this.teamCount; e++) this.flagScoreUi.setGrabbedFlags(e, t.has(e));
        this.updateFinalFlagMusic(), uc().renderer.renderWorthyEventHappened()
    }
    async updateFinalFlagMusic() {
        this.shouldPlayFinalFlagMusic = this.flagScoreUi.getFinalFlagHeld() && !this.gameEnded;
        const t = !!this.currentFinalFlagMusic;
        if (this.shouldPlayFinalFlagMusic != t)
            if (this.shouldPlayFinalFlagMusic) {
                const t = await uc().sfx.playSound("music/finalFlag");
                this.currentFinalFlagMusic || !this.shouldPlayFinalFlagMusic ? t && t.stop() : this.currentFinalFlagMusic = t
            } else this.currentFinalFlagMusic && (this.currentFinalFlagMusic.stop(), this.currentFinalFlagMusic = null)
    }
    showKillNotification() {
        this.uiVisible && this.crosshairNotificationsUi.showIcon("img/notificationIcons/crosshair/kill.svg")
    }
    showKilledNotification() {
        this.uiVisible && this.crosshairNotificationsUi.showIcon("img/notificationIcons/crosshair/killed.svg")
    }
    offsetPlayerScore(t, e, i) {
        if (this.gameEnded) return;
        const n = this.players.get(t);
        if (n && n.hasOwnership) {
            let t = 0;
            const n = this.trackedMyPlayerScores.get(i);
            n && (t = n), t += e, this.trackedMyPlayerScores.set(i, t), this.uiVisible && this.scoreOffsetNotificationsUi.showOffsetNotification(e, i)
        }
    }
    notifyGameStarted() {
        this.gameStarted = !0, this.fireSdkGameplayStartedChange(), this.updateBottomText();
        const t = this.getMyPlayer();
        t && t.respawn(), this.playersListDialog.setUnsetTeamVisibility(!1)
    }
    receivedGameEndAccountStats(t) {
        this.gameEndReceivedCoins = t.receivedCoins, t.receivedCoins > 0 && uc().shopState.provideNewCoinCount(t.newCoinCount), this.updateGameEndShowStatsScreen()
    }
    updateGameEndShowStatsScreen() {
        this.gameEndShowStatsScreen = this.gameEndMyTotalScore > 0 || this.gameEndReceivedCoins > 0, this.gameEndStatsShowTimer && this.gameEndStatsShowTimer.setTotalTime(this.gameEndShowStatsScreen ? this.gameEndShowStatsDuration : 0)
    }
    notifyGameEnded() {
        this.gameEnded = !0, uc().network.markNextCloseAsIntentional(), this.fireSdkGameplayStartedChange(), this.playersListDialog.visible = !1, this.playersListDialog.freezeScores();
        const t = this.getMyPlayer();
        if (t) {
            const e = t.getMatchMakeSkillLevel();
            uc().network.matchMaking.updateSmoothSkillLevel(e)
        }
        for (const t of this.onGameEndCbs) t();
        this.doGameEndSteps()
    }
    async doGameEndSteps() {
        if (this.isDoingGameEndSteps) return;
        if (this.isDoingGameEndSteps = !0, uc().poki.isShowingRewardedBreak && (await uc().poki.waitForRewardedBreakFinish(), this.destructed)) return;
        this.fireSdkGameplayStartedChange();
        const t = this.flagScoreUi.getWinningTeam(),
            e = this.getMyPlayer(),
            i = e && e.teamId == t;
        i && uc().poki.happyTime(1);
        const n = i ? "victory" : "defeated";
        this.updateUiVisible(), uc().mainMenu.hideUi || this.gameOverNotificationsUi.showIcon(`img/notificationIcons/gameOver/${n}.svg`), uc().sfx.playSound("gameEnd/" + (i ? "win" : "lose")), this.gameEndMyTotalScore = 0, e && (this.gameEndMyTotalScore = e.scoreTotal);
        const s = i ? this.gameEndTitleDurationWin : this.gameEndTitleDurationLose,
            r = this.createGameEndWaitTimer(this.gameEndLoweringTimeScaleDuration + s, "title"),
            o = this.createGameEndWaitTimer(this.gameEndPlayersListDuration, "playerlist");
        if (this.gameEndStatsShowTimer = this.createGameEndWaitTimer(0, "stats"), this.gameEndAdBreakTimer = this.createGameEndWaitTimer(10, "adbreak"), this.updateGameEndShowStatsScreen(), r.start(), await ra.promise(1e3 * this.gameEndLoweringTimeScaleDuration), !this.destructed && (uc().physics.startLoweringTimeScale(), await ra.promise(1e3 * s), !this.destructed && (this.currentGameEndWaitingMusic || (this.currentGameEndWaitingMusic = await uc().sfx.playSound("music/waiting")), r.clear(), this.playersListDialog.showTeamWonTitle(t), this.playersListDialog.visible = !0, this.playersListDialog.skipText.setVisibility(!0), this.playersListDialog.skipText.startTimer(this.gameEndPlayersListDuration), this.playersListDialog.skipText.startCreationCooldown(), uc().adBanners.setPageVisibility("gameEnd", !0), uc().input.unlockPointer(), o.start(), await this.playersListDialog.skipText.waitForSkip(), !this.destructed))) {
            if (o.clear(), this.playersListDialog.visible = !1, this.gameEndShowStatsScreen) {
                let t = 0;
                if (e && (t = e.teamId), this.gameOverStatsDialog = new Ph({
                    trackedMyPlayerScores: this.trackedMyPlayerScores,
                    totalScore: this.gameEndMyTotalScore,
                    myTeamId: t,
                    receivedCoins: this.gameEndReceivedCoins
                }), this.gameOverStatsDialog.onRewardedAdIsPlayingChange((t => {
                    t ? (this.gameEndTimerSuddenChangeDisabled = !0, this.gameEndStatsShowTimer && this.gameEndStatsShowTimer.clear(), this.gameEndRewardedAdTimer || (this.gameEndRewardedAdTimer = this.createGameEndWaitTimer(this.gameEndRewardedAdDuration, "rewarded ad"), this.gameEndRewardedAdTimer.start()), this.gameEndStatsAfterRewardedAdTimer || (this.gameEndStatsAfterRewardedAdTimer = this.createGameEndWaitTimer(this.gameEndShowStatsAfterRewardedDuration, "stats after rewarded")), this.gameEndAdBreakTimer && this.gameEndAdBreakTimer.clear(), this.gameEndTimerSuddenChangeDisabled = !1, this.fireEstimatedMaxGameEndWaitTimeSuddenChange()) : (this.gameEndRewardedAdTimer && (this.gameEndRewardedAdTimer.clear(), this.gameEndRewardedAdTimer = null), this.gameEndStatsAfterRewardedAdTimer && this.gameEndStatsAfterRewardedAdTimer.start())
                })), uc().dialogManager.addDialog(this.gameOverStatsDialog), this.gameOverStatsDialog.skipText.startTimer(this.gameEndShowStatsDuration), this.gameEndStatsShowTimer.start(), await this.gameOverStatsDialog.skipText.waitForSkip(), this.destructed) return;
                this.gameEndStatsShowTimer.clear()
            }
            this.closeGame()
        }
    }
    estimateMaxGameEndWaitTimeSeconds() {
        if (!this.gameEnded) return 300;
        let t = 0;
        for (const e of this.gameEndWaitTimers) t += e.timeRemaining;
        return t
    }
    createGameEndWaitTimer(t = 0, e = "") {
        const i = new Th(t, e);
        return i.onSuddenChange((() => {
            this.gameEndTimerSuddenChangeDisabled || this.fireEstimatedMaxGameEndWaitTimeSuddenChange()
        })), this.gameEndWaitTimers.push(i), this.gameEndTimerSuddenChangeDisabled || this.fireEstimatedMaxGameEndWaitTimeSuddenChange(), i
    }
    onEstimatedMaxGameEndWaitTimeSuddenChange(t) {
        this.onEstimatedMaxGameEndWaitTimeSuddenChangeCbs.add(t)
    }
    fireEstimatedMaxGameEndWaitTimeSuddenChange() {
        this.onEstimatedMaxGameEndWaitTimeSuddenChangeCbs.forEach((t => t()))
    }
    onGameEnd(t) {
        this.onGameEndCbs.add(t)
    }
    closeGame(t = !0) {
        uc().network.closeCurrentConnection(t), this.onGameCloseCbs.forEach((t => t()))
    }
    onGameClose(t) {
        this.onGameCloseCbs.add(t)
    }
    onPlayerListDown() {
        this.gameEnded || (this.playersListDialog.visible = !0)
    }
    onPlayerListUp() {
        this.gameEnded || (this.playersListDialog.visible = !1)
    }
    updateUiVisible() {
        const t = !uc().mainMenu.visible && !this.gameEnded && !uc().mainMenu.hideUi;
        this.setUiVisible(t), uc().hudIcons.setGlobalVisibility(t)
    }
    setUiVisible(t) {
        this.uiVisible = t, this.healthUi.setVisible(t), this.bottomText.setVisible(t), this.flagScoreUi.setVisible(t), this.crosshair.setVisible(t), t || (this.cornerNotificationsUi.removeIcon(), this.crosshairNotificationsUi.removeIcon(), this.scoreOffsetNotificationsUi.removeAll())
    }
}
class Lh {
    constructor() {
        this.currentGame = null, this.joinedOnce = !1, this.isInGamesLoop = !1, this.onIsInGamesLoopChangeCbs = new Set, this.onCurrentGameChangeCbs = new Set, this.readyToJoin = !1, this.onReadyToJoinChangeCbs = new Set, this.onGameEndCbs = new Set, this.windSfx = null, this.waterSfx = null, this.birdsSfx = null, this.jungleSfx = null, this.rainSfx = null
    }
    async init() {
        this.loadWindSfx(), this.loadWaterSfx(), this.loadBirdsSfx(), this.loadJungleSfx(), this.loadRainSfx(), uc().mainMenu.setJoinState("loading"), uc().poki.gameLoadingStart(), await uc().network.waitForInit(), await this.prepareMatchMaking(), this.setReadyToJoin(!0), uc().mainMenu.setJoinState("joinable"), uc().poki.gameLoadingFinished()
    }
    async loadWindSfx() {
        this.windSfx = await uc().sfx.playSound("ambient/wind")
    }
    async loadWaterSfx() {
        this.waterSfx = await uc().sfx.playSound("ambient/water")
    }
    async loadBirdsSfx() {
        this.birdsSfx = await uc().sfx.playSound("ambient/birds")
    }
    async loadJungleSfx() {
        this.jungleSfx = await uc().sfx.playSound("ambient/jungle")
    }
    async loadRainSfx() {
        this.rainSfx = await uc().sfx.playSound("ambient/rain")
    }
    setAmbientVolumes(t, e, i, n, s) {
        this.waterSfx && this.waterSfx.setVolume(e), this.windSfx && this.windSfx.setVolume(t), this.birdsSfx && this.birdsSfx.setVolume(i), this.jungleSfx && this.jungleSfx.setVolume(n), this.rainSfx && this.rainSfx.setVolume(s)
    }
    onCurrentGameChange(t) {
        this.onCurrentGameChangeCbs.add(t)
    }
    removeOnCurrentGameChange(t) {
        this.onCurrentGameChangeCbs.delete(t)
    }
    fireCurrentGameChangeCbs() {
        this.onCurrentGameChangeCbs.forEach((t => t(this.currentGame)))
    }
    onIsInGamesLoopChange(t) {
        this.onIsInGamesLoopChangeCbs.add(t)
    }
    setIsInGamesLoop(t) {
        this.isInGamesLoop != t && (this.isInGamesLoop = t, this.onIsInGamesLoopChangeCbs.forEach((e => e(t))))
    }
    loop(t, e) {
        this.currentGame && this.currentGame.loop(t, e)
    }
    afterPhysicsLoop(t, e) {
        this.currentGame && this.currentGame.afterPhysicsLoop(t, e)
    }
    async prepareMatchMaking(t = !1, e = !1) {
        if ((!e || uc().network.matchMaking.isInUnreadyQueue) && uc().network.shouldUseMatchMaking && (await uc().network.matchMaking.initConnection(), t)) {
            if (e && !uc().network.matchMaking.isInUnreadyQueue) return;
            await uc().network.matchMaking.updateQueueState({
                isReadyToJoin: !1,
                maxWaitTimeMs: this.estimateMaxWaitTimeSeconds()
            })
        }
    }
    joinedGameId(t) {
        this.currentGame && (this.currentGame.destructor(), this.updateSdkGameplayStarted());
        const e = new Ah;
        this.currentGame = e, this.updateSdkGameplayStarted(), this.currentGame.onGameEnd((() => {
            this.prepareMatchMaking(!0);
            for (const t of this.onGameEndCbs) t()
        })), this.currentGame.onGameClose((() => {
            e.destructor(), this.currentGame == e && (this.destroyCurrentGame(), uc().input.unlockPointer(), this.joinGameAfterAd())
        })), this.currentGame.onSdkGameplayStartedChange((() => {
            this.updateSdkGameplayStarted()
        })), this.currentGame.onEstimatedMaxGameEndWaitTimeSuddenChange((() => {
            this.prepareMatchMaking(!0, !0)
        })), this.currentGame.onGameSeedChange((t => {
            uc().mapLoader.mapVariablesManager.setSeed(t)
        })), this.fireCurrentGameChangeCbs()
    }
    closeCurrentGameMidGame() {
        uc().network.closeCurrentConnection(), this.destroyCurrentGame()
    }
    onGameEnd(t) {
        this.onGameEndCbs.add(t)
    }
    setJoinedOnce() {
        this.joinedOnce = !0, this.setIsInGamesLoop(!0)
    }
    connectionClosed() {
        this.currentGame && (this.currentGame.gameEnded || (this.destroyCurrentGame(), this.setIsInGamesLoop(!1))), this.setReadyToJoin(!0)
    }
    destroyCurrentGame() {
        this.currentGame && this.currentGame.destructor(), this.currentGame = null, this.updateSdkGameplayStarted(), this.fireCurrentGameChangeCbs(), uc().mainMenu.setJoinState("joinable")
    }
    async checkExistingGameAndJoin() {
        const t = uc();
        if (t.mainMenu.webglCreationFailed) return !1;
        const e = t.network.squadManager;
        if (e.isJoiningSquad) return !1;
        if (e.isInSquad) return t.dialogManager.showAlert({
            title: "You are currently in a squad",
            text: "Joining maps while in a squad is not supported."
        }), !1;
        if (this.currentGame) {
            const e = t.dialogManager.showAlert({
                title: "You are currently in a game",
                text: "Do you want to leave the current match?",
                buttons: [{
                    text: "Yes"
                }, {
                    text: "No"
                }]
            });
            if (0 != await e.waitForButton()) return !1;
            this.closeCurrentGameMidGame()
        }
        return await this.joinGameAfterAd(), !0
    }
    joinGameWithoutAd() {
        this.readyToJoin && (this.setReadyToJoin(!1), uc().network.prepareJoinGame())
    }
    async joinGameAfterAd() {
        this.readyToJoin && (this.setReadyToJoin(!1), uc().input.unlockPointer(), await uc().poki.commercialBreak(), uc().input.lockPointer(), await uc().network.prepareJoinGame())
    }
    estimateMaxWaitTimeSeconds() {
        let t = 0;
        return this.currentGame ? t += this.currentGame.estimateMaxGameEndWaitTimeSeconds() : t = 10, 1e3 * t
    }
    updateSdkGameplayStarted() {
        !uc().mainMenu.visible && this.currentGame && this.currentGame.sdkGameplayStarted ? uc().poki.gameplayStart() : uc().poki.gameplayStop()
    }
    onReadyToJoinChange(t) {
        this.onReadyToJoinChangeCbs.add(t)
    }
    removeOnReadyToJoinChange(t) {
        this.onReadyToJoinChangeCbs.delete(t)
    }
    setReadyToJoin(t) {
        this.readyToJoin = t, this.onReadyToJoinChangeCbs.forEach((e => e(t)))
    }
}
class kh extends jl {
    constructor(...t) {
        super(...t), this.radius = this.worldMatrix.getMaxScaleOnAxis(), this.pos = new w, this.pos.setFromMatrixPosition(this.worldMatrix);
        const e = this.pos.clone().subScalar(this.radius),
            i = this.pos.clone().addScalar(this.radius);
        this.aabb = new S(e, i)
    }
    getSphereManifold(t, e) {
        const i = t.clone().sub(this.pos),
            n = -i.length() + this.radius + e,
            s = i.normalize();
        return {
            colliderType: "sphere",
            pos: this.pos.clone().add(s.clone().multiplyScalar(this.radius)),
            normal: s,
            penetration: n
        }
    }
    rayCast(t, e) {
        const i = this.pos.clone().sub(t),
            n = i.length();
        if (n < this.radius) return {
            dist: 0,
            pos: t.clone(),
            collider: this
        };
        const s = i.clone().projectOnVector(e);
        if (s.dot(e) < 0) return null;
        const r = s.length(),
            o = Math.sqrt(n ** 2 - r ** 2);
        if (o > this.radius) return null;
        const a = r - Math.sqrt(this.radius ** 2 - o ** 2),
            l = e.clone();
        l.setLength(a);
        return {
            pos: t.clone().add(l),
            dist: a,
            collider: this
        }
    }
}
class Ih {
    constructor(t, e = 0) {
        this.aabb = t, this.depth = e, this.items = [], this.allChildren = [], this.children = new Set
    }
    addItems(t) {
        for (const e of t) this.items.push(e)
    }
    subdivideRecursive({
                           boundsContainsCb: t,
                           maxDepth: e,
                           itemCountDivideLimit: i
                       }) {
        if (!(this.depth >= e || this.items.length <= i)) {
            this.subdivide();
            for (const n of this.children) {
                for (const e of this.items) t(e, n.aabb) && n.addItems([e]);
                n.items.length <= 0 ? this.children.delete(n) : n.subdivideRecursive({
                    boundsContainsCb: t,
                    maxDepth: e,
                    itemCountDivideLimit: i
                })
            }
            this.items = []
        }
    }
    subdivide() {
        const t = this.aabb.min,
            e = this.aabb.max,
            i = this.aabb.getCenter(new w);
        for (let n = 0; n < 8; n++) {
            const s = new S;
            n % 2 < 1 ? (s.min.x = t.x, s.max.x = i.x) : (s.min.x = i.x, s.max.x = e.x), n % 4 < 2 ? (s.min.y = t.y, s.max.y = i.y) : (s.min.y = i.y, s.max.y = e.y), n < 4 ? (s.min.z = t.z, s.max.z = i.z) : (s.min.z = i.z, s.max.z = e.z);
            const r = new Ih(s, this.depth + 1);
            this.children.add(r), this.allChildren[n] = r
        }
    }* traverseDown(t = (() => !0)) {
        if (t(this)) {
            yield this;
            for (const e of this.children)
                for (const i of e.traverseDown(t)) yield i
        }
    }* findEndNodes(t = (() => !0)) {
        for (const e of this.traverseDown(t)) 0 != e.items.length && (yield e)
    }
}
class Rh {
    constructor() {
        this.rigidBodies = new Set, this.mapColliders = [], this.rootOctreeNode = null, this.octreeMaxDepth = 5, this.mapBounds = null, this.octreeAxisVoxelCount = 0, this.worldToOctreeVoxelSpaceMultiplier = new w, this.isLoweringTimeScale = !1, this.timeScale = 1, this.stepCount = 10
    }
    init() {}
    loop(t, e) {
        this.isLoweringTimeScale && (this.timeScale -= 3e-4 * e, this.timeScale < .01 && (this.timeScale = .01, this.isLoweringTimeScale = !1));
        for (const t of this.rigidBodies) t.enabled && t.beginPhysicsSteps();
        const i = e * this.timeScale / 1e3 / this.stepCount;
        for (let t = 0; t < this.stepCount; t++) {
            for (const t of this.rigidBodies) t.enabled && t.stepVelocity(i);
            for (const t of this.rigidBodies) t.enabled && t.resolveMapCollisionsOctree(i)
        }
        for (const t of this.rigidBodies) t.enabled && t.endPhysicsSteps()
    }
    startLoweringTimeScale() {
        this.isLoweringTimeScale = !0
    }
    resetTimeScale() {
        this.isLoweringTimeScale = !1, this.timeScale = 1
    }
    registerRigidBody(t) {
        return this.rigidBodies.add(t), t
    }
    removeRigidBody(t) {
        this.rigidBodies.delete(t)
    }
    addMapCollider(t, e, i) {
        const n = (new $).fromArray(e);
        let s;
        return s = "sphere" == t ? new kh(n, i) : new Ql(n, i), this.mapColliders.push(s), s
    }
    removeMapColliders() {
        this.mapColliders = [], this.rootOctreeNode = null
    }
    buildOctree() {
        if (this.mapColliders.length <= 0) return;
        const t = new S;
        for (const e of this.mapColliders) e.aabb && (t.expandByPoint(e.aabb.min), t.expandByPoint(e.aabb.max));
        this.mapBounds = t, this.octreeAxisVoxelCount = Math.pow(2, this.octreeMaxDepth);
        const e = t.getSize(new w);
        this.worldToOctreeVoxelSpaceMultiplier.set(1, 1, 1), this.worldToOctreeVoxelSpaceMultiplier.divide(e), this.worldToOctreeVoxelSpaceMultiplier.multiplyScalar(this.octreeAxisVoxelCount), this.rootOctreeNode = new Ih(t), this.rootOctreeNode.addItems(this.mapColliders), this.rootOctreeNode.subdivideRecursive({
            boundsContainsCb: (t, e) => !!t.aabb && t.aabb.intersectsBox(e),
            maxDepth: this.octreeMaxDepth,
            itemCountDivideLimit: 10
        })
    }
    getOctreeNodesInAabb(t, e = !0) {
        const i = new Set;
        if (!this.rootOctreeNode) return i;
        const n = this.worldToOctreeVoxelSpace(t.min),
            s = this.worldToOctreeVoxelSpace(t.max);
        for (let t = n[0]; t <= s[0]; t++)
            for (let r = n[1]; r <= s[1]; r++)
                for (let o = n[2]; o <= s[2]; o++) {
                    const n = this.octreeVoxelSpaceToNodePath([t, r, o]);
                    if (n) {
                        const t = this.getOctreeNodeForPath(n);
                        t && (t.items.length > 0 || !e) && i.add(t)
                    }
                }
        return i
    }
    getCollidersFromOctreeNodes(t) {
        const e = new Set;
        for (const i of t)
            for (const t of i.items) e.add(t);
        return e
    }
    getCollidersForAabbUsingOctree(t) {
        return this.getCollidersFromOctreeNodes(this.getOctreeNodesInAabb(t))
    }
    worldToOctreeVoxelSpace(t) {
        const e = t.clone();
        if (!this.mapBounds) throw new Error("Failed to convert coordinate, octree hasn't been built");
        return e.clamp(this.mapBounds.min, this.mapBounds.max), e.sub(this.mapBounds.min), e.multiply(this.worldToOctreeVoxelSpaceMultiplier), [Math.floor(e.x), Math.floor(e.y), Math.floor(e.z)]
    }
    octreeVoxelSpaceToNodePath(t) {
        const e = t[0],
            i = t[1],
            n = t[2];
        if (e < 0 || i < 0 || n < 0 || e > this.octreeAxisVoxelCount - 1 || i > this.octreeAxisVoxelCount - 1 || n > this.octreeAxisVoxelCount - 1) return null;
        let s = this.octreeAxisVoxelCount,
            r = this.octreeAxisVoxelCount,
            o = this.octreeAxisVoxelCount;
        const a = [];
        for (let t = 0; t < this.octreeMaxDepth; t++) {
            const t = s >> 1,
                l = r >> 1,
                h = o >> 1;
            let c = 0;
            e % s >= t && (c += 1), i % r >= l && (c += 2), n % o >= h && (c += 4), a.push(c), s = t, r = l, o = h
        }
        return a
    }
    getOctreeNodeForPath(t) {
        let e = this.rootOctreeNode;
        for (const i of t) {
            if (!e) return null;
            if (e.allChildren.length <= 0) return e;
            e = e.allChildren[i]
        }
        return e
    }* getColliders() {
        for (const t of this.mapColliders) yield t;
        for (const t of this.getPlayerColliders()) yield t
    }* getPlayerColliders() {
        for (const t of this.rigidBodies)
            if (t instanceof eh)
                for (const e of t.colliders) yield e
    }
    getRayCastCache(t, e, i) {
        const n = i.clone().sub(e);
        if (n.setLength(1), 0 == n.length()) return null;
        const s = new S;
        s.expandByPoint(e), s.expandByPoint(i);
        const r = this.getOctreeNodesInAabb(s);
        return {
            createTime: t,
            from: e.clone(),
            to: i.clone(),
            dir: n,
            length: e.distanceTo(i),
            octreeNodes: r
        }
    }
    rayCastMapColliders(t, e = null) {
        return this.rayCastHelper(t, this.getCollidersFromOctreeNodes(t.octreeNodes), e)
    }
    rayCastPlayerColliders(t, e = null) {
        return this.rayCastHelper(t, this.getPlayerColliders(), e)
    }
    rayCastHelper(t, e, i = null) {
        let n = null;
        for (const s of e) {
            const e = s.rayCast(t.from, t.dir);
            if (e && e.dist < t.length && (!n || e.dist < n.dist)) {
                const t = e;
                if (i && !i(t)) continue;
                n = t
            }
        }
        return n
    }
}
class Dh {
    constructor() {
        this.baseFov = 90, this.cam = new Re(65, 1, .08, 900), this.cam.name = "cam", this.cam.updateMatrixWorld(), this.isDoingLobbyShots = !1, this.prevHasPlayer = !1, this.lobbyCamPositions = null, this.hasDoneFirstLobbyShot = !1, this.currentLobbyShot = null, this.currentLobbyShotT = 0, this.currentLobbyShotDuration = 5e3, ea.addListener((() => {
            this.onResize()
        })), this.onResize()
    }
    init() {
        uc().scene.add(this.cam), uc().settingsManager.onValueChange("fov", (t => {
            this.baseFov = t
        }))
    }
    onResize() {
        this.cam.aspect = window.innerWidth / window.innerHeight, this.cam.updateProjectionMatrix()
    }
    loop(t, e) {
        let i = null;
        const n = uc();
        n.gameManager.currentGame && (i = n.gameManager.currentGame.getMyPlayer());
        let s = !1;
        const r = !!i;
        if (r != this.prevHasPlayer && (this.prevHasPlayer = r, r || (this.cam.fov = 65, this.cam.updateProjectionMatrix())), r && i) {
            this.cam.position.copy(i.getCamPos()), this.cam.quaternion.copy(i.getCamRot());
            let t, e = 0,
                n = null,
                s = 0;
            i.weapon && (e = i.weapon.fireAmount01, n = i.weapon.absoluteFov, s = i.getStatClassValue("shootingFocus")), t = la(this.baseFov, null != n ? n : this.baseFov - la(10, 30, s), e), this.cam.fov = la(this.cam.fov, t, .1), this.cam.updateProjectionMatrix(), this.cam.updateMatrixWorld()
        } else if (this.lobbyCamPositions && (s = !0, n.renderer.needsRenderFrame)) {
            if (this.currentLobbyShotT += e / this.currentLobbyShotDuration, this.currentLobbyShotT > 1 || !this.currentLobbyShot) {
                if (this.currentLobbyShotT = 0, this.hasDoneFirstLobbyShot) {
                    const t = this.lobbyCamPositions.filter((t => t != this.currentLobbyShot));
                    this.currentLobbyShot = fa(t)
                } else this.hasDoneFirstLobbyShot = !0, this.currentLobbyShot = this.lobbyCamPositions[0];
                this.computeLobbyShotDuration()
            }
            if (this.currentLobbyShot) {
                const t = this.currentLobbyShot,
                    e = this.currentLobbyShotT;
                this.cam.position.lerpVectors(t.posA, t.posB, e), this.cam.quaternion.slerpQuaternions(t.rotA, t.rotB, e), this.cam.updateMatrixWorld()
            }
        }
        s != this.isDoingLobbyShots && (this.isDoingLobbyShots = s, uc().renderer.updateMainCanvasRenderEnabled())
    }
    computeLobbyShotDuration() {
        if (!this.currentLobbyShot) return 1e4;
        const t = this.currentLobbyShot.posA.distanceTo(this.currentLobbyShot.posB);
        this.currentLobbyShotDuration = 5e3 * t
    }
    playerRespawned() {
        this.cam.fov = this.baseFov + 20
    }
    get fov() {
        return this.cam.fov
    }
    get fovOffset() {
        return this.baseFov - this.fov
    }
    get rot() {
        return this.cam.quaternion
    }
    get pos() {
        return this.cam.position
    }
    setLobbyCamPositions(t) {
        this.lobbyCamPositions = t, this.currentLobbyShot = null
    }
}
class Oh {
    constructor(t, {
        size: e = .05,
        url: i = null
    } = {}) {
        this.manager = t, this.size = e, this.visible = !0, this.texture = null, this.mat = t.mat.clone(), this.obj = new _e(t.geo, this.mat), this.obj.renderOrder = 1, this.obj.frustumCulled = !1, uc().scene.add(this.obj), this.updateIconSize(window.innerHeight, window.innerWidth), this.setUrl(i)
    }
    destructor() {
        this.disposeTexture(), this.mat.dispose(), uc().scene.remove(this.obj)
    }
    updateIconSize(t, e) {
        this.mat.uniforms.iconSize.value.set(t / e * this.size, this.size)
    }
    setPos(t) {
        this.obj.position.copy(t), this.obj.updateWorldMatrix(!1, !0)
    }
    setVisibility(t) {
        this.visible = t, this.updateVisibility()
    }
    updateVisibility() {
        this.obj.visible = this.visible && this.manager.globalVisibility
    }
    disposeTexture() {
        this.texture && (this.texture.dispose(), this.texture = null, this.mat && (this.mat.uniforms.map.value = null))
    }
    setUrl(t) {
        this.disposeTexture();
        const e = new Image;
        e.src = t, e.width = 512, e.height = 512, this.texture = new m(e), this.texture.minFilter = 1003, this.texture.magFilter = 1003, this.mat.uniforms.map.value = this.texture, e.onload = t => {
            this.texture && e == this.texture.image && (this.texture.needsUpdate = !0)
        }
    }
}
class Fh {
    constructor() {
        this.globalVisibility = !0, this.geo = new Ge, this.mat = new ke({
            name: "hudIcon",
            vertexShader: "\n\t\t\t\tuniform vec2 iconSize;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main(){\n\t\t\t\t\tvec4 objPos = modelMatrix[3];\n\t\t\t\t\tgl_Position = (projectionMatrix * viewMatrix) * vec4(objPos.xyz, 1.0);\n\t\t\t\t\tgl_Position /= gl_Position.w;\n\t\t\t\t\tgl_Position.xy += position.xy * iconSize * 2.0;\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t}\n\t\t\t",
            fragmentShader: "\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main(){\n\t\t\t\t\tgl_FragColor = texture2D(map, vUv);\n\t\t\t\t}\n\t\t\t",
            side: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0,
            uniforms: {
                map: {
                    value: null
                },
                iconSize: {
                    value: new h(1, 1)
                }
            }
        }), this.createdIcons = new Set, ea.addListener((t => {
            this.onResize()
        })), this.onResize()
    }
    onResize() {
        for (const t of this.createdIcons) t.updateIconSize(window.innerHeight, window.innerWidth)
    }
    createIcon(t) {
        const e = new Oh(this, t);
        return this.createdIcons.add(e), e
    }
    setGlobalVisibility(t) {
        this.globalVisibility = t;
        for (const t of this.createdIcons) t.updateVisibility()
    }
}
class Nh {
    constructor(t, e, i, n) {
        this.scene = t, this.material = e.clone(), this.material.uniforms.vignetteAmount.value = i, this.material.uniforms.theta.value = n;
        const s = new Ge(2, 2);
        this.obj = new _e(s, this.material), this.obj.frustumCulled = !1, t.add(this.obj), this.creationTime = uc().now, this.shouldBeDestroyed = !1
    }
    destructor() {
        this.scene.remove(this.obj), this.material.dispose()
    }
    loop(t) {
        const e = (t - this.creationTime) / 1e3;
        this.material.uniforms.opacity.value = Math.max(0, .1 / (e + .1)), e > 10 && (this.shouldBeDestroyed = !0)
    }
}
class Bh {
    constructor(t, e) {
        this.scene = t, this.camera = e, this.material = null, this.createdFlashes = new Set
    }
    setMaterial(t) {
        this.material = t
    }
    flash(t, e) {
        if (!this.material) return;
        const i = this.getThetaFromArrowHitNormal(t),
            n = new Nh(this.scene, this.material, 1 - e, i);
        this.createdFlashes.add(n)
    }
    getThetaFromArrowHitNormal(t) {
        if (!t) return 0;
        const e = new w(0, 0, -1);
        if (e.applyQuaternion(this.camera.quaternion), e.y = 0, e.length() <= 1e-4) return 0;
        const i = t.clone();
        if (i.y = 0, i.length() <= 1e-4) return 0;
        const n = new w;
        n.crossVectors(e, i);
        const s = e.dot(i);
        let r = Math.acos(s);
        return n.y > 0 && (r *= -1), aa(r, 2 * Math.PI) - Math.PI
    }
    loop(t) {
        const e = new Set;
        for (const i of this.createdFlashes) i.loop(t), i.shouldBeDestroyed && e.add(i);
        for (const t of e) t.destructor(), this.createdFlashes.delete(t)
    }
}
class Vh {
    constructor({
                    width: t = 100,
                    height: e = 100
                } = {}) {
        this.dirty = !1, this.alwaysDirty = !1, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.width = t, this.height = e, this.onNextFrameRenderCbs = new Set, this.scene = null, this.cam = null, this.setSize(t, e)
    }
    setSize(t, e) {
        this.canvas.width = t, this.canvas.height = e, this.width = t, this.height = e
    }
    setRenderObjects(t, e, i = !0) {
        this.scene = t, this.cam = e, i && this.markDirty()
    }
    markDirty() {
        this.dirty = !0
    }
    get needsRender() {
        return this.dirty || this.alwaysDirty
    }
    render(t, e, i) {
        this.needsRender && (this.dirty = !1, this.scene && this.cam && this.ctx && (t.setClearAlpha(0), t.setViewport(0, i - this.canvas.height, this.canvas.width, this.canvas.height), t.render(this.scene, this.cam), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.drawImage(t.domElement, 0, 0), this.onNextFrameRenderCbs.forEach((t => t())), this.onNextFrameRenderCbs.clear()))
    }
    async waitForFrameRender() {
        const t = new Promise((t => this.onNextFrameRenderCbs.add(t)));
        await t
    }
    async getBlob() {
        const t = new Promise((t => {
            this.canvas.toBlob(t)
        }));
        return await t
    }
}
class Uh {
    constructor({
                    minFov: t = 0,
                    maxFov: e = 180,
                    near: i = .01,
                    far: n = 100
                } = {}) {
        this.scene = new ns, this.cam = new Re, this.cam.matrixAutoUpdate = !1, this.minFov = t, this.maxFov = e, this.near = i, this.far = n, this.enabled = !0
    }
    updateProjectionMatrix() {
        this.cam.near = this.near, this.cam.far = this.far;
        const t = uc().cam;
        this.cam.fov = da(t.fov, this.minFov, this.maxFov), this.cam.aspect = t.cam.aspect, this.cam.updateProjectionMatrix()
    }
}
class zh {
    constructor() {
        this.renderer = null, this.canvas = null, this.freezeFrameCanvas = null, this.freezeFrameCtx = null, this.freezeFrameDirty = !1, this.afterFrameRenderCbs = [], this.onBeforeRenderCbs = new Set, this.renderViews = new Set, this.renderOverlays = new Set, this.mainCanvasRenderEnabled = !0, this.lastRenderWorthyEventTime = 0, this.updateRenderWorthyTimer = new ra((() => this.updateMainCanvasRenderEnabled()), 1e3), this.queriedScreenshotCallbacks = [], this.renderWidth = 0, this.renderHeight = 0, this.resolutionMultiplier = 1
    }
    setResolutionQuality(t) {
        const e = this.resolutionMultiplier;
        if (this.resolutionMultiplier = 1, 1 == window.devicePixelRatio) switch (t) {
            case 0:
                this.resolutionMultiplier = .5;
                break;
            case 1:
                this.resolutionMultiplier = 1;
                break;
            case 2:
                this.resolutionMultiplier = 2
        } else {
            let e = 1;
            switch (t) {
                case 0:
                    e = .3333;
                    break;
                case 1:
                    e = .66666;
                    break;
                case 2:
                    e = 1
            }
            this.resolutionMultiplier = e * window.devicePixelRatio
        }
        e != this.resolutionMultiplier && this.onResize()
    }
    init() {
        const t = uc();
        try {
            this.renderer = new is({
                antialias: !0,
                powerPreference: "high-performance",
                alpha: !0
            })
        } catch (e) {
            try {
                this.renderer = new is({
                    antialias: !0,
                    alpha: !0
                })
            } catch (e) {
                try {
                    this.renderer = new is({
                        antialias: !1,
                        alpha: !0
                    })
                } catch (e) {
                    try {
                        this.renderer = new is
                    } catch (e) {
                        console.error("Failed to create WebGLRenderer:", e), t.mainMenu.notifyWebglCreationFailed()
                    }
                }
            }
        }
        this.renderer && (this.renderer.outputEncoding = 3001, this.renderer.autoClear = !1, this.canvas = this.renderer.domElement, this.canvas.classList.add("fullScreen", "mainCanvas"), this.canvas.inert = !0, document.body.appendChild(this.canvas)), t.dialogManager.onAnyDialogVisibilityChange((() => {
            this.updateMainCanvasRenderEnabled(), this.freezeFrameDirty = !0
        })), ea.addListener((() => {
            this.onResize()
        })), this.onResize()
    }
    onResize() {
        const t = this.resolutionMultiplier;
        this.setSize(window.innerWidth * t, window.innerHeight * t), this.freezeFrameDirty = !0, this.freezeFrameCanvas && this.canvas && (this.freezeFrameCanvas.width = this.canvas.width, this.freezeFrameCanvas.height = this.canvas.height)
    }
    setSize(t, e) {
        this.renderWidth = t, this.renderHeight = e, this.renderer && this.renderer.setSize(t, e, !1)
    }
    createRenderView(...t) {
        const e = new Vh(...t);
        return this.renderViews.add(e), e
    }
    removeRenderView(t) {
        this.renderViews.delete(t)
    }
    createRenderOverlay(...t) {
        const e = new Uh(...t);
        return this.renderOverlays.add(e), e
    }
    removeRenderOverlay(t) {
        this.renderOverlays.delete(t)
    }
    queryScreenshot() {
        return new Promise((t => {
            this.queriedScreenshotCallbacks.push(t)
        }))
    }
    loop(t, e) {
        this.renderCameras()
    }
    renderWorthyEventHappened(t = 1e3) {
        this.lastRenderWorthyEventTime = Math.max(this.lastRenderWorthyEventTime, performance.now() + t), this.updateMainCanvasRenderEnabled();
        const e = this.lastRenderWorthyEventTime - performance.now();
        this.updateRenderWorthyTimer.start(e + 500)
    }
    updateMainCanvasRenderEnabled() {
        let t = !1;
        const e = uc();
        if (e.cam.isDoingLobbyShots) {
            let i = !0;
            t = !e.dialogManager.hasAnyDialogs && i
        } else e.gameManager.currentGame && (t = this.lastRenderWorthyEventTime > performance.now());
        this.setMainCanvasRenderEnabled(t)
    }
    setMainCanvasRenderEnabled(t) {
        t != this.mainCanvasRenderEnabled && (this.mainCanvasRenderEnabled = t, t ? (this.freezeFrameCanvas && document.body.removeChild(this.freezeFrameCanvas), this.freezeFrameCanvas = null, this.freezeFrameCtx = null) : (this.freezeFrameCanvas = document.createElement("canvas"), this.freezeFrameCanvas.classList.add("fullScreen", "mainCanvas"), this.freezeFrameCanvas.inert = !0, this.canvas && (this.freezeFrameCanvas.width = this.canvas.width, this.freezeFrameCanvas.height = this.canvas.height), this.freezeFrameCtx = this.freezeFrameCanvas.getContext("2d"), document.body.appendChild(this.freezeFrameCanvas), this.freezeFrameDirty = !0), this.canvas && (this.canvas.style.display = t ? "" : "none"))
    }
    get needsRenderFrame() {
        return this.mainCanvasRenderEnabled || this.freezeFrameDirty
    }
    renderCameras() {
        if (this.renderer) {
            let t = 0,
                e = 0;
            for (const i of this.renderViews) i.needsRender && (t = Math.max(t, i.width), e = Math.max(e, i.height));
            t = Math.max(t, this.renderWidth), e = Math.max(e, this.renderHeight);
            let i = !1;
            const n = this.renderWidth,
                s = this.renderHeight;
            t == this.renderWidth && e == this.renderHeight || (this.setSize(t, e), i = !0);
            for (const t of this.renderViews) this.renderer.clear(), t.render(this.renderer, this.renderWidth, this.renderHeight);
            if (i && this.setSize(n, s), this.needsRenderFrame) {
                this.renderer.clear(), this.renderer.setViewport(0, 0, window.innerWidth * this.resolutionMultiplier, window.innerHeight * this.resolutionMultiplier), this.renderer.render(uc().scene, uc().cam.cam);
                const t = Array.from(this.renderOverlays).filter((t => t.enabled));
                if (t.length > 0) {
                    this.renderer.clearDepth();
                    for (const e of t) e.updateProjectionMatrix(), this.renderer.render(e.scene, e.cam)
                }
            }
            this.queriedScreenshotCallbacks.length > 0 && (async () => {
                const t = new Promise((t => {
                        if (!this.renderer) return null;
                        this.renderer.domElement.toBlob(t)
                    })),
                    e = await t;
                for (const t of this.queriedScreenshotCallbacks) t(e);
                this.queriedScreenshotCallbacks = []
            })()
        }
        this.freezeFrameDirty && this.freezeFrameCtx && this.freezeFrameCanvas && this.canvas && (this.freezeFrameDirty = !1, this.freezeFrameCtx.clearRect(0, 0, this.freezeFrameCanvas.width, this.freezeFrameCanvas.height), this.freezeFrameCtx.drawImage(this.canvas, 0, 0));
        for (let t = this.afterFrameRenderCbs.length - 1; t >= 0; t--) {
            const e = this.afterFrameRenderCbs[t];
            e.waitCount--, e.waitCount <= 0 && (e.cb(), this.afterFrameRenderCbs.splice(t, 1))
        }
    }
    async waitForFrameRender(t = 1) {
        return await new Promise((e => {
            this.afterFrameRenderCbs.push({
                cb: e,
                waitCount: t
            })
        }))
    }
}
class Hh {
    constructor() {
        this.cachedAssetPromises = new Map
    }
    getArrowAssetWithCache(t) {
        const e = this.cachedAssetPromises.get(t);
        if (e) return e;
        const i = this.getAsset(t);
        return this.cachedAssetPromises.set(t, i), i
    }
    async getAsset(t) {
        const e = await uc().assets.loadGlbViaWorker("arrow.glb", {
            teamId: t,
            packageName: "main",
            keepCustomProperties: []
        });
        if (!e) throw new Error("Failed to load arrow.glb");
        return e.name = "arrow", e
    }
}
class Gh {
    constructor() {
        this.cachedPoses = new Map, this.loadingPoseCbs = new Map
    }
    async getSkeleton(t, {
        clone: e = !1,
        signal: i = null
    } = {}) {
        let n = this.cachedPoses.get(t);
        if (!n) {
            let e = this.loadingPoseCbs.get(t);
            if (e) {
                const t = e,
                    i = new Promise((e => t.add(e)));
                n = await i
            } else {
                e = new Set, this.loadingPoseCbs.set(t, e);
                const s = await uc().assets.loadGlbViaWorker(`playerSkeletonPoses/${t}.glb`, {
                    merge: !1,
                    signal: i
                });
                if (!s) throw new Error(`Failed to load skeleton pose ${t}`);
                n = s, this.cachedPoses.set(t, n);
                for (const t of e) t(n);
                this.loadingPoseCbs.delete(t)
            }
        }
        return e ? n.clone() : n
    }
}
class Wh {
    constructor(t, e) {
        this.opts = t, this.ctx = e, this.loaded = !1, this.loading = !1, this.buffer = null, this.mediaElement = null, this.onLoadCbs = []
    }
    async init() {
        if (this.loaded) return;
        if (this.loading) return await new Promise((t => {
            this.onLoadCbs.push(t)
        }));
        this.loading = !0;
        const t = uc().assets.getPackage("sfx" + jh.audioFormatCamelCase);
        if (this.opts.useMediaElement) {
            const e = await t.getAsObjectUrl(this.opts.name + "." + jh.audioFormat, "audio/" + jh.audioFormat);
            this.mediaElement = document.createElement("audio"), this.mediaElement.src = e, this.mediaElement.loop = this.opts.loop
        } else {
            const e = await t.getFileAsBuffer(this.opts.name + "." + jh.audioFormat);
            this.buffer = await new Promise((t => {
                this.ctx.decodeAudioData(e, t)
            }))
        }
        this.loaded = !0;
        for (const t of this.onLoadCbs) t();
        this.onLoadCbs = []
    }
    async waitForLoad() {
        if (!this.loaded) return await new Promise((t => this.onLoadCbs.push(t)))
    }
    async getBuffer() {
        return await this.waitForLoad(), this.buffer
    }
    async getMediaElement() {
        return await this.waitForLoad(), this.mediaElement
    }
}
class qh {
    constructor(t, e = {}) {
        this.cachedSfx = t, this.opts = {
            autoPlay: !0,
            volume: 1,
            minPitch: 1,
            maxPitch: 1,
            volumeFront: 1,
            volumeBack: 0,
            isMusic: !1,
            loop: !1,
            useMediaElement: !1,
            allowWithoutUserEvent: !1,
            overrideMute: !1,
            pos: null,
            connectToDestination: !0,
            ...t.opts,
            ...e
        }, this.destructed = !1, this.sourceNode = null, this.gainNode = null, this.frontGainNode = null, this.frontSplitterNode = null, this.backGainNode = null, this.backSplitterNode = null, this.channelMergerNode = null, this.finalNode = null, this.pannerNode = null, this.preventDestructOnNextStop = !1, this.lastSetVolume = 0, this.isLoopPlaying = null, this.muted = !1, this.forceMuted = !1, this.playPromise = null, this.pitch = ga(this.opts.minPitch, this.opts.maxPitch)
    }
    destructor() {
        this.destructed = !0, this.cachedSfx = null, this.opts = null, this.sourceNode = null, this.gainNode = null, this.finalNode = null, this.pannerNode = null, uc().sfx.sfxDestructed(this)
    }
    async init() {
        return !uc().sfx.muted || this.opts.loop || this.opts.overrideMute ? (this.setVolume(this.opts.volume, !0), this.opts.autoPlay && await this.start(!0), this.setMuted(uc().sfx.muted), !0) : (this.destructor(), !1)
    }
    setVolume(t, e = !1) {
        this.lastSetVolume = t;
        t *= uc().settingsManager.getValue(this.opts.isMusic ? "musicVolume" : "sfxVolume") / 100, this.gainNode && (e ? this.gainNode.gain.value = t : this.gainNode.gain.linearRampToValueAtTime(t, uc().sfx.ctx.currentTime + .1))
    }
    volumeSettingChanged(t) {
        this.setVolume(this.lastSetVolume)
    }
    setMuted(t, e = !1) {
        if (this.muted = t, this.forceMuted = e, this.opts.overrideMute && !e && (t = !1), this.opts.loop)
            if (t) {
                const t = this.isLoopPlaying;
                this.pause(!0), this.isLoopPlaying = t
            } else this.isLoopPlaying && this.resume(!0);
        else t && this.stop()
    }
    async start(t = !1) {
        if (!this.sourceNode) {
            const e = uc().sfx.ctx;
            if (this.opts.useMediaElement) {
                const t = await this.cachedSfx.getMediaElement();
                this.sourceNode = e.createMediaElementSource(t)
            } else this.sourceNode = e.createBufferSource(), this.sourceNode.buffer = await this.cachedSfx.getBuffer(), this.sourceNode.loop = this.opts.loop;
            this.sourceNode.playbackRate.value = this.pitch, this.finalNode = this.sourceNode, this.gainNode = e.createGain(), this.finalNode.connect(this.gainNode), this.finalNode = this.gainNode, this.opts.pos && (this.pannerNode = e.createPanner(), this.pannerNode.panningModel = "HRTF", this.pannerNode.distanceModel = "inverse", this.pannerNode.refDistance = 1, this.pannerNode.maxDistance = 1e3, this.pannerNode.rolloffFactor = 1, this.pannerNode.positionX ? (this.pannerNode.positionX.value = this.opts.pos.x, this.pannerNode.positionY.value = this.opts.pos.y, this.pannerNode.positionZ.value = this.opts.pos.z) : this.pannerNode.setPosition(this.opts.pos.x, this.opts.pos.y, this.opts.pos.z), this.finalNode.connect(this.pannerNode), this.finalNode = this.pannerNode), e.destination.maxChannelCount >= 6 && (this.frontGainNode = e.createGain(), this.frontGainNode.gain.value = this.opts.volumeFront, this.finalNode.connect(this.frontGainNode), this.frontSplitterNode = e.createChannelSplitter(2), this.frontGainNode.connect(this.frontSplitterNode), this.backGainNode = e.createGain(), this.backGainNode.gain.value = this.opts.volumeBack, this.finalNode.connect(this.backGainNode), this.backSplitterNode = e.createChannelSplitter(2), this.backGainNode.connect(this.backSplitterNode), this.channelMergerNode = e.createChannelMerger(6), this.frontSplitterNode.connect(this.channelMergerNode, 0, 0), this.frontSplitterNode.connect(this.channelMergerNode, 1, 1), this.backSplitterNode.connect(this.channelMergerNode, 0, 4), this.backSplitterNode.connect(this.channelMergerNode, 1, 5), this.finalNode = this.channelMergerNode), this.opts.connectToDestination && this.finalNode.connect(e.destination);
            const i = t => {
                this.sourceNode && this.sourceNode.removeEventListener("ended", i), this.preventDestructOnNextStop || this.destructor(), this.preventDestructOnNextStop = !1
            };
            this.sourceNode.addEventListener("ended", i), this.setVolume(this.lastSetVolume, t), this.opts.useMediaElement ? this.sourceNode.mediaElement.play() : this.sourceNode.start(), !1 === this.isLoopPlaying && this.pause(!0)
        }
        this.opts.loop && (this.isLoopPlaying = !0)
    }
    stop(t = !0) {
        this.destructed || (this.preventDestructOnNextStop = !t, this.sourceNode && (this.opts.useMediaElement ? (this.sourceNode.mediaElement.stop(), this.sourceNode.mediaElement.fastSeek(0)) : this.sourceNode.stop(), this.sourceNode = null, this.opts.connectToDestination && this.finalNode.disconnect(uc().sfx.ctx.destination), this.finalNode = null), this.opts.loop && (this.isLoopPlaying = !1))
    }
    pause(t = !1) {
        this.isLoopPlaying = !1, this.sourceNode && (this.opts.useMediaElement ? this.pausePromise = (async t => {
            await this.playPromise, this.sourceNode.mediaElement.pause()
        })() : this.sourceNode.playbackRate.value = 1e-4)
    }
    resume(t = !1) {
        this.isLoopPlaying = !0, (!this.muted || !this.opts.loop || this.opts.overrideMute && !this.forceMuted || t) && this.sourceNode && (this.opts.useMediaElement ? this.playPromise = (async t => {
            await this.pausePromise, await this.sourceNode.mediaElement.play()
        })() : this.sourceNode.playbackRate.value = this.pitch)
    }
}
class jh {
    constructor() {
        if (window.AudioContext = window.AudioContext || window.webkitAudioContext, this.supported = !!AudioContext, this.supported && this.supported) {
            this.packageName = "sfx" + jh.audioFormatCamelCase, this.ctx = new AudioContext, this.ctx.destination.maxChannelCount >= 6 && (this.ctx.destination.channelCount = 6), this.cachedSfx = {}, this.createdSfx = [], this.settingsMuted = !0, this.adsMuted = !1, this.muted = !0, this.ctx.onstatechange = () => {
                this.onCtxStatechange()
            }, this.boundUserEvent = this.userEvent.bind(this), this.addedUserEventListeners = !1, this.onCtxStatechange(), this.soundsConfig = [{
                name: "weapon/bow/pull",
                volume: .04
            }, {
                name: "weapon/bow/pullHeavy",
                volume: .02
            }, {
                name: "weapon/bow/shoot",
                volume: .22
            }, {
                name: "weapon/bow/arrowReady",
                volume: .015
            }, {
                name: "weapon/largeBow/shoot",
                volume: .45
            }, {
                name: "weapon/largeCrossbow/shoot",
                volume: .45
            }, {
                name: "weapon/smallCrossbow/shoot",
                volume: .35
            }, {
                name: "weapon/bow/environmentImpact/1",
                volume: .42,
                minPitch: .8,
                maxPitch: 1.2
            }, {
                name: "weapon/bow/environmentImpact/2",
                volume: .42,
                minPitch: .8,
                maxPitch: 1.2
            }, {
                name: "weapon/bow/environmentImpact/3",
                volume: .42,
                minPitch: .8,
                maxPitch: 1.2
            }, {
                name: "gameEnd/win",
                volume: .4,
                isMusic: !0
            }, {
                name: "gameEnd/lose",
                volume: .4,
                isMusic: !0
            }, {
                name: "player/spawn",
                volume: .25
            }, {
                name: "player/takeDamage/male/1",
                volume: .15,
                minPitch: .8,
                maxPitch: 1.1
            }, {
                name: "player/takeDamage/male/2",
                volume: .15,
                minPitch: .8,
                maxPitch: 1.1
            }, {
                name: "player/takeDamage/male/3",
                volume: .15,
                minPitch: .8,
                maxPitch: 1.1
            }, {
                name: "player/takeDamage/female/1",
                volume: .02,
                minPitch: .9,
                maxPitch: 1.05
            }, {
                name: "player/takeDamage/female/2",
                volume: .02,
                minPitch: .9,
                maxPitch: 1.05
            }, {
                name: "player/takeDamage/female/3",
                volume: .02,
                minPitch: .9,
                maxPitch: 1.05
            }, {
                name: "player/walkL",
                volume: .032
            }, {
                name: "player/walkR",
                volume: .032
            }, {
                name: "player/jump/male/1",
                volume: .077,
                minPitch: .8,
                maxPitch: .9
            }, {
                name: "player/jump/male/2",
                volume: .077,
                minPitch: .9,
                maxPitch: 1.1
            }, {
                name: "player/jump/male/3",
                volume: .077,
                minPitch: .9,
                maxPitch: 1
            }, {
                name: "player/jump/female/1",
                volume: .03,
                minPitch: .9,
                maxPitch: 1.1
            }, {
                name: "player/jump/female/2",
                volume: .03,
                minPitch: .9,
                maxPitch: 1.1
            }, {
                name: "player/jump/female/3",
                volume: .03,
                minPitch: .9,
                maxPitch: 1.1
            }, {
                name: "player/land",
                volume: .22,
                minPitch: .9,
                maxPitch: 1
            }, {
                name: "player/fall",
                volume: .14
            }, {
                name: "feedback/hitPlayer",
                volume: .45,
                minPitch: .8,
                maxPitch: 1.1
            }, {
                name: "feedback/headShot",
                volume: .45,
                minPitch: .8,
                maxPitch: 1.1
            }, {
                name: "feedback/die",
                volume: .3
            }, {
                name: "feedback/kill",
                volume: .4
            }, {
                name: "feedback/healthRegen",
                volume: .002
            }, {
                name: "flag/grab",
                volume: .4
            }, {
                name: "flag/drop",
                volume: .4
            }, {
                name: "flag/positive",
                volume: .3
            }, {
                name: "flag/negative",
                volume: .3
            }, {
                name: "flag/positiveImportant",
                volume: .4
            }, {
                name: "flag/negativeImportant",
                volume: .4
            }, {
                name: "ui/coin/0",
                volume: .4
            }, {
                name: "ui/coin/1",
                volume: .4
            }, {
                name: "ui/coin/2",
                volume: .4
            }, {
                name: "ui/coin/3",
                volume: .4
            }, {
                name: "ui/coin/pile",
                volume: .4,
                minPitch: .8,
                maxPitch: 1.1
            }, {
                name: "ui/purchaseShopItem",
                volume: .3,
                minPitch: .95,
                maxPitch: 1.05
            }, {
                name: "music/mainMenu",
                volume: .1,
                loop: !0,
                isMusic: !0
            }, {
                name: "music/finalFlag",
                volume: .1,
                loop: !0,
                isMusic: !0
            }, {
                name: "music/waiting",
                volume: .1,
                loop: !0,
                isMusic: !0
            }, {
                name: "ambient/wind",
                volume: .01,
                loop: !0
            }, {
                name: "ambient/water",
                volume: 0,
                loop: !0
            }, {
                name: "ambient/birds",
                volume: 0,
                loop: !0
            }, {
                name: "ambient/jungle",
                volume: 0,
                loop: !0
            }, {
                name: "ambient/rain",
                volume: 0,
                loop: !0
            }];
            for (const t of this.soundsConfig) this.cachedSfx[t.name] = new Wh(t, this.ctx);
            this.ctxStatePossiblyInvalid = !1, document.addEventListener("visibilitychange", (t => {
                document.hidden ? this.ctx.suspend() : (this.ctxStatePossiblyInvalid = !0, window.setTimeout((t => this.ctx.resume()), 300))
            }), !1), this.setMutedSettings(!1)
        }
    }
    static get audioFormat() {
        if (!this._audioFormatSet) {
            const t = document.createElement("audio");
            t.canPlayType("audio/webm;codecs=opus") ? this._audioFormat = "webm" : t.canPlayType("audio/mp3") ? this._audioFormat = "mp3" : (this._audioFormat = null, this.supported = !1), this._audioFormatSet = !0
        }
        return this._audioFormat
    }
    static get audioFormatCamelCase() {
        const t = this.audioFormat;
        return t.charAt(0).toUpperCase() + t.substring(1)
    }
    init() {
        if (this.supported) {
            this.downloadPackage();
            for (const [t, e] of Object.entries(this.cachedSfx)) e.init();
            uc().settingsManager.onValueChange("musicVolume", (t => {
                for (const e of this.createdSfx) e.opts.isMusic && e.volumeSettingChanged(t)
            })), uc().settingsManager.onValueChange("sfxVolume", (t => {
                for (const e of this.createdSfx) e.opts.isMusic || e.volumeSettingChanged(t)
            }))
        }
    }
    async downloadPackage() {
        const t = uc().assets.addPackage(this.packageName, {
            manualDownload: !0
        });
        await uc().mapLoader.waitForFirstMapDownload(), t.startDownloading()
    }
    loop(t, e) {
        if (this.supported && "running" == this.ctx.state && this.ctx.listener) {
            const t = uc().cam.pos,
                e = uc().cam.rot;
            this.ctx.listener.positionX ? (this.ctx.listener.positionX.value = t.x, this.ctx.listener.positionY.value = t.y, this.ctx.listener.positionZ.value = t.z) : this.ctx.listener.setPosition(t.x, t.y, t.z);
            const i = new w(0, 0, -1);
            i.applyQuaternion(e);
            const n = new w(0, 1, 0);
            n.applyQuaternion(e), this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.value = i.x, this.ctx.listener.forwardY.value = i.y, this.ctx.listener.forwardZ.value = i.z, this.ctx.listener.upX.value = n.x, this.ctx.listener.upY.value = n.y, this.ctx.listener.upZ.value = n.z) : this.ctx.listener.setOrientation(i.x, i.y, i.z, n.x, n.y, n.z)
        }
    }
    onCtxStatechange() {
        this.supported && ("running" != this.ctx.state || this.ctxStatePossiblyInvalid ? this.addUserEventListeners() : this.removeUserEventListeners())
    }
    addUserEventListeners() {
        this.supported && (this.addedUserEventListeners || (window.addEventListener("touchstart", this.boundUserEvent), window.addEventListener("touchend", this.boundUserEvent), window.addEventListener("click", this.boundUserEvent), window.addEventListener("keydown", this.boundUserEvent), this.addedUserEventListeners = !0))
    }
    removeUserEventListeners() {
        this.supported && this.addedUserEventListeners && (window.removeEventListener("touchstart", this.boundUserEvent), window.removeEventListener("touchend", this.boundUserEvent), window.removeEventListener("click", this.boundUserEvent), window.removeEventListener("keydown", this.boundUserEvent), this.addedUserEventListeners = !1)
    }
    async userEvent() {
        this.supported && (this.ctxStatePossiblyInvalid && await this.ctx.suspend(), await this.ctx.resume(), this.ctxStatePossiblyInvalid = !1)
    }
    async playSound(t, e) {
        const i = this.cachedSfx[t];
        if (!i) return void console.warn("attempted to play sound " + t + " but it doesn't exist");
        const n = new qh(i, e);
        return await n.init() ? (this.createdSfx.push(n), n) : null
    }
    setMutedSettings(t) {
        this.settingsMuted = t, this.updateMuted()
    }
    setMutedAds(t) {
        this.adsMuted = t, this.updateMuted()
    }
    updateMuted() {
        this.muted = this.settingsMuted || this.adsMuted;
        for (let t = this.createdSfx.length - 1; t >= 0; t--) this.createdSfx[t].setMuted(this.muted, this.adsMuted)
    }
    sfxDestructed(t) {
        const e = this.createdSfx.indexOf(t);
        e >= 0 && this.createdSfx.splice(e, 1)
    }
}
class Yh extends Ma {
    constructor(t = "login") {
        super({
            title: "login" == t ? "Log in and keep your loot safe!" : "Link new account"
        }), this.type = t, this.didClickAnyButton = !1, this.oAuthLoginFinished = !1, this.onAuthLoginResult = null, this.onOAuthLoginFinishCbs = new Set;
        const e = document.createElement("div");
        if (e.classList.add("dialog-art-buttons-container"), this.el.appendChild(e), "linknew" == t) {
            const t = document.createElement("p");
            t.textContent = "Link a new account to your current one so you have multiple ways to log in.", e.appendChild(t)
        }
        if ("login" == t) {
            const t = document.createElement("div");
            t.classList.add("dialog-art-wrapper"), e.appendChild(t);
            const i = document.createElement("picture");
            t.appendChild(i);
            const n = [{
                type: "image/avif",
                src: "img/loginUI/art.avif"
            }, {
                type: "image/webp",
                src: "img/loginUI/art.webp"
            }, {
                type: "image/png",
                src: "img/loginUI/art.png"
            }];
            for (const t of n) {
                let e = null;
                t === n[n.length - 1] ? (e = document.createElement("img"), e.src = t.src, e.classList.add("dialog-art")) : (e = document.createElement("source"), e.type = t.type, e.srcset = t.src), i.appendChild(e)
            }
        }
        this.addButtonsContainer({
            vertical: !0,
            parent: e
        }), this.loginButtons = [];
        for (const [t, e] of uc().auth.oAuthProviderConfigs) {
            const i = this.addButton({
                text: e.loginButtonText,
                icon: e.loginButtonIcon,
                onClick: () => {
                    this.didClickAnyButton = !0, this.setButtonsEnabled(!1), this.handleOAuthLogin(t)
                }
            });
            this.loginButtons.push(i)
        }
    }
    setButtonsEnabled(t) {
        for (const e of this.loginButtons) e.enabled = t
    }
    async waitForFlowEnd() {
        return await new Promise((async t => {
            this.addOnCloseCb((async () => {
                if (this.didClickAnyButton) {
                    const e = await this.waitForOAuthLoginFinish();
                    t(e)
                } else t(null)
            }))
        }))
    }
    async handleOAuthLogin(t) {
        const e = await uc().auth.oAuthLogin(t);
        if (e) {
            this.oAuthLoginFinished = !0, this.onAuthLoginResult = e;
            for (const t of this.onOAuthLoginFinishCbs) t(e);
            this.onOAuthLoginFinishCbs.clear(), this.close()
        } else this.setButtonsEnabled(!0)
    }
    async waitForOAuthLoginFinish() {
        if (this.oAuthLoginFinished) return this.onAuthLoginResult;
        await new Promise((t => this.onOAuthLoginFinishCbs.add(t)))
    }
}

function Jh() {
    const t = new URL(location.href);
    return t.searchParams.get("useProductionServers") && (t.href = "https://narrow.one/"), uc().poki.isPokiBuild && (t.searchParams.get("pokiDebug") ? t.href = "https://staging.narrow.one/" : t.href = "https://narrow.one/"), t
}

function Xh(t) {
    const e = Jh();
    return e.search = "", e.hash = "", e.pathname = "/api/" + t, e
}
class $h {
    constructor() {
        this.oAuthProviderConfigs = new Map, this.oAuthProviderConfigs.set("google", {
            loginButtonText: "Login with Google",
            loginButtonIcon: "img/loginUI/google.svg",
            issuer: "https://accounts.google.com",
            clientId: "249998461419-0biodmg82dpppih5tef7g2htbtg8cca8.apps.googleusercontent.com"
        }), this.oAuthProviderConfigs.set("facebook", {
            loginButtonText: "Login with Facebook",
            loginButtonIcon: "img/loginUI/facebook.svg",
            issuer: "https://www.facebook.com",
            fallBackAuthorizationEndpoint: "https://facebook.com/dialog/oauth/",
            clientId: "363560581868168"
        }), this.oAuthProviderConfigs.set("apple", {
            loginButtonText: "Login with Apple",
            loginButtonIcon: "img/loginUI/apple.svg",
            issuer: "https://appleid.apple.com",
            clientId: "co.pelicanparty.narrow.one.signin"
        }), this.prevSessionNonce = null, this.sessionNonce = null, this.currentSessionData = null, this.currentGuestSessionData = null, this.openOAuthWindows = new Set, this.onOAuthWindowCloseCbs = new Set, this.isHandlingAuthToken = !1, this.onAuthTokenHandleFinishCbs = new Set, this.mostRecentAuthTokenHandleResult = null, this.onLoggedInAccountChangeCbs = new Set, this.onGuestSessionDataChangeCbs = new Set, window.addEventListener("message", (t => {
            if (t.origin == Jh().origin && t.data) {
                const e = t.source;
                "requestOpenerOrigin" == t.data.type ? t.source && e.postMessage({
                    type: "openerOrigin",
                    openerOrigin: location.origin
                }, "*") : "oAuthCallback" == t.data.type && (e && e.postMessage({
                    type: "oAuthTokenReceived"
                }, "*"), this.handleAuthToken(t.data.idToken), this.closeOpenOAuthWindows())
            }
        })), this.syncGuestDataWithRestServiceInstance = new zl((async () => await this.syncGuestDataWithRestServiceFn()), {
            once: !1,
            run: !1
        }), this.isInit = !1, this.onInitCbs = new Set
    }
    async init() {
        this.currentSessionData = await uc().indexedDb.get("currentAuthSessionData"), this.prevSessionNonce = await uc().indexedDb.get("prevSessionNonce"), this.isInit = !0;
        for (const t of this.onInitCbs) t();
        this.onInitCbs.clear();
        const t = va();
        if (t.loginIdToken) {
            this.handleAuthToken(t.loginIdToken, !0);
            const e = new URL(window.location.href);
            e.search = "", e.hash = "", window.history.replaceState(null, "", e.href)
        }
    }
    async waitForInit() {
        if (this.isInit) return;
        const t = new Promise((t => this.onInitCbs.add(t)));
        await t
    }
    onLoggedInAccountChange(t) {
        this.onLoggedInAccountChangeCbs.add(t)
    }
    fireLoggedInAccountChange() {
        this.onLoggedInAccountChangeCbs.forEach((t => t()))
    }
    onGuestSessionDataChange(t) {
        this.onGuestSessionDataChangeCbs.add(t)
    }
    async showLoginDialog(t = "login") {
        const e = new Yh(t);
        return uc().dialogManager.addDialog(e), await e.waitForFlowEnd()
    }
    getSessionNonce() {
        if (this.sessionNonce) return this.sessionNonce;
        let t = 16;
        const e = "0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz";
        let i = "";
        for (; t > 0;) {
            const n = new Uint8Array(t);
            try {
                window.crypto.getRandomValues(n)
            } catch (t) {
                return i
            }
            for (const s of n) s < e.length && (i += e[s], t--)
        }
        return this.sessionNonce = i, uc().indexedDb.set("prevSessionNonce", this.sessionNonce), i
    }
    async getOAuthUrl(t) {
        await this.waitForInit();
        const e = this.oAuthProviderConfigs.get(t);
        if (!e) return null;
        const i = e.issuer;
        if (!i) return null;
        const n = Xh("auth/authEndpoint");
        let s;
        n.searchParams.set("issuer", i);
        try {
            s = await wa(n.href)
        } catch (t) {
            console.error(t)
        }
        if (!s || !s.ok) return null;
        const r = await s.json(),
            o = new URL(r.authorization_endpoint);
        let a = "code";
        r.response_types_supported.includes("id_token") && (a = "id_token"), o.searchParams.set("response_type", a), o.searchParams.set("client_id", e.clientId);
        const l = Xh("auth/oAuthCallback");
        l.searchParams.set("issuer", i), o.searchParams.set("redirect_uri", l.href);
        const h = "facebook" == t ? "," : " ";
        return o.searchParams.set("scope", ["openid", "email"].join(h)), "apple" == t && r.response_modes_supported && r.response_modes_supported.includes("form_post") && o.searchParams.set("response_mode", "form_post"), o.searchParams.set("nonce", this.getSessionNonce()), o.href
    }
    async oAuthLogin(t) {
        let e = null;
        const i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        "apple" == t && i || (e = window.open(), e && (e.document.body.innerText = "Loading..."));
        const n = await this.getOAuthUrl(t);
        if (!n) return e && e.close(), uc().dialogManager.showAlert({
            text: "An error occurred while getting login url."
        }), null;
        if (e) {
            const t = e;
            e.location.href = n, this.openOAuthWindows.add(e);
            const i = this.mostRecentAuthTokenHandleResult,
                s = new Promise((e => {
                    const i = setInterval((() => {
                        this.onOAuthWindowCloseCbs.add((() => {
                            e(), clearInterval(i)
                        })), t.closed && (clearInterval(i), this.openOAuthWindows.delete(t), e())
                    }), 1e3)
                }));
            return await s, this.isHandlingAuthToken || this.mostRecentAuthTokenHandleResult != i ? await this.waitForAuthTokenHandleFinish() : null
        } {
            window.location.href = n;
            const t = new Promise((t => {
                window.addEventListener("focus", (() => {
                    t()
                }), {
                    once: !0
                })
            }));
            return await t, null
        }
    }
    closeOpenOAuthWindows() {
        for (const t of this.openOAuthWindows) try {
            t.close()
        } catch (t) {}
        this.openOAuthWindows.clear();
        for (const t of this.onOAuthWindowCloseCbs) t();
        this.onOAuthWindowCloseCbs.clear()
    }
    async handleAuthToken(t, e = !1) {
        this.isHandlingAuthToken = !0, await this.waitForInit();
        const i = e ? this.prevSessionNonce : this.getSessionNonce();
        let n, s = !1;
        if (this.isLoggedIn) {
            const e = Xh("auth/linkNewAccount"),
                r = new URLSearchParams;
            r.set("idToken", t), r.set("nonce", i);
            let o = null;
            try {
                o = await wa(e.href, {
                    method: "POST",
                    credentials: "include",
                    body: r
                })
            } catch (t) {
                console.error(t)
            }
            o && (s = o.ok, n = await o.text())
        } else {
            const e = Xh("auth/getSession"),
                n = new URLSearchParams;
            n.set("idToken", t), n.set("nonce", i), s = await this.fetchAuthSessionData(e, n), s && (this.fireLoggedInAccountChange(), await this.mergeGuestDataWithLoggedInAccount())
        }
        this.isHandlingAuthToken = !1, this.mostRecentAuthTokenHandleResult = {
            success: s,
            error: n,
            usedIdToken: t,
            usedNonce: i
        };
        for (const t of this.onAuthTokenHandleFinishCbs) t(this.mostRecentAuthTokenHandleResult);
        this.onAuthTokenHandleFinishCbs.clear()
    }
    async waitForAuthTokenHandleFinish() {
        return !this.isHandlingAuthToken && this.mostRecentAuthTokenHandleResult ? this.mostRecentAuthTokenHandleResult : await new Promise((t => this.onAuthTokenHandleFinishCbs.add(t)))
    }
    async mergeAccountToCurrent(t, e) {
        if (!this.isLoggedIn) return !1;
        const i = Xh("auth/mergeAccount"),
            n = new URLSearchParams;
        n.set("idToken", t), n.set("nonce", e);
        let s = null;
        try {
            s = await wa(i.href, {
                method: "POST",
                credentials: "include",
                body: n
            })
        } catch (t) {
            console.error(t)
        }
        return !(!s || !s.ok) && (this.fireLoggedInAccountChange(), !0)
    }
    async mergeGuestDataWithLoggedInAccount() {
        if (!this.isLoggedIn) return !1;
        const t = await this.getGuestAccountData();
        if (!t) return !1;
        const e = Xh("auth/mergeGuestAccount"),
            i = new URLSearchParams;
        i.set("guestData", t);
        let n = null;
        try {
            n = await wa(e.href, {
                method: "POST",
                credentials: "include",
                body: i
            })
        } catch (t) {
            console.error(t)
        }
        if (!n) return !1;
        const s = n.ok;
        let r = !1;
        if (s) r = !0;
        else {
            const t = await n.text();
            "invalid-guest-data" == t ? (console.error("Failed to merge guest data with login account. The guest data may already have been merged."), r = !0) : console.error("Failed to merge guest data with login account: " + t)
        }
        return r && await this.setGuestAccountData(null), s && this.fireLoggedInAccountChange(), !0
    }
    async refreshSession() {
        const t = Xh("auth/refreshSession");
        await this.fetchAuthSessionData(t, null, !0)
    }
    async refreshSessionIfNeeded() {
        this.currentSessionData && (Date.now() < this.currentSessionData.expires - 6e5 || await this.refreshSession())
    }
    async fetchAuthSessionData(t, e = null, i = !1) {
        let n;
        try {
            n = await wa(t.href, {
                method: "POST",
                credentials: "include",
                body: e
            }), n && !n.ok && console.error("session data request error: " + await n.text())
        } catch (t) {
            console.error(t)
        }
        if (n && n.ok) {
            const t = await n.json();
            this.currentSessionData = {
                secureId: t.secureId,
                token: t.token,
                expires: Date.now() + t.expiresIn
            }
        } else this.currentSessionData = null, this.fireLoggedInAccountChange(), this.showLoggedOutNotification(i);
        return await uc().indexedDb.set("currentAuthSessionData", this.currentSessionData), !(!n || !n.ok)
    }
    get isLoggedIn() {
        return !!this.currentSessionData
    }
    async loginIfNotLoggedIn(t = !1) {
        return await this.waitForInit(), this.currentSessionData ? (Date.now() > this.currentSessionData.expires - 6e5 && await this.refreshSession(), !this.currentSessionData && t && await this.showLoginDialog()) : t && await this.showLoginDialog(), this.isLoggedIn
    }
    async logoutAfterError() {
        return !!this.isLoggedIn && (await this.refreshSession(), this.isLoggedIn)
    }
    showLoggedOutNotification(t = !1) {
        t ? uc().dialogManager.showAlert({
            title: "Login error",
            text: "You have been logged out."
        }) : uc().dialogManager.showAlert({
            text: "An error occurred while logging in."
        })
    }
    async logout() {
        await this.waitForInit();
        const t = Xh("auth/logout"),
            e = new URLSearchParams;
        e.set("tokenId", this.currentSessionData.secureId), e.set("token", this.currentSessionData.token);
        const i = await wa(t.href, {
            method: "POST",
            credentials: "include",
            body: e
        });
        if (!i.ok) {
            const t = await i.text();
            if ("token-not-found" != t) return t && console.error(t), !1
        }
        return this.clearCurrentSessionData(), await uc().indexedDb.set("currentAuthSessionData", null), !0
    }
    async logoutEverywhere() {
        await this.waitForInit();
        const t = Xh("auth/logoutEverywhere"),
            e = await wa(t.href, {
                method: "POST",
                credentials: "include"
            });
        if (!e.ok) {
            const t = await e.text();
            return t && console.error(t), !1
        }
        return this.clearCurrentSessionData(), await uc().indexedDb.set("currentAuthSessionData", null), !0
    }
    clearCurrentSessionData() {
        this.currentSessionData = null, this.mostRecentAuthTokenHandleResult = null, this.fireLoggedInAccountChange()
    }
    async getGuestAccountData() {
        return await uc().indexedDb.get("guestAccountData")
    }
    async setGuestAccountData(t, e = !0) {
        await uc().indexedDb.set("guestAccountData", t), this.onGuestSessionDataChangeCbs.forEach((t => t())), e || await this.deleteGuestAccountDataFromRestService()
    }
    async getSessionDataForGameServer() {
        return this.isLoggedIn ? (await this.refreshSessionIfNeeded(), {
            type: "sessionToken",
            token: this.currentSessionData.token,
            secureId: this.currentSessionData.secureId
        }) : {
            type: "guest",
            guestData: await this.getGuestAccountData()
        }
    }
    async refreshGuestSessionIfNeeded() {
        if (!this.isLoggedIn) return !(!this.currentGuestSessionData || Date.now() > this.currentGuestSessionData.expires - 6e4) || await this.postGuestAccountDataToRestService()
    }
    async postGuestAccountDataToRestService() {
        const t = await this.getGuestAccountData(),
            e = Xh("auth/guestAccountData"),
            i = new URLSearchParams;
        i.set("guestData", t ?? "");
        const n = await fetch(e.href, {
            method: "POST",
            body: i
        });
        if (!n.ok) return !1;
        const s = await n.json();
        return this.currentGuestSessionData = {
            secureId: s.secureId,
            token: s.token,
            expires: Date.now() + s.expiresIn
        }, !0
    }
    async syncGuestDataWithRestService() {
        return await this.syncGuestDataWithRestServiceInstance.run(!0)
    }
    async waitForGuestDataSync() {
        await this.syncGuestDataWithRestServiceInstance.waitForFinishIfRunning()
    }
    async syncGuestDataWithRestServiceFn() {
        if (this.isLoggedIn) return;
        const t = Xh("auth/guestAccountData"),
            e = await this.getRestAuthHeader(!1);
        if (!e) return !1;
        const i = await fetch(t.href, {
            headers: {
                Authorization: e
            }
        });
        if (!i.ok) return !1;
        const n = await i.text();
        this.setGuestAccountData(n, !0)
    }
    async deleteGuestAccountDataFromRestService() {
        const t = Xh("auth/guestAccountData"),
            e = await this.getRestAuthHeader(!1);
        if (!e) return !0;
        const i = await fetch(t.href, {
            method: "DELETE",
            headers: {
                Authorization: e
            }
        });
        return this.currentGuestSessionData = null, i.ok
    }
    async getRestAuthHeader(t = !0) {
        await this.waitForInit();
        let e = "",
            i = null;
        if (this.isLoggedIn) t && await this.refreshSessionIfNeeded(), e = "st", i = this.currentSessionData;
        else {
            if (t) {
                if (!await this.refreshGuestSessionIfNeeded()) return null
            }
            e = "g", i = this.currentGuestSessionData
        }
        if (!i) return null;
        return `Bearer ${[e,i.secureId,i.token].join(".")}`
    }
    async requestWithAuthHeader(t) {
        const e = await this.getRestAuthHeader(),
            i = await t(e);
        if (!i.gotAuthError || this.isLoggedIn) return i.returnValue; {
            this.currentGuestSessionData = null;
            const e = await this.getRestAuthHeader();
            if (!e) return i.returnValue;
            return (await t(e)).returnValue
        }
    }
}
class Zh {
    constructor(t, e) {
        this.authManager = t, this.indexedDb = e, this.onStateChangedCbs = new Set, this.cachedStateIndexDbKey = "cachedState", this.getStateUrl = "", this.fetchCurrentDataInstance = new zl((async () => await this.fetchCurrentDataFn()), {
            once: !1
        }), this.stateIsStale = !0
    }
    init() {
        this.loadCachedState(), this.authManager.onLoggedInAccountChange((() => {
            this.clearCurrentData(), this.markStateAsStale(), this.fetchCurrentData()
        }))
    }
    clearCurrentData() {
        this.clearCurrentDataImpl(), this.fireStateChanged(), this.saveCurrentCachedState()
    }
    async saveCachedState(t) {
        await this.indexedDb.set(this.cachedStateIndexDbKey, t)
    }
    async loadCachedState() {
        const t = await this.indexedDb.get(this.cachedStateIndexDbKey);
        this.loadStateData(t), this.fireStateChanged()
    }
    async saveCurrentCachedState() {
        const t = this.getCurrentState();
        await this.saveCachedState(t)
    }
    markStateAsStale() {
        this.stateIsStale = !0
    }
    onStateChanged(t) {
        this.onStateChangedCbs.add(t)
    }
    removeOnStateChanged(t) {
        this.onStateChangedCbs.delete(t)
    }
    fireStateChanged() {
        this.saveCurrentCachedState(), this.onStateChangedCbs.forEach((t => t()))
    }
    async fetchCurrentData(t = !1) {
        (this.stateIsStale || t) && await this.fetchCurrentDataInstance.run()
    }
    async waitForCurrentDataFetch() {
        await this.fetchCurrentDataInstance.waitForFinishIfRunning()
    }
    async fetchCurrentDataFn() {
        const t = Xh(this.getStateUrl),
            {
                success: e,
                authError: i,
                data: n
            } = await this.authManager.requestWithAuthHeader((async e => {
                if (!e) return {
                    gotAuthError: !0,
                    returnValue: {
                        success: !1,
                        authError: !0,
                        data: null
                    }
                };
                const i = await fetch(t.href, {
                    headers: {
                        Authorization: e
                    }
                });
                if (!i.ok) {
                    const t = await i.text(),
                        e = "token-not-found" == t || "invalid-token" == t;
                    return {
                        gotAuthError: e,
                        returnValue: {
                            success: !1,
                            authError: e,
                            data: null
                        }
                    }
                }
                return {
                    gotAuthError: !1,
                    returnValue: {
                        success: !0,
                        authError: !1,
                        data: await i.json()
                    }
                }
            }));
        if (e) this.saveCachedState(n), this.loadStateData(n), this.fireStateChanged(), this.stateIsStale = !1;
        else {
            if (i) {
                if (await this.authManager.logoutAfterError()) return await this.fetchCurrentDataFn()
            }
            this.clearCurrentData()
        }
    }
    loadStateData(t) {}
    getCurrentState() {
        throw new Error("Base class")
    }
    clearCurrentDataImpl() {}
}
class Kh extends Zh {
    constructor(...t) {
        super(...t), this.cachedStateIndexDbKey = "cachedProfileState", this.getStateUrl = "profile/getProfile", this.username = null
    }
    getCurrentState() {
        return {
            username: this.username
        }
    }
    loadStateData(t) {
        t && (this.username = t.username)
    }
    clearCurrentDataImpl() {
        this.username = null
    }
    async setUsername(t) {
        const e = Xh("profile/username"),
            i = new URLSearchParams;
        i.set("username", t);
        const n = await this.authManager.requestWithAuthHeader((async t => {
            if (!t) return {
                gotAuthError: !0,
                returnValue: !1
            };
            const n = await fetch(e.href, {
                method: "POST",
                headers: {
                    Authorization: t
                },
                body: i
            });
            if (!n.ok) {
                const t = await n.text();
                return t && console.error(t), {
                    gotAuthError: 401 == n.status,
                    returnValue: !1
                }
            }
            return {
                gotAuthError: !1,
                returnValue: !0
            }
        }));
        return n && (this.username = t, this.fireStateChanged()), n
    }
}
class Qh extends Zh {
    constructor(...t) {
        super(...t), this.cachedStateIndexDbKey = "cachedShopState", this.getStateUrl = "shop/getShopState", this.ownedCoins = 0, this.purchasedItems = new Set, this.purchasingItemTasks = new Map
    }
    getCurrentState() {
        return {
            ownedCoins: this.ownedCoins,
            purchasedItems: Array.from(this.purchasedItems)
        }
    }
    loadStateData(t) {
        t && (this.ownedCoins = t.ownedCoins, this.purchasedItems = new Set(t.purchasedItems))
    }
    clearCurrentDataImpl() {
        this.ownedCoins = 0, this.purchasedItems.clear()
    }
    async sendPurchaseItemRequest(t) {
        const e = t.id;
        let i = this.purchasingItemTasks.get(e);
        i || (i = (async () => {
            const i = Xh("shop/purchaseItem");
            return await this.authManager.requestWithAuthHeader((async n => {
                if (!n) return {
                    gotAuthError: !0,
                    returnValue: {
                        success: !1,
                        errorCode: "not-logged-in"
                    }
                };
                const s = new URLSearchParams;
                s.set("itemId", e);
                const r = await fetch(i.href, {
                    method: "POST",
                    headers: {
                        Authorization: n
                    },
                    body: s
                });
                return r.ok && (await this.waitForCurrentDataFetch(), t.price && t.price > 0 && (this.ownedCoins -= t.price), this.purchasedItems.add(e), this.fireStateChanged(), this.authManager.syncGuestDataWithRestService()), {
                    gotAuthError: !r.ok && 401 == r.status,
                    returnValue: {
                        success: r.ok,
                        errorCode: await r.text()
                    }
                }
            }))
        })(), this.purchasingItemTasks.set(e, i));
        const n = await i;
        return this.purchasingItemTasks.delete(e), n
    }
    async purchasePaidItem(t, e) {
        const {
            success: i,
            errorCode: n
        } = await this.sendPurchaseItemRequest(t);
        return i ? (uc().sfx.playSound("ui/purchaseShopItem"), !0) : ("not-enough-coins" === n ? e.showAlert({
            title: "Not enough coins",
            text: "You don't have enough coins to purchase this item."
        }) : (n && console.error("Purchase failed: " + n), e.showAlert({
            title: "Purchase Failed",
            text: "An error occurred while trying to purchase this item. Please try again later."
        })), !1)
    }
    async purchaseRewardedItem(t, e, i) {
        if (this.purchasedItems.has(t.id)) return i.showAlert({
            title: "Purchase Failed",
            text: "You already own this item."
        }), !1;
        return !!await e.rewardedBreakWithErrorDialog() && await this.purchasePaidItem(t, i)
    }
    async purchaseItem(t, e, i, n) {
        let s = !1;
        return t.price ? s = await this.purchasePaidItem(t, i) : t.hasRewardedAd && (s = await this.purchaseRewardedItem(t, e, i)), s
    }
    provideNewCoinCount(t) {
        this.ownedCoins = t, this.fireStateChanged()
    }
    async doubleLastGameCoins() {
        const t = Xh("shop/doubleLastGameCoins");
        return await this.authManager.requestWithAuthHeader((async e => {
            if (!e) return {
                gotAuthError: !0,
                returnValue: {
                    success: !1,
                    error: "not-logged-in"
                }
            };
            const i = await fetch(t.href, {
                method: "POST",
                headers: {
                    Authorization: e
                }
            });
            if (i.ok) {
                const {
                    newCoinCount: t
                } = await i.json();
                return this.provideNewCoinCount(t), this.authManager.syncGuestDataWithRestService(), {
                    gotAuthError: !1,
                    returnValue: {
                        success: !0,
                        error: ""
                    }
                }
            }
            return {
                gotAuthError: 401 == i.status,
                returnValue: {
                    success: !1,
                    error: await i.text()
                }
            }
        }))
    }
    async requestCheatCoins(t) {
        return !1
    }
    isPurchasingItem(t) {
        return this.purchasingItemTasks.has(t)
    }
    itemIsPurchased(t) {
        return this.purchasedItems.has(t)
    }
    async waitForItemPurchase(t) {
        const e = this.purchasingItemTasks.get(t);
        e && await e
    }
}
class tc {
    constructor(t) {
        this.pokiInit = !1, this.pokiErrored = !1, this.pokiInitErrored = !1, this.onPokiInitCbs = [], this._usePokiSdk = !1, this.gameplayStarted = !1, this.loadStartCalled = !1, this.loadFinishCalled = !1, this.isShowingRewardedBreak = !1, this.onRewardedBreakFinishCbs = new Set, this.prevVisiblePokiBanners = new Set, t && (this._usePokiSdk = !0), this.isPokiBuild = location.origin.includes("poki"), ea.addListener((t => {
            this.updateBannerVisibility()
        }))
    }
    get usePokiSdk() {
        return this._usePokiSdk
    }
    get supported() {
        return !!this._usePokiSdk && !this.pokiErrored
    }
    async init() {
        if (this.usePokiSdk) {
            try {
                await async function(t) {
                    const e = document.createElement("script");
                    e.src = t, document.head.appendChild(e), await new Promise(((i, n) => {
                        const s = t => {
                            i(), e.removeEventListener("load", s)
                        };
                        e.addEventListener("load", s);
                        const r = i => {
                            n("unable to load srcipt " + t), e.removeEventListener("error", r)
                        };
                        e.addEventListener("error", r)
                    }))
                }("https://game-cdn.poki.com/scripts/v2/poki-sdk.js")
            } catch (t) {
                this.pokiErrored = !0, console.warn("failed to load PokiSDK", t)
            }
            if ("undefined" == typeof PokiSDK && (this.pokiErrored = !0, console.warn("failed to load PokiSDK, PokiSDK does not exist")), !this.pokiErrored) try {
                await PokiSDK.init({
                    debug: !1
                })
            } catch (t) {
                console.warn("Warning! Error during poki initialization: ", t), this.pokiInitErrored = !0
            }
            this.pokiInit = !0;
            for (const t of this.onPokiInitCbs) t();
            this.onPokiInitCbs = [], this.updateBannerVisibility(), uc().mainMenu.onVisibilityChange((t => {
                this.updateBannerVisibility()
            }))
        }
    }
    async waitForInit() {
        if (!this.pokiInit) return await new Promise((t => {
            this.onPokiInitCbs.push(t)
        }))
    }
    async gameplayStart() {
        if (!this.gameplayStarted && (this.gameplayStarted = !0, this.supported)) {
            await this.waitForInit();
            try {
                PokiSDK.gameplayStart()
            } catch (t) {
                console.error(t)
            }
        }
    }
    async gameplayStop() {
        if (this.gameplayStarted && (this.gameplayStarted = !1, this.supported)) {
            await this.waitForInit();
            try {
                PokiSDK.gameplayStop()
            } catch (t) {
                console.error(t)
            }
        }
    }
    async gameLoadingStart() {
        if (this.supported && !this.loadStartCalled) {
            this.loadStartCalled = !0, await this.waitForInit();
            try {
                PokiSDK.gameLoadingStart()
            } catch (t) {
                console.error(t)
            }
        }
    }
    async gameLoadingProgress(t) {
        if (this.supported && !this.loadFinishCalled) {
            await this.waitForInit();
            try {
                PokiSDK.gameLoadingProgress({
                    percentageDone: t
                })
            } catch (t) {}
        }
    }
    async gameLoadingFinished() {
        if (this.supported && !this.loadFinishCalled) {
            this.loadFinishCalled = !0, await this.waitForInit();
            try {
                PokiSDK.gameLoadingFinished()
            } catch (t) {
                console.error(t)
            }
        }
    }
    async rewardedBreak() {
        if (!this.supported || !this.pokiInit) return {
            success: !1,
            error: "sdk-not-init"
        };
        this.isShowingRewardedBreak = !0, await this.waitForInit(), uc().sfx.setMutedAds(!0);
        let t = !1;
        try {
            t = await PokiSDK.rewardedBreak()
        } catch (t) {
            console.error(t)
        }
        return uc().sfx.setMutedAds(!1), this.isShowingRewardedBreak = !1, this.onRewardedBreakFinishCbs.forEach((t => t())), this.onRewardedBreakFinishCbs.clear(), t ? {
            success: !0 //SWITCHED FROM 0
        } : { //ADBLOCk HACK
            success: !1,//SWITCHED FROM 1
            error: this.pokiInitErrored ? "adblocker" : "unknown"
        }
    }
    async rewardedBreakWithErrorDialog() {
        const t = await this.rewardedBreak();
        if (!t.success) {
            let e = "I'm gae.";
            return "adblocker" == t.error && (e = "Yes, I'm gae."), uc().dialogManager.showAlert({
                title: "I'm just gae",
                text: e
            }), !1
        }
        return t.success
    }
    async waitForRewardedBreakFinish() {
        this.isShowingRewardedBreak && await new Promise((t => this.onRewardedBreakFinishCbs.add(t)))
    }
    async commercialBreak() {
        if (this.supported && this.pokiInit) {
            uc().sfx.setMutedAds(!0);
            try {
                await PokiSDK.commercialBreak()
            } catch (t) {
                console.error(t)
            }
            uc().sfx.setMutedAds(!1)
        }
    }
    updateBannerVisibility() {
        if (!this.supported) return;
        if (!this.pokiInit) return;
        let t = [];
        t.push({
            el: uc().adBanners.desktopBanner,
            size: "728x90"
        }), t.push({
            el: uc().adBanners.mobileBanner,
            size: "320x50"
        }), t = t.filter((t => "none" != window.getComputedStyle(t.el).display));
        for (const {
            el: e,
            size: i
        }
            of t)
            if (!this.prevVisiblePokiBanners.has(e)) {
                this.prevVisiblePokiBanners.add(e);
                try {
                    PokiSDK.displayAd(e, i)
                } catch (t) {
                    console.error(t)
                }
            } for (const e of this.prevVisiblePokiBanners)
            if (!t.some((t => t.el == e))) {
                this.prevVisiblePokiBanners.delete(e);
                try {
                    PokiSDK.destroyAd(e)
                } catch (t) {
                    console.error(t)
                }
            }
    }
    async happyTime(t = .5) {
        if (this.supported) {
            await this.waitForInit();
            try {
                PokiSDK.happyTime(t)
            } catch (t) {
                console.error(t)
            }
        }
    }
    get isHappyDay() {
        const t = new Date;
        return t.getUTCDate() > new Date(t.getUTCFullYear(), t.getUTCMonth() + 1, 0).getDate() / 2
    }
}
class ec {
    static setCurrentScene(t) {
        this.scene = t, this.drawLinesNextFrame = [], this.removeLinesNextFrame = [], this.material || (this.material = new Is({
            color: 16777215,
            vertexColors: !0
        }))
    }
    static loop() {
        if (this.drawLinesNextFrame && this.removeLinesNextFrame) {
            for (const t of this.removeLinesNextFrame) {
                const e = t.line;
                e.parent.remove(e), e.geometry.dispose()
            }
            this.removeLinesNextFrame = [];
            for (const t of this.drawLinesNextFrame) {
                const e = new ae,
                    i = new Float32Array([...t.from.toArray(), ...t.to.toArray()]);
                e.setAttribute("position", new Xt(i, 3));
                let n = this.material;
                t.color && (n = new Is({
                    color: t.color
                }));
                const s = new Bs(e, n);
                t.line = s, this.scene.add(s), this.removeLinesNextFrame.push(t)
            }
            this.drawLinesNextFrame = []
        }
    }
    static drawLine(t, e, i) {
        this.drawLinesNextFrame && this.drawLinesNextFrame.push({
            from: t.clone(),
            to: e.clone(),
            color: i
        })
    }
    static drawRay(t, e, i) {
        const n = (t = t.clone()).clone();
        n.add(e), this.drawLine(t, n, i)
    }
}
class ic {
    init(t) {
        if (t) try {
            ! function() {
                const t = document.createElement("script"),
                    e = document.getElementsByTagName("script")[0],
                    i = "https://cmp.quantcast.com".concat("/choice/", "A-YH9MP3vgq7x", "/", "narrow.one", "/choice.js?tag_version=V2");
                let n = 0;
                t.async = !0, t.type = "text/javascript", t.src = i, e.parentNode.insertBefore(t, e),
                    function() {
                        const t = "__tcfapiLocator",
                            e = [];
                        let i, n = window;
                        for (; n;) {
                            try {
                                if (n.frames.__tcfapiLocator) {
                                    i = n;
                                    break
                                }
                            } catch (t) {}
                            if (n === window.top) break;
                            n = n.parent
                        }
                        i || (function e() {
                            const i = n.document,
                                s = !!n.frames.__tcfapiLocator;
                            if (!s)
                                if (i.body) {
                                    const e = i.createElement("iframe");
                                    e.style.cssText = "display:none", e.name = t, i.body.appendChild(e)
                                } else setTimeout(e, 5);
                            return !s
                        }(), n.__tcfapi = function() {
                            let t;
                            const i = arguments;
                            if (!i.length) return e;
                            if ("setGdprApplies" === i[0]) i.length > 3 && 2 === i[2] && "boolean" == typeof i[3] && (t = i[3], "function" == typeof i[2] && i[2]("set", !0));
                            else if ("ping" === i[0]) {
                                const e = {
                                    gdprApplies: t,
                                    cmpLoaded: !1,
                                    cmpStatus: "stub"
                                };
                                "function" == typeof i[2] && i[2](e)
                            } else "init" === i[0] && "object" == typeof i[3] && (i[3] = Object.assign(i[3], {
                                tag_version: "V2"
                            })), e.push(i)
                        }, n.addEventListener("message", (function(t) {
                            const e = "string" == typeof t.data;
                            let i = {};
                            try {
                                i = e ? JSON.parse(t.data) : t.data
                            } catch (t) {}
                            const n = i.__tcfapiCall;
                            n && window.__tcfapi(n.command, n.version, ((i, s) => {
                                let r = {
                                    __tcfapiReturn: {
                                        returnValue: i,
                                        success: s,
                                        callId: n.callId
                                    }
                                };
                                e && (r = JSON.stringify(r)), t && t.source && t.source.postMessage && t.source.postMessage(r, "*")
                            }), n.parameter)
                        }), !1))
                    }();
                var s = function() {
                    const t = arguments;
                    typeof window.__uspapi !== s && setTimeout((() => {
                        void 0 !== window.__uspapi && window.__uspapi.apply(window.__uspapi, t)
                    }), 500)
                };
                const r = function() {
                    n++, window.__uspapi === s && n < 3 ? console.warn("USP is not accessible") : clearInterval(o)
                };
                if (void 0 === window.__uspapi) {
                    window.__uspapi = s;
                    var o = setInterval(r, 6e3)
                }
            }()
        } catch (t) {
            console.error("error occurred while initializing quantcast: ", t)
        }
    }
}
class nc {
    constructor() {
        this.onDestructedCbs = new Set, this.onBlobUrlCreatedCbs = new Set, this.blobUrl = null, this.destructed = !1
    }
    destructor() {
        this.destructed = !0, this.onDestructedCbs.forEach((t => t()))
    }
    onDestructed(t) {
        this.onDestructedCbs.add(t)
    }
    blobUrlCreated(t) {
        this.blobUrl = t, this.onBlobUrlCreatedCbs.forEach((e => e(t)))
    }
    async getBlobUrl() {
        if (this.destructed) throw new Error("Can't get blob urls from destructed references");
        if (this.blobUrl) return this.blobUrl;
        const t = new Promise((t => {
            this.onBlobUrlCreatedCbs.add(t)
        }));
        return await t
    }
}
class sc {
    constructor(t, e) {
        this.avatarsManager = t, this.config = e, this.blobUrlReferences = new Set, this.onDestructedCbs = new Set, this.blobUrl = null, this.createAvatarInstance = new zl((async () => {
            const t = await this.avatarsManager.generateAvatarBlob(this.config);
            if (!t) return;
            if (this.destructed) return;
            const e = URL.createObjectURL(t);
            this.blobUrl = e, this.blobUrlReferences.forEach((t => t.blobUrlCreated(e)))
        })), this.destructed = !1
    }
    destructor() {
        this.destructed = !0, this.blobUrl && URL.revokeObjectURL(this.blobUrl), this.onDestructedCbs.forEach((t => t()))
    }
    getBlobUrlReference() {
        const t = new nc;
        return t.onDestructed((() => {
            this.blobUrlReferences.delete(t), this.blobUrlReferences.size <= 0 && this.destructor()
        })), this.blobUrlReferences.add(t), this.blobUrl && t.blobUrlCreated(this.blobUrl), this.createAvatarInstance.run(), t
    }
    onDestructed(t) {
        this.onDestructedCbs.add(t)
    }
}
class rc {
    constructor(t) {
        this.renderer = t, this.createdAvatars = new Map
    }
    fillConfigDefaults(t) {
        return {
            cameraType: "face-close",
            width: 512,
            height: 512,
            backgroundColor: "black",
            backgroundAlpha: 1,
            clipPathType: "circle",
            skinObjectOpts: {
                teamId: 0,
                skin: {}
            },
            skeletonPoseLayers: ["shopPreview"],
            bow: null,
            ...t
        }
    }
    async generateAvatarBlob(t) {
        const {
            cameraType: e,
            width: i,
            height: n,
            backgroundColor: s,
            backgroundAlpha: r,
            skinObjectOpts: o,
            clipPathType: a,
            skeletonPoseLayers: l
        } = this.fillConfigDefaults(t), h = new Ha({
            gender: o.skin.gender || "male"
        }), c = new ja({
            skinObjectOpts: o
        });
        let d = null;
        t.bow && (d = new Xa, d.setConfig(t.bow), await d.waitForLoad()), await c.waitForInit(), await h.waitForLoad();
        const u = [];
        for (const t of l) {
            const e = h.addPoseLayer(t);
            u.push((async () => {
                await e.waitForObjectLinks()
            })())
        }
        await Promise.all(u), h.applyLayers(), h.updateMatrices(), c.applySkeleton(h);
        const p = new ns;
        if (p.name = "Avatar scene", !c.obj) return null;
        if (p.add(c.obj), d) {
            if (!h.baseSkeletonObject) throw new Error("Assertion failed, skeleton is not initialized");
            const t = h.baseSkeletonObject.getObjectByName("bowHoldingPos");
            if (!t) throw new Error("Assertion failed, bowHoldingPos is not found");
            p.add(d.obj), d.obj.matrixAutoUpdate = !1, d.obj.matrix.copy(t.matrixWorld)
        }
        const m = new Re;
        m.far = 10, m.aspect = i / n, m.updateProjectionMatrix(), "face-close" == e ? m.position.set(0, 1.75, .7) : "face" == e ? m.position.set(0, 1.7, .9) : "upper-body" == e ? m.position.set(0, 1.5, 1.3) : "full-body" == e && m.position.set(0, 1.1, 2.5);
        const g = this.renderer.createRenderView({
            width: i,
            height: n
        });
        g.setRenderObjects(p, m, !0), await g.waitForFrameRender();
        const f = await g.getBlob();
        if (this.renderer.removeRenderView(g), c.destructor(), d && d.destructor(), !f) return null;
        const y = document.createElement("canvas");
        y.width = i, y.height = n;
        const v = y.getContext("2d");
        if (!v) return null;
        if ("circle" == a) {
            v.beginPath();
            const t = Math.min(i, n);
            v.arc(i / 2, n / 2, .45 * t, 0, 2 * Math.PI), v.clip()
        }
        v.fillStyle = s, v.globalAlpha = r, v.fillRect(0, 0, i, n), v.globalAlpha = 1;
        const w = URL.createObjectURL(f),
            b = new Image;
        b.src = w, await new Promise(((t, e) => {
            b.onload = t, b.onerror = e
        })), v.drawImage(b, 0, 0), URL.revokeObjectURL(w);
        const x = new Promise((t => {
                y.toBlob(t)
            })),
            S = await x;
        return S || null
    }
    configToCacheKey(t) {
        const {
            cameraType: e,
            width: i,
            height: n,
            backgroundColor: s,
            backgroundAlpha: r,
            skinObjectOpts: o,
            clipPathType: a,
            skeletonPoseLayers: l
        } = this.fillConfigDefaults(t), h = [];
        h.push(e), h.push(i), h.push(n), h.push(s), h.push(r), h.push(a), h.push("skeletonStart");
        for (const t of l) h.push(t);
        return h.push("skeletonEnd"), h.push(uc().skins.skinObjectOptsToCacheKey(o)), h.join("-")
    }
    getAvatar(t) {
        const e = this.configToCacheKey(t);
        let i = this.createdAvatars.get(e);
        return i || (i = new sc(this, t), i.onDestructed((() => {
            this.createdAvatars.delete(e)
        })), this.createdAvatars.set(e, i), i)
    }
}
class oc {
    constructor(t, e) {
        this.classId = t, this.classSelectionImageManager = e, this._needsUpdates = !1, this.lastBlobUrl = null, this.blobUrlChangeCbs = new Set, this.onNeedsUpdatesChangeCbs = new Set
    }
    destructor() {
        this.classSelectionImageManager.removeUpdateReference(this.classId, this)
    }
    get needsUpdates() {
        return this._needsUpdates
    }
    set needsUpdates(t) {
        this._needsUpdates = t, this.onNeedsUpdatesChangeCbs.forEach((t => t()))
    }
    onNeedsUpdatesChange(t) {
        this.onNeedsUpdatesChangeCbs.add(t)
    }
    onBlobUrlChange(t, e = !0) {
        this.blobUrlChangeCbs.add(t), e && this.lastBlobUrl && t(this.lastBlobUrl)
    }
    fireUrlChangeCbs(t) {
        this.lastBlobUrl = t, this.blobUrlChangeCbs.forEach((e => e(t)))
    }
}
class ac {
    constructor() {
        this.cachedBlobUrlDatas = new Map, this.teamId = 1
    }
    init() {
        uc().skins.onSkinConfigChange((() => {
            this.markAllAvatarsDirty()
        }))
    }
    markAllAvatarsDirty() {
        for (const [t, e] of this.cachedBlobUrlDatas) e.avatarDirty = !0, this.loadClassBlobUrl(t)
    }
    async loadClassBlobUrl(t) {
        const e = this.getOrCreateBlobUrlData(t);
        if (!e.avatarDirty) return;
        let i = !1;
        for (const t of e.updateReferences)
            if (t.needsUpdates) {
                i = !0;
                break
            } if (!i) return;
        e.avatarDirty = !1;
        let n = null,
            s = null;
        e.reference && (n = e.reference, s = e.url);
        const r = Symbol("Loading avatar");
        e.lastLoadingSym = r;
        const o = this.createClassBlobUrl(t);
        e.reference = o;
        const a = await o.getBlobUrl(),
            l = this.cachedBlobUrlDatas.get(t);
        if (!(l && l.lastLoadingSym != r || (e.url = a, n && n.destructor(), s && s == a)))
            for (const t of e.updateReferences) t.fireUrlChangeCbs(a)
    }
    createClassBlobUrl(t) {
        const e = Ta(t),
            i = uc(),
            n = i.skins.getClassSkinDataWithAppliedPreset(t);
        return i.avatars.getAvatar({
            skinObjectOpts: {
                skin: n,
                teamId: this.teamId
            },
            width: 200,
            height: 200,
            clipPathType: "none",
            cameraType: "upper-body",
            skeletonPoseLayers: [e.bowId + "/shopClassItem"],
            backgroundAlpha: 0,
            bow: {
                teamId: this.teamId,
                bowId: e.bowId,
                arrowCount: 1,
                skins: i.skins.skinNetworkDataToBowAssetNames(e.bowId, n)
            }
        }).getBlobUrlReference()
    }
    setTeamId(t) {
        null == t && (t = 1), this.teamId = t, this.markAllAvatarsDirty()
    }
    getOrCreateBlobUrlData(t) {
        let e = this.cachedBlobUrlDatas.get(t);
        return e || (e = {
            updateReferences: new Set,
            reference: null,
            url: null,
            lastLoadingSym: null,
            avatarDirty: !0
        }, this.cachedBlobUrlDatas.set(t, e)), e
    }
    createUpdateReference(t) {
        const e = this.getOrCreateBlobUrlData(t),
            i = new oc(t, this);
        return e.updateReferences.add(i), e.url && i.fireUrlChangeCbs(e.url), i.onNeedsUpdatesChange((() => {
            this.loadClassBlobUrl(t)
        })), i
    }
    removeUpdateReference(t, e) {
        this.getOrCreateBlobUrlData(t).updateReferences.delete(e)
    }
}
class lc {
    constructor(t) {
        this.settingsManager = t, this.isAprilFirst = Ga(1, 4), t.onSettingsLoaded((() => {
            this.updateScreenFlipStyle(), this.isAprilFirst || t.getValue("afFlipScreen") || t.setValue("afFlipScreen", !0)
        })), t.onValueChange("afFlipScreen", (() => {
            this.updateScreenFlipStyle()
        }))
    }
    get needsFlip() {
        return this.isAprilFirst && this.settingsManager.settingsLoaded && this.settingsManager.getValue("afFlipScreen")
    }
    updateScreenFlipStyle() {
        document.body.classList.toggle("af-mirror", this.needsFlip)
    }
}
class hc {
    constructor(t, e) {
        this.mapLoader = t, this.mapsConfigLoader = e, this.votedScores = new Map, this.forcingSoloMap = null, this.onMatchMakeDataChangeCbs = new Set, t.onMapCached((() => {
            this.onMatchMakeDataChangeCbs.forEach((t => t()))
        }))
    }
    onMatchMakeDataChange(t) {
        this.onMatchMakeDataChangeCbs.add(t)
    }
    getMatchMakeData() {
        if (!this.mapsConfigLoader.loadedConfigData) return null;
        const t = [];
        let e = 1 / 0,
            i = -1 / 0;
        for (const n of this.mapsConfigLoader.loadedConfigData.maps) {
            if (this.forcingSoloMap && this.forcingSoloMap !== n.hash) continue;
            if (!this.mapLoader.hasCachedMap(n.hash)) continue;
            let s = 0;
            const r = this.votedScores.get(n.assetName);
            r && (s = r.votedScore, r.hasTemporaryBoost && (s += .5), s -= ca(0, 3, 1, 0, r.lastPlayedCounter, !0)), e = Math.min(e, s), i = Math.max(i, s), t.push({
                hash: n.hash,
                configTimestamp: this.mapsConfigLoader.loadedConfigData.lastUpdatedTimestamp,
                preference: s
            })
        }
        if (e == i)
            for (const e of t) e.preference = 0;
        else
            for (const n of t) n.preference = ca(e, i, 0, 1, n.preference, !0);
        return {
            op: "downloadedMapHashes",
            downloadedMapHashes: t,
            configTimestamp: this.mapsConfigLoader.loadedConfigData.lastUpdatedTimestamp
        }
    }
    getOrCreateMapVoteData(t) {
        let e = this.votedScores.get(t);
        return e || (e = {
            votedScore: 0,
            hasTemporaryBoost: !1,
            lastPlayedCounter: 0
        }, this.votedScores.set(t, e), e)
    }
    voteMap(t) {}
    markRecentMap(t) {
        const e = this.mapsConfigLoader.getListedMapConfigByHash(t);
        if (!e) return;
        for (const t of this.votedScores.values()) t.lastPlayedCounter++;
        this.getOrCreateMapVoteData(e.assetName).lastPlayedCounter = 0
    }
    forceSoloMap(t) {
        this.forcingSoloMap = t, this.onMatchMakeDataChangeCbs.forEach((t => t()))
    }
    disableForcedSoloMap() {
        this.forcingSoloMap = null, this.onMatchMakeDataChangeCbs.forEach((t => t()))
    }
    get isForcingSoloMap() {
        return !!this.forcingSoloMap
    }
}
class cc {
    constructor() {
        this.thirdPartyEnabled = !0;
        const t = va();
        t.thirdParty && (this.thirdPartyEnabled = "false" != t.thirdParty), this.scene = new ns, this.scene.autoUpdate = !1, ec.setCurrentScene(this.scene), this.indexedDb = new ia, this.settingsManager = new na(this.indexedDb), this.mainMenu = new fl, this.adBanners = new yl, this.dialogManager = new wl, this.input = new Al, this.config = new Fl, this.mapLoader = new kl(this.config, this.config.mapsConfig), this.preferredMapManager = new hc(this.mapLoader, this.config.mapsConfig), this.gameManager = new Lh, this.physics = new Rh, this.cam = new Dh, this.materials = new Wa, this.hudIcons = new Fh, this.screenFlash = new Bh(this.scene, this.cam.cam), this.renderer = new zh, this.assets = new La, this.arrowAssetCache = new Hh, this.skins = new Va, this.skeletons = new Gh, this.avatars = new rc(this.renderer), this.classSelectionImageManager = new ac, this.sfx = new jh, this.network = new Wl(this.gameManager), this.auth = new $h, this.profileState = new Kh(this.auth, this.indexedDb), this.shopState = new Qh(this.auth, this.indexedDb), this.quantcastManager = new ic, this.poki = new tc(this.thirdPartyEnabled), this.aprilFools = new lc(this.settingsManager), this.boundLoop = this.vsyncLoop.bind(this), this.prevNow = 0, this.now = 0, this.dt = 0, this.smoothDt = 0, this.useFakeNow = !1, this.fakeNow = 0, this.fastLoopCount = 1, this.frameCount = 0, this.frameCap = 1;
        const e = function(t) {
            try {
                return localStorage.getItem(t)
            } catch (e) {
                return ya.get(t)
            }
        }("frameCap");
        e && (this.frameCap = parseInt(e, 10)), this.maxDt = 100, "000" == VERSION_TIMESTAMP ? (this.env = "local", window.location.hostname.includes("narrow.one") && !window.location.hostname.includes("localhost") && (this.env = "dev")) : (this.env = "production", "staging.narrow.one" == window.location.hostname && (this.env = "staging"), this.poki.isPokiBuild && document.referrer && document.referrer.includes("qa.po.ki") && (this.env = "staging")), "paintWorklet" in CSS && CSS.paintWorklet.addModule("narrowCssWorklet.js?v=" + VERSION_TIMESTAMP)
    }
    init() {
        ea.init(), this.settingsManager.init(), this.mainMenu.init(), this.adBanners.init(), this.mapLoader.init(), this.config.init(), this.gameManager.init(), this.physics.init(), this.cam.init(), this.renderer.init(), this.materials.init(), this.materials.screenFlashMat && this.screenFlash.setMaterial(this.materials.screenFlashMat), this.skins.init(), this.classSelectionImageManager.init(), this.sfx.init(), this.network.init(), this.auth.init(), this.profileState.init(), this.shopState.init(), this.quantcastManager.init(this.thirdPartyEnabled), this.poki.init(), this.vsyncLoop()
    }
    vsyncLoop() {
        if (this.frameCount++, this.frameCount % this.frameCap == 0) {
            for (let t = 0; t < this.fastLoopCount - 1; t++) this.loop();
            this.loop()
        }
        window.requestAnimationFrame(this.boundLoop)
    }
    loop() {
        let t = performance.now();
        this.useFakeNow && (t = this.fakeNow, this.fakeNow += 30), this.prevNow <= 0 && (this.prevNow = t);
        const e = t - this.prevNow,
            i = Math.min(e, this.maxDt);
        this.prevNow = t, this.now += i, t = this.now, this.dt = i, this.dt16 = this.dt / 16.6666, this.smoothDt = la(this.smoothDt, this.dt, .1), this.mainMenu.loop(t, i), this.input.loop(t, i), this.gameManager.loop(t, i), this.physics.loop(t, i), this.gameManager.afterPhysicsLoop(t, i), this.cam.loop(t, i), this.screenFlash.loop(t), ec.loop(), this.renderer.loop(t, i), this.sfx.loop(t, i)
    }
}
globalThis.VERSION_TIMESTAMP = "1659120483", globalThis.false = !1, globalThis.true = !1;
let dc = null;

function uc() {
    if (!dc) throw new Error("Main instance is not initialized");
    return dc
}
const pc = new CSSStyleSheet;
pc.replaceSync(":root{\n\t--default-drop-shadow: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));\n\t--default-wrinkled-paper-border-color: #353535;\n\t--disabled-wrinkled-paper-border-color: #919191;\n\t--shop-item-background-color: #f1f1f1;\n\t--shop-item-highlight-color: #fdc570;\n\t--blue-highlight-color: #0c5fcc;\n}\n\nbody, html {\n\t/* Setting overflow to hidden prevents the page from being scrolled by the user.\n\tBut scripts like scrollIntoView() can still cause the page to be scrolled.\n\tTry fixing the element that causet the page to get scrollable rather than setting\n\tthe body to overflow: hidden */\n\t/* overflow: hidden; */\n}\n\n.allow-select {\n\tuser-select: text;\n\t-webkit-user-select: text;\n}\n\n@property --wrinkled-paper-color {\n\tsyntax: '<color>';\n\tinherits: false;\n\tinitial-value: blue;\n}\n\n.fullScreen.safeArea{\n\tleft: 0;\n\tright: 0;\n\ttop: 0;\n\tbottom: 0;\n\tleft: env(safe-area-inset-left);\n\tright: env(safe-area-inset-right);\n\ttop: env(safe-area-inset-top);\n\tbottom: env(safe-area-inset-bottom);\n\twidth: initial;\n\theight: initial;\n}\n\n.mainCanvas{\n\tz-index: -1;\n}\n\n.wrinkledPaper{\n\t--wrinkled-paper-wrinkle-size: 6px;\n\t--wrinkled-paper-color: white;\n\t--wrinkled-paper-border-segments: 0.016;\n\t--wrinkled-paper-tear-count-min: 0.001;\n\t--wrinkled-paper-tear-count-max: 0.003;\n\t--wrinkled-paper-tear-depth-min: 5px;\n\t--wrinkled-paper-tear-depth-max: 15px;\n\t--wrinkled-paper-tear-width-min: 10px;\n\t--wrinkled-paper-tear-width-max: 20px;\n\t--wrinkled-paper-tear-angle-offset-min: 0.7;\n\t--wrinkled-paper-tear-angle-offset-max: 1.1;\n}\n\n.wrinkledLine {\n\t--wrinkled-line-color: black;\n\t--wrinkled-line-width: 1px;\n\t--wrinkled-line-wrinkle-size: 6px;\n\t--wrinkled-line-segments: 0.016;\n}\n\n.dialogCurtain{\n\tbackground: rgba(0,0,0,0.3);\n}\n.dialogCurtain.hidden{\n\tvisibility: hidden;\n\topacity: 0;\n}\n\n.dialogWrapper, .dialog {\n\tdisplay: block;\n\tposition: absolute;\n\tmax-width: 100%;\n\tmin-height: 150px;\n\tmax-height: 100%;\n\tleft: 50%;\n\ttop: 50%;\n\ttransform: translate(-50%, -50%);\n\t-webkit-transform: translate3d(-50%,-50%,0);\n\ttransition: transform 0.2s, opacity 0.2s, visibility 0.2s;\n\ttransition-timing-function: cubic-bezier(0.3, -0.8, 0.7, 1.8);\n}\n\n.dialogWrapper > .dialog {\n\tposition: relative;\n\tleft: 0;\n\ttop: 0;\n\ttransform: initial;\n\t-webkit-transform: initial;\n}\n\n.dialog{\n\tfilter: var(--default-drop-shadow);\n\tpadding: 30px;\n\tbox-sizing: border-box;\n\twidth: fit-content;\n}\n.dialog.hidden, .dialogWrapper.hidden{\n\topacity: 0;\n\ttransform: translate(-50%, -50%) scale(0.95);\n\tvisibility: hidden;\n}\n.dialog.topCenter{\n\ttop: 10px;\n\ttransform: translate(-50%, 0);\n}\n\n.dialog-title-header-container {\n\tdisplay: flex;\n\tgap: 20px;\n}\n\nh2.dialogTitle{\n\tmargin: 0px 0px 20px 0px;\n\tfont-size: 42px;\n}\n\nh3.dialogTitle{\n\tmargin: 0px 0px 10px 0px;\n\tfont-size: 30px;\n}\n\n.dialogButtonsContainer {\n\tmargin-top: 10px;\n\ttext-align: center;\n\tdisplay: flex;\n\tjustify-content: center;\n}\n\n.dialogButtonsContainer.vertical {\n\tflex-direction: column;\n\tmax-width: 300px;\n\tmargin: auto;\n}\n\n.dialog-art-wrapper {\n\twidth: 100%;\n\tmargin: auto;\n}\n\n.dialog-art {\n\twidth: 0;\n\tmin-width: 100%;\n\theight: 100%;\n\tmax-height: 50vh;\n\tobject-fit: contain;\n}\n\n.dialog-art-buttons-container {\n\tdisplay: flex;\n}\n\n@media (min-height: 500px) {\n\t.dialog-art-buttons-container {\n\t\tflex-direction: column;\n\t}\n}\n\n@media (max-width: 500px) and (max-height: 600px) {\n\t.dialog-art-wrapper {\n\t\tdisplay: none;\n\t}\n}\n\n.currency-button {\n\tpadding: 0px 30px;\n}\n\n.currency-container {\n\tdisplay: flex;\n\talign-items: center;\n\tfont-size: 18px;\n\tjustify-content: center;\n}\n\n.coin-icon {\n\twidth: 20px;\n\theight: 20px;\n\tdisplay: inline-block;\n\tbackground-image: url(img/coin.svg);\n\tmargin-right: 5px;\n}\n\n.coin-count-text {\n\tcolor: #fbd413;\n\tfont-weight: 900;\n\t-webkit-text-stroke: 2px #766200;\n\tfilter: drop-shadow(0px 1px #766200);\n\tposition: relative;\n\tletter-spacing: 1px;\n\tfont-size: 20pt;\n}\n\n.coin-count-text::after {\n\tcontent: attr(data-text-content);\n\t-webkit-text-stroke: 0;\n\tfilter: none;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0px;\n}\n\n.dialogTabs {\n\tposition: absolute;\n\ttop: -50px;\n\tleft: 5px;\n\tpointer-events: none;\n}\n\n.dialogTab {\n\tdisplay: inline-block;\n\tpointer-events: auto;\n\ttransition: transform 0.1s;\n\theight: 80px;\n}\n\n.dialogTabSpacer {\n\tdisplay: inline-block;\n\twidth: 20px;\n}\n\n.dialogTab.back {\n\t--wrinkled-paper-color: #d1d1d1;\n}\n\n.dialogTab.front:not(.active), .dialogTab.back.active {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.dialogTab.back:not(.active) {\n\ttransform: translateY(4px);\n\tcursor: pointer;\n}\n\n.dialogTab:not(.active):hover {\n\ttransform: translateY(2px);\n}\n\n.dialogTabIcon {\n\twidth: 60px;\n\theight: 60px;\n\tbackground-size: contain;\n\tbackground-repeat: no-repeat;\n}\n\n.skipDialogText {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 50%;\n\ttransform: translate(-50%, 25px);\n\tcolor: #dddddd;\n\ttext-shadow: 1px 1px #00000073;\n\tfont-size: 16px;\n\tcursor: pointer;\n\twhite-space: nowrap;\n}\n\n.toggle-menu-touch-button {\n\tpadding: 10px;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 110;\n}\n\n.menuButtonsContainer {\n\tmax-width: fit-content;\n}\n\n.main-menu-corner-profile {\n\twidth: 300px;\n\tdisplay: flex;\n\tgap: 10px;\n\tmargin: 10px;\n}\n\n.main-menu-username {\n\tfont-size: 30px;\n}\n\n.main-menu-username:not(.blueNight) {\n\tfont-size: 25px;\n\tfont-weight: bold;\n}\n\n.main-menu-promo-banner-container {\n\ttop: 20px;\n\tright: 20px;\n\tposition: absolute;\n\twidth: 320px;\n\theight: 210px;\n\tfilter: var(--default-drop-shadow);\n}\n.main-menu-promo-banner-container.hidden {\n\tdisplay: none;\n}\n\n@media (max-width: 1200px), (max-height: 700px) {\n\t.main-menu-promo-banner-container {\n\t\twidth: 220px;\n\t\theight: 140px;\n\t}\n}\n\n@media (max-width: 500px), (max-height: 420px) {\n\t.main-menu-promo-banner-container {\n\t\tdisplay: none;\n\t}\n}\n\n.main-menu-promo-banner {\n\twidth: 100%;\n\theight: 100%;\n\tbackground: center / cover, white;\n\t--wrinkled-paper-wrinkle-size: 8px;\n\t--wrinkled-paper-tear-count-min: 0.003;\n\t--wrinkled-paper-tear-count-max: 0.004;\n\tcursor: pointer;\n}\n.main-menu-promo-banner:hover {\n\tfilter: brightness(0.9);\n}\n.main-menu-promo-banner:active {\n\tfilter: brightness(0.85);\n}\n\n.main-menu-promo-button {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 50%;\n\ttransform: translate(-50%, 50%);\n\tmargin: 0;\n}\n\n.gameAd{\n\tposition: absolute;\n\tbottom: 0;\n\tmargin-bottom: 20px;\n\tleft: 50%;\n\ttransform: translate(-50%);\n\tbackground: #0000004f;\n\tz-index: 20;\n}\n.gameAd.desktop{\n\twidth: 728px;\n\theight: 90px;\n}\n.gameAd.mobile{\n\twidth: 320px;\n\theight: 50px;\n\tdisplay: none;\n}\n@media(max-width: 1220px){\n\t.gameAd.desktop{\n\t\tdisplay: none;\n\t}\n\t.gameAd.mobile{\n\t\tdisplay: inherit;\n\t}\n}\n.gameAd.hidden{\n\tdisplay: none;\n}\n\n.shake-anim {\n\tanimation: 2.5s linear infinite shake;\n}\n\n@keyframes shake {\n\t0% { transform: rotate(0deg); }\n\t4% { transform: rotate(4deg); }\n\t8% { transform: rotate(-3deg); }\n\t12% { transform: rotate(2deg); }\n\t16% { transform: rotate(1deg); }\n\t20% { transform: rotate(0deg); }\n}\n\n.crosshairContainer{\n\tposition: absolute;\n\tleft: 50%;\n\ttop: 50%;\n\tz-index: 100;\n\ttransform: translate(-50%, -50%);\n\tpointer-events: none;\n}\n.crosshairLine{\n\tposition: absolute;\n\twidth: 15px;\n\theight: 2px;\n\tbackground: white;\n\tborder: 2px solid black;\n\tborder-radius: 10px;\n\ttransform-origin: left;\n\twill-change: transform;\n}\n.flagReturnProgressContainer {\n\tposition: absolute;\n\ttransform: translate(-50%, -50%);\n\ttransition: opacity 0.2s;\n}\n.flagReturnProgressContainer.hidden{\n\topacity: 0;\n}\n.flagReturnProgressPath {\n\tfill: none;\n\tstroke-width: 10px;\n\tstroke-linecap: round;\n}\n\n.flagScoreContainer{\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tz-index: 100;\n\tmargin: 30px;\n\tfilter: var(--default-drop-shadow);\n\tpointer-events: none;\n}\n\n.flagScoreItem{\n\tmargin: 3px;\n\tdisplay: flex;\n}\n\n.flagScoreIcon{\n\theight: 50px;\n\twidth: 50px;\n\ttransform: translateY(-5px);\n}\n\n.flagScorePointEl{\n\twidth: 40px;\n\theight: 40px;\n\talign-self: center;\n}\n\n.healthUiContainer{\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tmargin: 30px;\n\twidth: 330px;\n\theight: 50px;\n\tz-index: 100;\n\tpointer-events: none;\n}\n\n.healthUiBorder{\n\tbackground: url(img/healthUiBorder.svg);\n\twidth: 100%;\n\theight: 100%;\n\tposition: absolute;\n\tfilter: var(--default-drop-shadow);\n}\n\n.healthUiBarContainer{\n\tbackground: black;\n\twidth: 276px;\n\theight: 20px;\n\tposition: absolute;\n\ttop: 15px;\n\tleft: 37px;\n\toverflow: hidden;\n}\n\n.healthUiBar{\n\twidth: 100%;\n\theight: 100%;\n\tbackground: #e81d25;\n\tbackground: linear-gradient(90deg, #740e12 33.333%, #ae161c 33.334%, #ae161c 66.666%, #e81d25 66.667%);\n}\n\n.gameplayBottomText{\n\tfont-size: 45px;\n\tposition: absolute;\n\tleft: 0;\n\twidth: 100%;\n\tbottom: 25px;\n\ttext-align: center;\n\tpointer-events: none;\n}\n\n.scoreBoardContainer{\n\tbackground: white;\n}\n\n.notificationIconsUiContainer{\n\twidth: 200px;\n\theight: 200px;\n\tpointer-events: none;\n}\n\n.notificationIconsUiContainer.topleft{\n\tleft: 0;\n\ttop: 80px;\n\tposition: absolute;\n\ttransform-origin: top left;\n}\n\n.notificationIconsUiContainer.centerbig{\n\tleft: 50%;\n\ttop: 50%;\n\twidth: 50vw;\n\theight: min(50vw, 100vh);\n\tposition: absolute;\n\ttransform: translate(-50%, -50%);\n}\n\n.notificationIconsUiContainer.crosshair{\n\tleft: 50%;\n\ttop: 50%;\n\twidth: 200px;\n\theight: 200px;\n\tposition: absolute;\n\ttransform: translate(-50%, -50%) translateY(-140px);\n}\n\n.notificationIcon{\n\tfilter: var(--default-drop-shadow);\n\tanimation: 1s notificationIconFade 6s both, 0.2s notificationIconPop;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-position: center;\n\tbackground-repeat: no-repeat;\n}\n\n.crosshair > .notificationIcon{\n\tanimation: 1s notificationIconFade 0.5s both, 0.2s notificationIconPop;\n}\n\n@keyframes notificationIconPop{\n\t0%{\n\t\ttransform: scale(1);\n\t}\n\t50%{\n\t\ttransform: scale(1.2);\n\t}\n\t100%{\n\t\ttransform: scale(1);\n\t}\n}\n@keyframes notificationIconFade{\n\t0%{\n\t\topacity: 1;\n\t}\n\n\t100%{\n\t\topacity: 0;\n\t}\n}\n\n.score-offset-notifications-container {\n\tpointer-events: none;\n\toverflow: hidden;\n}\n\n.score-offset-notifications-list {\n\tfont-size: 30px;\n\ttext-align: center;\n\ttop: 20%;\n\tposition: absolute;\n\twidth: 100%;\n}\n\n.scoreOffsetNotification {\n\tposition: absolute;\n\twidth: 100%;\n\ttransition: transform 0.5s;\n}\n\n.scoreOffsetNotificationScore {\n\tcolor: #b0e9b0;\n}\n\n.touchInputWhiteBorder{\n\tbackground: #00000047;\n\tborder-radius: 150px;\n\tbox-sizing: border-box;\n\tborder: solid white;\n\tpointer-events: none;\n}\n\n.touchInputJoyStickContainer{\n\twidth: 150px;\n\theight: 150px;\n\tposition: absolute;\n\ttransition: opacity 0.3s;\n}\n\n.touchInputJoyStick{\n\twidth: 60px;\n\theight: 60px;\n\tleft: 50%;\n\ttop: 50%;\n\tbackground: white;\n\tborder-radius: 60px;\n\tposition: absolute;\n\ttransform: translate(-50%, -50%);\n}\n\n.touchInputButton{\n\twidth: 70px;\n\theight: 70px;\n\tposition: absolute;\n}\n\n.touchInputButton.touching{\n\tbackground: #ffffff47;\n}\n\n@media(max-width: 700px), (max-height: 450px){\n\t.healthUiContainer{\n\t\tmargin: 10px;\n\t\ttransform: scale(0.5) translateX(60px);\n\t\ttransform-origin: top left;\n\t}\n\n\t.flagScoreContainer{\n\t\tmargin: 10px;\n\t\ttransform: scale(0.5);\n\t\ttransform-origin: top right;\n\t}\n\n\t.notificationIconsUiContainer{\n\t\ttransform: scale(0.5);\n\t}\n\n\t.notificationIconsUiContainer.topleft{\n\t\ttop: 40px;\n\t}\n}\n\n.screenFlash{\n\tpointer-events: none;\n\tbackground: red;\n\topacity: 0;\n}\n\n.settingsItem{\n\tdisplay: flex;\n\tmargin-bottom: 6px;\n\tflex-wrap: wrap;\n}\n.settingsItemText{\n\tdisplay: inline;\n\tflex-grow: 1;\n\tflex-shrink: 0;\n\twidth: 200px;\n}\n.settingsItemSlider{\n\tdisplay: inline;\n\twidth: 220px;\n\tflex-shrink: 0;\n}\n.settingsItemSlider > input{\n\twidth: 170px;\n}\n.settingsItemSliderValue{\n\tdisplay: inline-block;\n\twidth: 40px;\n\ttext-align: right;\n}\n\n.settings-list {\n\toverflow: auto;\n\tmax-height: min(250px, 40vh);\n}\n\n.playersListTeamWonTitle{\n\ttext-align: center;\n\tfont-size: 34px;\n\tmargin: 0;\n}\n\n.playersListContainer{\n\toverflow: auto;\n\tmax-height: 600px;\n\tdisplay: flex;\n\tgap: 20px;\n\talign-items: flex-start;\n}\n\n@media(max-width: 1000px){\n\t.playersListContainer{\n\t\tflex-direction: column;\n\t}\n}\n\n.playersListTeam{\n\t--wrinkled-paper-wrinkle-size: 4px;\n\twidth: 550px;\n}\n\n.itemsTable{\n\tborder-collapse: collapse;\n}\n\n.playersListHead{\n\tcolor: white;\n}\n\n.itemsTable > tbody > tr:nth-child(even){\n\t--wrinkled-paper-wrinkle-size: 2px;\n\t--wrinkled-paper-color: #ffffff6b;\n}\n\n.itemsTable > tbody > tr > td:first-child{\n\tpadding-left: 10px;\n}\n.itemsTable > tbody > tr > td:last-child{\n\tpadding-right: 10px;\n}\n\n.itemsTable > tbody > tr > td, .playersListHead > th{\n\tpadding: 10px 0px;\n}\n\n.player-list-avatar {\n\twidth: 40px;\n\theight: 40px;\n\tbackground-size: contain;\n}\n\n.players-list-label{\n\tcolor: white;\n\tbackground: #909090;\n\tpadding: 2px 3px;\n\tfont-size: 13px;\n\tmargin-left: 7px;\n\tborder-radius: 3px;\n}\n\n.players-list-item-username {\n\tdisplay: flex;\n\tmax-width: 200px;\n\talign-items: center;\n}\n\n.player-list-username {\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap;\n}\n\n.player-name-verified-icon {\n\tmargin-left: 5px;\n\twidth: 20px;\n\theight: 20px;\n\tbackground-repeat: no-repeat;\n\tbackground-image: url(img/menuUI/verified.svg);\n}\n\n.playersListItem > td:first-child {\n\tpadding: 0px;\n}\n\n.playersListItemScore{\n\ttext-align: center;\n}\n\n.gameoverStatsContainer {\n\t--wrinkled-paper-color: #cdcdcd;\n\twidth: fit-content;\n\tmargin: auto;\n\toverflow: auto;\n}\n\n.gameOverStatsTable {\n\twidth: 240px;\n}\n\n.game-over-stats-coins-container {\n\tdisplay: flex;\n\tgap: 10px;\n\tjustify-content: center;\n\tmargin-top: 20px;\n}\n\n.totalScoreRow {\n\tfont-weight: bold;\n}\n\n.ownedCoinsContainer {\n\tposition: absolute;\n\ttop: -20px;\n\tright: -20px;\n\tpadding: 10px;\n\tfilter: var(--default-drop-shadow);\n}\n\n.weaponSelectionDialog{\n\tbottom: 130px;\n\ttop: inherit;\n\ttransform: translate(-50%, 0px);\n\ttransform-origin: bottom;\n}\n.weaponSelectionDialog.hidden{\n\ttransform: translate(-50%, 0px) scale(0.95);\n}\n\n@media(max-width: 1220px){\n\t.weaponSelectionDialog{\n\t\tbottom: 90px;\n\t\ttransform: translate(-50%, 0px) scale(0.5);\n\t}\n\t.weaponSelectionDialog.hidden{\n\t\ttransform: translate(-50%, 0px) scale(0.45);\n\t}\n}\n.weaponSelectionContainer{\n\tdisplay: flex;\n\tgap: 10px;\n}\n\n.weaponSelectionItem{\n\ttransition: transform 0.2s;\n\ttransition-timing-function: cubic-bezier(0.0, 0.0, 0.0, 1.8);\n\t--wrinkled-paper-color: #d8d8d8;\n\t--wrinkled-paper-border-segments: 0.02;\n\t--wrinkled-paper-banner-color: #0000001c;\n\t--wrinkled-paper-banner-size: 17px;\n\t--wrinkled-paper-border-size: 8px;\n\t--wrinkled-paper-border-color: #0000002b;\n\tposition: relative;\n\tfilter: var(--default-drop-shadow);\n}\n\n.weaponSelectionItem.selected{\n\ttransform: scale(1.1);\n\t--wrinkled-paper-color: #bfbfbf;\n}\n.weaponSelectionItem:not(.selected){\n\tfilter: brightness(0.8);\n}\n.weaponSelectionItem:not(.selected):hover{\n\tfilter: brightness(0.9);\n}\n\n.weaponSelectionItemKeyNumber{\n\tposition: absolute;\n\tmargin: 9px;\n\tcolor: white;\n\ttop: 0;\n\tright: 0;\n}\n\n.weaponSelectionItemIcon{\n\twidth: 80px;\n\theight: 80px;\n\tmargin: 5px;\n}\n\n.text-with-submit-form {\n\tdisplay: flex;\n\tgap: 5px;\n\twidth: 100%;\n\tpadding: 4px 10px;\n\tbox-sizing: border-box;\n}\n\n.text-with-submit-form > * {\n\tmargin-left: 0;\n\tmargin-right: 0;\n}\n\n.text-with-submit-form > button {\n\tpadding-left: 10px;\n\tpadding-right: 10px;\n}\n\n.skin-downloader-dialog-content {\n\tmax-width: 600px;\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\talign-items: center;\n}\n\n.skin-downloader-dialog-controls {\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n.skin-downloader-dialog-controls > * {\n\theight: 30px;\n}\n\n.skin-downloader-size-input {\n\twidth: 50px;\n}\n\n.skin-downloader-download-container {\n\tpadding: 10px;\n\talign-self: center;\n}\n\n.downloadable-skin-preview {\n\twidth: 250px;\n\theight: 250px;\n\tbackground-size: contain;\n\tbackground-repeat: no-repeat;\n\tflex-shrink: 0;\n}\n\n.af-mirror > #mainMenu,\n.af-mirror > .mainCanvas {\n\ttransform: scale(-1, 1);\n}\n\n.af-mirror > .dialog,\n.af-mirror > .dialogWrapper {\n\ttransform: translate(-50%, -50%) scale(-1, 1);\n}\n\n.af-mirror> .weaponSelectionDialog{\n\ttransform: translate(-50%, 0px) scale(-1, 1);\n}\n.af-mirror > .weaponSelectionDialog.hidden{\n\ttransform: translate(-50%, 0px) scale(-0.95, 0.95);\n}\n\n@media(max-width: 1220px){\n\t.af-mirror > .weaponSelectionDialog{\n\t\ttransform: translate(-50%, 0px) scale(-0.5, 0.5);\n\t}\n\t.af-mirror > .weaponSelectionDialog.hidden{\n\t\ttransform: translate(-50%, 0px) scale(-0.45, 0.45);\n\t}\n}\n.af-mirror > .dialog.topCenter{\n\ttransform: translate(-50%, 0) scale(-1, 1);\n}\n\n.shop-paged-view-container {\n\twidth: 340px;\n\theight: 300px;\n\tposition: relative;\n\toverflow: hidden;\n}\n");
const mc = new CSSStyleSheet;
mc.replaceSync('.dialog-button,\n.icon-button {\n\tborder: none;\n\tappearance: none;\n}\n\n.dialog-button,\n.main-menu-button {\n\t-webkit-tap-highlight-color: transparent;\n}\n\n.dialog-button{\n\tpadding: 7px 30px;\n\tmargin: 4px 10px;\n\tfont-size: 24px;\n\theight: 38px;\n\tcolor: var(--default-wrinkled-paper-border-color);\n\tvertical-align: middle;\n\twhite-space: nowrap;\n\t--wrinkled-paper-border-size: 3;\n\t--wrinkled-paper-border-size-bottom: 6;\n\t--wrinkled-paper-border-color: var(--default-wrinkled-paper-border-color);\n\t--wrinkled-paper-seed: 70;\n\t--wrinkled-paper-wrinkle-size: 2px;\n\t--wrinkled-paper-border-segments: 0.02;\n\t--wrinkled-paper-tear-count-min: 0;\n\t--wrinkled-paper-tear-count-max: 0;\n}\n.dialog-button:hover:not(:disabled){\n\tfilter: brightness(0.9);\n}\n.dialog-button:active:not(:disabled){\n\tfilter: brightness(0.8);\n}\n\n.dialog-button:not(:disabled){\n\tcursor: pointer;\n}\n\n.dialog-button:disabled {\n\t--wrinkled-paper-border-color: #959595;\n\tcolor: #959595;\n}\n\n.dialog-button:disabled > .currency-container, .dialog-button:disabled > .dialog-button-icon {\n\topacity: 0.5;\n}\n\n.dialog-button-icon {\n\twidth: 20px;\n\theight: 20px;\n\tdisplay: inline-block;\n\tbackground-size: contain;\n\tbackground-position: center;\n\tbackground-repeat: no-repeat;\n\tmargin-right: 10px;\n\tvertical-align: middle;\n}\n\n.icon-button {\n\tcursor: pointer;\n\tbackground: transparent;\n\tbackground-repeat: no-repeat;\n\tbackground-position: center;\n}\n\n.icon-button:hover {\n\topacity: 0.7;\n}\n.icon-button:active {\n\topacity: 0.6;\n}\n\n.header-button {\n\tpadding: 0;\n}\n\n.icon-button > .dialog-button-icon,\n.header-button > .dialog-button-icon {\n\twidth: 20px;\n\theight: 20px;\n\tmargin: 3px;\n}\n\n.header-back-button > .dialog-button-icon {\n\twidth: 30px;\n}\n\n\n.main-menu-button-container {\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.main-menu-button{\n\tborder: none;\n\twidth: 70px;\n\theight: 70px;\n\tcursor: pointer;\n\tmargin: 5px;\n\tpadding: 0;\n\t--wrinkled-paper-border-segments: 0.04;\n\t--wrinkled-paper-wrinkle-size: 5px;\n\t--wrinkled-paper-tear-count-min: 0.003;\n\t--wrinkled-paper-tear-count-max: 0.004;\n\t--wrinkled-paper-border-size: 3;\n\t--wrinkled-paper-border-size-bottom: 6;\n\t--wrinkled-paper-border-color: var(--default-wrinkled-paper-border-color);\n\t--wrinkled-paper-tear-count-min: 0;\n\t--wrinkled-paper-tear-count-max: 0;\n\tfilter: var(--default-drop-shadow);\n}\n.main-menu-button:hover{\n\tfilter: var(--default-drop-shadow) brightness(0.9);\n}\n.main-menu-button:active{\n\tfilter: var(--default-drop-shadow) brightness(0.8);\n}\n\n.main-menu-button-text {\n\tcolor: white;\n\tfont-size: 30px;\n}\n\n.buttonImage{\n\twidth: 100%;\n\theight: 100%;\n\tbackground-size: contain;\n\tbackground-repeat: no-repeat;\n\tbackground-position: center;\n}\n\n.dialog-text-input,\n.dialog-select-wrapper,\n.dialog-checkbox-input,\n.dialog-toggle-input {\n\t--wrinkled-paper-border-size: 3;\n\t--wrinkled-paper-border-size-bottom: 4;\n\t--wrinkled-paper-border-color: var(--default-wrinkled-paper-border-color);\n\t--wrinkled-paper-seed: 70;\n\t--wrinkled-paper-wrinkle-size: 2px;\n\t--wrinkled-paper-border-segments: 0.02;\n\t--wrinkled-paper-border-color-top-extra: #e2e2e2;\n\t--wrinkled-paper-border-size-top-extra: 10;\n\t--wrinkled-paper-tear-count-min: 0;\n\t--wrinkled-paper-tear-count-max: 0;\n}\n.dialog-checkbox-input:focus-visible,\n.dialog-toggle-input:focus-visible,\n.dialog-text-input:focus-visible,\n.dialog-button:focus-visible,\n.main-menu-button:focus-visible,\n.dialog-select-wrapper:has(> select:focus-visible) {\n\toutline: none;\n\t--wrinkled-paper-border-color: var(--blue-highlight-color);\n\t--wrinkled-paper-border-size: 5;\n\t--wrinkled-paper-border-size-bottom: 7;\n}\n.icon-button:focus-visible {\n\toutline: var(--blue-highlight-color) auto 1px;\n}\n.dialog-text-input:disabled,\n.dialog-checkbox-input:disabled,\n.dialog-toggle-input:disabled {\n\t--wrinkled-paper-border-color: var(--disabled-wrinkled-paper-border-color);\n}\n\n.dialog-text-input {\n\tpadding: 7px;\n\tmargin: 4px 10px;\n\tfont-size: 24px;\n\theight: 38px;\n\tborder: none;\n\tbox-sizing: border-box;\n}\n\n.dialog-checkbox-input,\n.dialog-toggle-input {\n\tappearance: none;\n\twidth: 30px;\n\theight: 30px;\n\tdisplay: grid;\n\tplace-content: center;\n}\n.dialog-toggle-input {\n\twidth: 45px;\n}\n.dialog-checkbox-input:active:not(:disabled),\n.dialog-toggle-input:active:not(:disabled) {\n\t--wrinkled-paper-color: #e7e7e7;\n}\n.dialog-checkbox-input:checked::before {\n\tcontent: "";\n\twidth: 20px;\n\theight: 20px;\n\tbackground-image: url(img/menuUI/check.svg);\n\tbackground-size: contain;\n}\n.dialog-checkbox-input:checked:disabled::before,\n.dialog-toggle-input:checked:disabled::before {\n\topacity: 0.5;\n}\n.dialog-toggle-input {\n\t--wrinkled-paper-extra-box-color: white;\n\t--wrinkled-paper-extra-box-size: 10px;\n\t--wrinkled-paper-extra-box-border-color: var(--default-wrinkled-paper-border-color);\n\t--wrinkled-paper-extra-box-border-size: 2;\n\t--wrinkled-paper-extra-box-side: left;\n}\n.dialog-toggle-input:checked {\n\t--wrinkled-paper-extra-box-side: right;\n}\n\n.dialog-select-input {\n\tappearance: none;\n\toutline: none;\n\tborder: none;\n\tpadding: 8px 25px 8px 8px;\n\tfont-size: 14pt;\n\tbackground: url(img/downArrowSmall.svg) no-repeat right center;\n}\n');
const gc = new CSSStyleSheet;
gc.replaceSync('.paged-view-page {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\ttransition: opacity 0.3s, transform 0.3s;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n}\n\n.paged-view-page.hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n.paged-view-page.hiddenleft {\n\ttransform: translateX(-20%);\n}\n\n.paged-view-page.hiddenright {\n\ttransform: translateX(20%);\n}\n\n.paged-view-page-header {\n\tdisplay: grid;\n\twidth: 100%;\n\tgrid-template-columns: 40px 1fr auto;\n\tgrid-template-areas: "back-button header-title header-corner";\n}\n.paged-view-page-header > * {\n\talign-self: center;\n\tjustify-self: center;\n}\n\n.paged-view-page-back-button {\n\twidth: 30px;\n\theight: 30px;\n\tbackground-image: url(img/arrow.svg);\n}\n\n.paged-view-page-header-title {\n\tgrid-area: header-title;\n\tfont-size: 24pt;\n\tmargin: 15px;\n}\n\n.paged-view-page-header-corner {\n\tgrid-area: header-corner;\n}\n\n.paged-view-page-header-line {\n\theight: 20px;\n\twidth: 100%;\n}\n\n.paged-view-page-items-list {\n\tdisplay: flex;\n\tflex-direction: column;\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tmax-width: 300px;\n}\n\n.paged-view-page-custom-subpage,\n.paged-view-page-items-list {\n\twidth: 100%;\n\theight: 100%;\n\toverflow-y: scroll;\n}\n');
const fc = new CSSStyleSheet;
fc.replaceSync(".maps-container {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n\trow-gap: 40px;\n\tcolumn-gap: 20px;\n\twidth: 80vw;\n\tmax-width: 660px;\n\toverflow-y: scroll;\n\tmax-height: 80vh;\n}\n\n.map-item {\n\twidth: 200px;\n\tposition: relative;\n}\n\n.map-item-title {\n\tfont-size: 30pt;\n\tmargin: 0;\n\tmargin-bottom: 5px;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.map-item-thumb {\n\twidth: 200px;\n\theight: 100px;\n\tbackground: center / cover, white;\n\t--wrinkled-paper-wrinkle-size: 8px;\n\t--wrinkled-paper-tear-count-min: 0.003;\n\t--wrinkled-paper-tear-count-max: 0.004;\n\tfilter: var(--default-drop-shadow);\n}\n\n.map-item-join-button {\n\tposition: absolute;\n\tleft: 50%;\n\tbottom: 0;\n\ttransform: translate(-50%, 50%);\n\tmargin: 0;\n}\n");
const yc = new CSSStyleSheet;
yc.replaceSync(".shopDialogContent{\n\tdisplay: flex;\n\talign-items: stretch;\n\tmax-width: 80vw;\n\twidth: max-content;\n\tgap: 10px;\n}\n\nh2.shop-presets-title {\n\tmargin: 0;\n}\n\n.shop-skin-selection-list {\n\tdisplay: flex;\n\toverflow-x: scroll;\n\tmax-width: 700px;\n\tscroll-behavior: smooth;\n}\n\n@media (min-height: 650px) and (min-width: 800px) {\n\t.shop-class-selection-list {\n\t\toverflow-x: initial;\n\t\tflex-wrap: wrap;\n\t\tjustify-content: center;\n\t\twidth: 700px;\n\t}\n}\n\n.shop-skin-selection-item {\n\tposition: relative;\n\tmin-width: 200px;\n\tmin-height: 320px;\n\tmargin: 10px;\n}\n\n.shop-skin-selection-image {\n\tmin-width: 200px;\n\tmin-height: 300px;\n}\n\n.shop-class-selection-item {\n\tmin-height: 240px;\n}\n\n.shop-skin-selection-list-add-button {\n\talign-self: center;\n}\n\n.shop-skin-selection-edit-button {\n\tposition: absolute;\n    left: 50%;\n    bottom: 0px;\n    transform: translate(-50%, 0);\n    margin: 0px;\n}\n\n.corner-delete-button {\n\tposition: absolute;\n\ttop: 0;\n\tright: 0;\n\tpadding: 8px;\n\tfont-size: 12pt;\n\theight: auto;\n\tmargin: 0;\n}\n\n.shop-items-grid-view{\n\tdisplay: grid;\n\tgrid-template-columns: repeat(auto-fit, 100px);\n\tgrid-gap: 5px;\n\twidth: 100%;\n\theight: fit-content;\n\tmax-height: 300px;\n\tjustify-content: center;\n}\n\n.shopItem{\n\tborder: none;\n\twidth: 100px;\n\theight: 100px;\n\tposition: relative;\n\ttransition: --wrinkled-paper-color 2s;\n\t--wrinkled-paper-color: #e3e3e3;\n}\n\n.shopItemUsage-confirmPurchase {\n\tmargin: auto;\n\twidth: 200px;\n\theight: 200px;\n}\n\n.shopItem.selected{\n\t--wrinkled-paper-color: #c0c0c0;\n\t--wrinkled-paper-border-size: 3;\n\t--wrinkled-paper-border-color: var(--default-wrinkled-paper-border-color);\n}\n.shopItem:focus-visible {\n\toutline: none;\n\t--wrinkled-paper-border-size: 3;\n\t--wrinkled-paper-border-color: var(--blue-highlight-color);\n}\n\n.shopItem:not(.shopItemUsage-confirmPurchase):not(.selected.preventUnequip) {\n\tcursor: pointer;\n}\n.shopItem:hover:not(.shopItemUsage-confirmPurchase):not(.selected.preventUnequip) {\n\tfilter: brightness(0.9);\n}\n.shopItem:active:not(.shopItemUsage-confirmPurchase):not(.selected.preventUnequip) {\n\tfilter: brightness(0.85);\n}\n\n.shopItemStatClassesContainer {\n\tposition: absolute;\n\ttop: 3px;\n\tleft: 3px;\n}\n\n.shopItemStatClassIcon {\n\twidth: 30px;\n\theight: 30px;\n}\n\n.shopItemLocked:not(.shopItemUsage-confirmPurchase) {\n\t--wrinkled-paper-color: var(--shop-item-background-color);\n}\n\n.shopItem.highlight:not(.shopItemUsage-confirmPurchase) {\n\tanimation: shop-item-highlight 5s;\n}\n\n@keyframes shop-item-highlight {\n\t0% {\n\t\t--wrinkled-paper-color: var(--shop-item-highlight-color);\n\t}\n\t50% {\n\t\t--wrinkled-paper-color: var(--shop-item-highlight-color);\n\t}\n\t100% {\n\t\t--wrinkled-paper-color: var(--shop-item-background-color);\n\t}\n}\n\n.shopItemLocked:not(.shopItemUsage-confirmPurchase) > canvas {\n\tfilter: grayscale(100%);\n}\n\n.shopItemLock {\n\twidth: 80px;\n\theight: 80px;\n\tposition: absolute;\n\tleft: 50%;\n\ttop: 50%;\n\ttransform: translate(-50%, -50%);\n\tbackground: url(img/menuUI/shop/lock.svg);\n\topacity: 0.3;\n}\n.shopItemLock.rewarded-break-unlockable {\n\twidth: 60px;\n\theight: 60px;\n\tbackground: url(img/rewardedAdIcon.svg);\n}\n\n.shopItem:hover > .shopItemLock {\n\topacity: 0.8;\n}\n\n.shopItemOwned > .shopItemLock, .shopItemUsage-confirmPurchase > .shopItemLock {\n\tdisplay: none;\n}\n\n.shopItem > .currency-container {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 50%;\n\ttransform: translateX(-50%);\n}\n\n.shopSkinPreview{\n\tdisplay: inline-block;\n\tmin-width: 200px;\n\tbackground: #0088ff;\n\tposition: relative;\n}\n\n.shop-skin-preview-canvas {\n\tdisplay: block;\n}\n\n.shop-skin-preview-download-button {\n\twidth: 50px;\n\theight: 50px;\n\tbackground: url(img/menuUI/download.svg);\n\tposition: absolute;\n\tbottom: 0;\n\tright: 0;\n\tcursor: pointer;\n\topacity: 0.4;\n}\n.shop-skin-preview-download-button:hover {\n\topacity: 0.7;\n}\n\n.shop-gender-toggle-container {\n\tdisplay: flex;\n\talign-items: center;\n}\n.gender-icon{\n\twidth: 25px;\n\theight: 25px;\n\tbackground: no-repeat center;\n}\n.gender-icon.male {\n\tbackground-image: url(img/menuUI/shop/male.svg);\n}\n.gender-icon.female {\n\tbackground-image: url(img/menuUI/shop/female.svg);\n}\n\n.shop-color-buttons-corner {\n\tdisplay: flex;\n}\n\n.shop-color-button {\n\twidth: 20px;\n\theight: 20px;\n\tmargin: 0 1px;\n\tappearance: none;\n\tborder-radius: 100px;\n\toutline: none;\n\tborder: 2px solid var(--default-wrinkled-paper-border-color);\n\tpadding: 0;\n\tbox-shadow: 0px 1px var(--default-wrinkled-paper-border-color);\n\tcursor: pointer;\n}\n\n.shop-color-button:hover {\n\tfilter: brightness(120%);\n}\n");
const vc = new CSSStyleSheet;
vc.replaceSync(".squad-split-container {\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: stretch;\n\tmargin-bottom: 30px;\n}\n\n.squad-split-divider {\n\tdisplay: flex;\n\tflex-direction: column;\n\ttext-align: center;\n\tmargin: 0px 15px;\n}\n\n.squad-split-divider-line {\n\twidth: 19px;\n\tflex-grow: 1;\n\t--wrinkled-line-direction: vertical;\n\t--wrinkled-line-segments: 0.05;\n\t--wrinkled-line-wrinkle-size: 6px;\n}\n\n.squad-split-section {\n\twidth: 234px;\n\ttext-align: center;\n\tmargin: auto;\n}\n\n.squad-id-container {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tgap: 7px;\n}\n\n.squad-id-button {\n\twidth: 20px;\n\theight: 20px;\n}\n\n.copy-squad-url-button {\n\tbackground-image: url(img/menuUI/copy.svg);\n\tposition: relative;\n}\n\n.squad-id-copied-text {\n\tposition: absolute;\n\tleft: 50%;\n\ttop: 50%;\n\ttransform: translate(-50%, -50%);\n\tdisplay: none;\n}\n.squad-id-copied-text.animating {\n\tdisplay: inherit;\n\tanimation-name: copy-squad-url-button-animation;\n\tanimation-duration: 1s;\n\tanimation-fill-mode: both;\n}\n\n@keyframes copy-squad-url-button-animation {\n\t0% {\n\t\topacity: 1;\n\t\ttransform: translate(-50%, -50%);\n\t}\n\t100% {\n\t\topacity: 0;\n\t\ttransform: translate(-50%, -50%) translateY(-30px);\n\t}\n}\n\n.squad-id {\n\tfont-size: 20pt;\n}\n\n.join-squad-input {\n\twidth: 100%;\n\ttext-align: center;\n}\n\n.in-squad-content {\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: flex-start;\n}\n\n.squad-settings-button {\n\tbackground-image: url(img/menuUI/settings.svg);\n\twidth: 30px;\n\theight: 30px;\n\tposition: absolute;\n\tright: 20px;\n\tbottom: 20px;\n}\n\n.squad-players-list {\n\tbackground: #cdcdcd !important;\n\toverflow: auto;\n\tflex-grow: 1;\n\tmax-width: 250px;\n\tmax-height: min(300px, 30vh);\n}\n\n.squad-players-list > table {\n\twidth: 100%;\n}\n\n.squad-players-list > table > tbody > tr > .squad-players-leader-container {\n\twidth: 20px;\n}\n\n.squad-players-list > table > tbody > tr > .squad-players-avatar-container {\n\twidth: 40px;\n\tpadding: 0px;\n}\n\n.squad-leader-icon {\n\tbackground: url(img/menuUI/crown.svg) no-repeat center;\n\twidth: 15px;\n\theight: 15px;\n}\n\n.in-squad-buttons {\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-self: flex-end;\n}\n\n.in-squad-buttons.hidden {\n\tdisplay: none;\n}\n\n@media (max-width: 520px) {\n\t.squad-split-container {\n\t\tflex-direction: column;\n\t}\n\n\t.squad-split-divider {\n\t\tflex-direction: row;\n\t\tmargin: 15px 0px;\n\t}\n\n\t.squad-split-divider-line {\n\t\t--wrinkled-line-direction: horizontal;\n\t}\n\n\t.in-squad-content {\n\t\tflex-direction: column;\n\t\talign-items: stretch;\n\t}\n\n\t.in-squad-buttons {\n\t\tflex-flow: row wrap;\n\t\talign-self: auto;\n\t}\n\n\t.squad-split-divider-line {\n\t\t--wrinkled-line-wrinkle-size: 3px;\n\t}\n\n\t.squad-split-divider > span {\n\t\tmargin: 0px 10px;\n\t}\n\n\t.squad-players-list {\n\t\tmax-width: 100%;\n\t}\n\n\n\t.squad-settings-button {\n\t\tright: 20px;\n\t\ttop: 20px;\n\t\tbottom: initial;\n\t}\n}\n\n.squad-settings-leader-only-message {\n\tmax-width: 200px;\n\tmargin-bottom: 20px;\n}\n");
const wc = new CSSStyleSheet;
wc.replaceSync(".class-selection-image-container {\n\tposition: relative;\n\tmin-width: 200px;\n\tmin-height: 200px;\n}\n\n.class-selection-image-container.in-game {\n\tmin-width: 100px;\n\tmin-height: 100px;\n}\n\n.class-selection-image,\n.class-selection-image-background {\n\tposition: absolute;\n\tinset: 0;\n}\n\n.class-selection-image {\n\tbackground-size: contain;\n}\n\n.class-selection-image-background {\n\t--wrinkled-paper-color: #d8d8d8;\n\t--wrinkled-paper-banner-color: #0000001c;\n\t--wrinkled-paper-banner-size: 40px;\n\t--wrinkled-paper-border-size: 20px;\n\t--wrinkled-paper-border-color: #0000002b;\n}\n\n.class-selection-image-container.in-game > .class-selection-image-background {\n\t--wrinkled-paper-banner-size: 20px;\n\t--wrinkled-paper-border-size: 12px;\n}\n\n.class-selection-image-container.in-game > .class-selection-image {\n\tbackground-size: 130%;\n\tbackground-position: 50% 10%;\n}\n");
const bc = new CSSStyleSheet;
bc.replaceSync('#qc-cmp2-ui {\n\tbackground: paint(wrinkledPaper);\n\t--wrinkled-paper-wrinkle-size: 6px;\n\t--wrinkled-paper-color: white;\n\t--wrinkled-paper-border-segments: 0.016;\n\t--wrinkled-paper-tear-count-min: 0.001;\n\t--wrinkled-paper-tear-count-max: 0.003;\n\t--wrinkled-paper-tear-depth-min: 5px;\n\t--wrinkled-paper-tear-depth-max: 15px;\n\t--wrinkled-paper-tear-width-min: 10px;\n\t--wrinkled-paper-tear-width-max: 20px;\n\t--wrinkled-paper-tear-angle-offset-min: 0.7;\n\t--wrinkled-paper-tear-angle-offset-max: 1.1;\n\t--wrinkled-paper-seed: 33;\n}\n\n#qc-cmp2-ui .qc-cmp2-consent-info {\n\tpadding: 30px;\n}\n\n#qc-cmp2-ui h2 {\n\tfont-family: BlueNight, sans-serif;\n\ttext-transform: lowercase;\n\tfont-weight: lighter;\n\tline-height: 0.7em;\n\tfont-size: 26pt;\n}\n\n#qc-cmp2-ui .qc-cmp2-footer {\n\tborder-top: none;\n\tbox-shadow: none;\n}\n\n#qc-cmp2-ui button[mode="primary"] > span,\n#qc-cmp2-ui button[mode="secondary"] > span,\n#qc-cmp2-ui button[mode="primary"],\n#qc-cmp2-ui button[mode="secondary"] {\n\tfont-family: BlueNight, sans-serif;\n\ttext-transform: lowercase;\n\tfont-weight: lighter;\n\tline-height: 0.7em;\n\tfont-size: 18pt;\n\tcursor: pointer;\n}\n\n#qc-cmp2-ui button[mode="primary"],\n#qc-cmp2-ui button[mode="secondary"] {\n\tpadding: 7px 30px;\n    margin: 4px 10px;\n    font-size: 24px;\n    height: 38px;\n    color: var(--default-wrinkled-paper-border-color);\n    white-space: nowrap;\n\n\tborder: none;\n\tappearance: none;\n\tbox-shadow: none;\n\tdisplay: block;\n\ttransition: none;\n\n\tbackground: paint(wrinkledPaper);\n\t--wrinkled-paper-color: white;\n    --wrinkled-paper-border-size: 3;\n    --wrinkled-paper-border-size-bottom: 6;\n    --wrinkled-paper-border-color: var(--default-wrinkled-paper-border-color);\n    --wrinkled-paper-seed: 70;\n    --wrinkled-paper-wrinkle-size: 2px;\n    --wrinkled-paper-border-segments: 0.02;\n    --wrinkled-paper-tear-count-min: 0;\n    --wrinkled-paper-tear-count-max: 0;\n}\n\n#qc-cmp2-ui button[mode="primary"]:hover:not(:disabled),\n#qc-cmp2-ui button[mode="secondary"]:hover:not(:disabled) {\n\tfilter: brightness(0.9);\n}\n#qc-cmp2-ui button[mode="primary"]:active:not(:disabled),\n#qc-cmp2-ui button[mode="secondary"]:active:not(:disabled) {\n\tfilter: brightness(0.8);\n}\n\n@media (min-width: 768px) {\n\t#qc-cmp2-ui button.qc-cmp2-hide-desktop {\n\t\tdisplay: none;\n\t}\n}\n'), document.adoptedStyleSheets = [pc, mc, gc, fc, yc, vc, wc, bc],
    function() {
        let t = "";
        if (window.Intl && Intl.RelativeTimeFormat) {
            const e = new Intl.RelativeTimeFormat,
                i = Date.now() / 1e3 - Number("1659120483");
            t = i < 60 ? e.format(-Math.floor(i), "second") : i < 3600 ? e.format(-Math.floor(i / 60), "minute") : i < 86400 ? e.format(-Math.floor(i / 60 / 60), "hour") : i < 31536e3 ? e.format(-Math.floor(i / 60 / 60 / 24), "day") : e.format(-Math.floor(i / 60 / 60 / 24 / 365), "year"), t = " (" + t + ")"
        }
        console.log("loading v1659120483" + t), dc = new cc, dc.init()
    }();